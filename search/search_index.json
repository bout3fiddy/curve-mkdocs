{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Curve is an exchange liquidity pool on Ethereum. Curve is designed for extremely efficient stablecoin trading and low risk, supplemental fee income for liquidity providers, without an opportunity cost. This documentation outlines the technical implementation of the core Curve protocol and related smart contracts. It may be useful for contributors to the Curve codebase, third party integrators, or technically proficient users of the protocol. Non-technical users may prefer the Resources section of the main Curve website. Note All code starting with $ is meant to be run on your terminal. Code starting with >>> is meant to run inside the Brownie console. Note This project relies heavily upon brownie and the documentation assumes a basic familiarity with it. You may wish to view the Brownie documentation if you have not used it previously. Protocol Overview \u00b6 Curve can be broadly separated into the following categories: StableSwap: Exchange contracts for stable assets CryptoSwap: Exchange contracts for volatile assets The DAO: Protocol governance and value accrual The Registry: Standardized API and on-chain resources to aid 3 rd party integrations","title":"Home"},{"location":"#protocol-overview","text":"Curve can be broadly separated into the following categories: StableSwap: Exchange contracts for stable assets CryptoSwap: Exchange contracts for volatile assets The DAO: Protocol governance and value accrual The Registry: Standardized API and on-chain resources to aid 3 rd party integrations","title":"Protocol Overview"},{"location":"cryptoswap_exchange/overview/","text":"","title":"Overview"},{"location":"curve_dao/overview/","text":"","title":"Overview"},{"location":"factory/admin_controls/","text":"Admin Controls \u00b6 Admin controls Factory.add_base_pool \u00b6 Factory.add_base_pool(_base_pool: address, _fee_receiver: address, _asset_type: uint256, _implementations: address[10]) Add a base pool to the registry, which may be used in factory metapools. Only callable by fatory admin . Input Type Description _base_pool address Pool address to add _fee_receiver address Admin fee receiver address for metapools using this base pool _asset_type uint256 Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other implementations address List of implementation addresses that can be used with this base pool Emits: BasePoolAdded Source code @external def add_base_pool ( _base_pool : address , _fee_receiver : address , _asset_type : uint256 , _implementations : address [ 10 ], ): \"\"\" @notice Add a base pool to the registry, which may be used in factory metapools @dev Only callable by admin @param _base_pool Pool address to add @param _fee_receiver Admin fee receiver address for metapools using this base pool @param _asset_type Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _implementations List of implementation addresses that can be used with this base pool \"\"\" assert msg . sender == self . admin # dev: admin-only function assert self . base_pool_data [ _base_pool ] . coins [ 0 ] == ZERO_ADDRESS # dev: pool exists registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () n_coins : uint256 = Registry ( registry ) . get_n_coins ( _base_pool ) # add pool to pool_list length : uint256 = self . base_pool_count self . base_pool_list [ length ] = _base_pool self . base_pool_count = length + 1 self . base_pool_data [ _base_pool ] . lp_token = Registry ( registry ) . get_lp_token ( _base_pool ) self . base_pool_data [ _base_pool ] . n_coins = n_coins self . base_pool_data [ _base_pool ] . fee_receiver = _fee_receiver if _asset_type != 0 : self . base_pool_data [ _base_pool ] . asset_type = _asset_type for i in range ( 10 ): implementation : address = _implementations [ i ] if implementation == ZERO_ADDRESS : break self . base_pool_data [ _base_pool ] . implementations [ i ] = implementation decimals : uint256 = 0 coins : address [ MAX_COINS ] = Registry ( registry ) . get_coins ( _base_pool ) for i in range ( MAX_COINS ): if i == n_coins : break coin : address = coins [ i ] self . base_pool_data [ _base_pool ] . coins [ i ] = coin self . base_pool_assets [ coin ] = True decimals += shift ( ERC20 ( coin ) . decimals (), convert ( i * 8 , int128 )) self . base_pool_data [ _base_pool ] . decimals = decimals log BasePoolAdded ( _base_pool ) Example >>> todo:","title":"Admin Controls"},{"location":"factory/admin_controls/#admin-controls","text":"Admin controls","title":"Admin Controls"},{"location":"factory/admin_controls/#factoryadd_base_pool","text":"Factory.add_base_pool(_base_pool: address, _fee_receiver: address, _asset_type: uint256, _implementations: address[10]) Add a base pool to the registry, which may be used in factory metapools. Only callable by fatory admin . Input Type Description _base_pool address Pool address to add _fee_receiver address Admin fee receiver address for metapools using this base pool _asset_type uint256 Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other implementations address List of implementation addresses that can be used with this base pool Emits: BasePoolAdded Source code @external def add_base_pool ( _base_pool : address , _fee_receiver : address , _asset_type : uint256 , _implementations : address [ 10 ], ): \"\"\" @notice Add a base pool to the registry, which may be used in factory metapools @dev Only callable by admin @param _base_pool Pool address to add @param _fee_receiver Admin fee receiver address for metapools using this base pool @param _asset_type Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _implementations List of implementation addresses that can be used with this base pool \"\"\" assert msg . sender == self . admin # dev: admin-only function assert self . base_pool_data [ _base_pool ] . coins [ 0 ] == ZERO_ADDRESS # dev: pool exists registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () n_coins : uint256 = Registry ( registry ) . get_n_coins ( _base_pool ) # add pool to pool_list length : uint256 = self . base_pool_count self . base_pool_list [ length ] = _base_pool self . base_pool_count = length + 1 self . base_pool_data [ _base_pool ] . lp_token = Registry ( registry ) . get_lp_token ( _base_pool ) self . base_pool_data [ _base_pool ] . n_coins = n_coins self . base_pool_data [ _base_pool ] . fee_receiver = _fee_receiver if _asset_type != 0 : self . base_pool_data [ _base_pool ] . asset_type = _asset_type for i in range ( 10 ): implementation : address = _implementations [ i ] if implementation == ZERO_ADDRESS : break self . base_pool_data [ _base_pool ] . implementations [ i ] = implementation decimals : uint256 = 0 coins : address [ MAX_COINS ] = Registry ( registry ) . get_coins ( _base_pool ) for i in range ( MAX_COINS ): if i == n_coins : break coin : address = coins [ i ] self . base_pool_data [ _base_pool ] . coins [ i ] = coin self . base_pool_assets [ coin ] = True decimals += shift ( ERC20 ( coin ) . decimals (), convert ( i * 8 , int128 )) self . base_pool_data [ _base_pool ] . decimals = decimals log BasePoolAdded ( _base_pool ) Example >>> todo:","title":"Factory.add_base_pool"},{"location":"factory/deployer_api/","text":"Deployer API \u00b6 Deploy Pool \u00b6 Note After deploying a pool, you must also add initial liquidity before the pool can be used. Factory.deploy_plain_pool \u00b6 Factory.deploy_plain_pool(_name: String[32], _symbol: String[10], _coins: address[4], _A: uint256, _fee: uint256, _asset_type: uint256 = 0, _implementation_idx: uint256 = 0) \u2192 address: nonpayable Deploys a new plain pool. Returns address of the deployed pool. Input Type Description _name String[32] Name of the new plain pool _symbol String[10] Symbol for the new metapool\u2019s LP token. This value will be concatenated with the factory symbol. _coins address[4] List of addresses of the coins being used in the pool _A uint256 Amplification coefficient _fee uint256 Trade fee, given as an integer with 1e10 precision _asset_type uint256 Asset type of the pool as an integer. 0 = USD , 1 = ETH , 2 = BTC , 3 = Other. _implementation_idx uint256 Index of the implementation to use. All possible implementations for a pool of N_COINS can be publicly accessed via plain_implementations(N_COINS) . Emits: PlainPoolDeployed Source code MAX_PLAIN_COINS : constant ( int128 ) = 4 # max coins in a plain pool ... @external def deploy_plain_pool ( _name : String [ 32 ], _symbol : String [ 10 ], _coins : address [ MAX_PLAIN_COINS ], _A : uint256 , _fee : uint256 , _asset_type : uint256 = 0 , _implementation_idx : uint256 = 0 , ) -> address : \"\"\" @notice Deploy a new plain pool @param _name Name of the new plain pool @param _symbol Symbol for the new plain pool - will be concatenated with factory symbol @param _coins List of addresses of the coins being used in the pool. @param _A Amplification co-efficient - a lower value here means less tolerance for imbalance within the pool's assets. Suggested values include: * Uncollateralized algorithmic stablecoins: 5-10 * Non-redeemable, collateralized assets: 100 * Redeemable assets: 200-400 @param _fee Trade fee, given as an integer with 1e10 precision. The minimum fee is 0.04% (4000000), the maximum is 1% (100000000). 50% of the fee is distributed to veCRV holders. @param _asset_type Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _implementation_idx Index of the implementation to use. All possible implementations for a pool of N_COINS can be publicly accessed via `plain_implementations(N_COINS)` @return Address of the deployed pool \"\"\" # fee must be between 0.04% and 1% assert _fee >= 4000000 and _fee <= 100000000 , \"Invalid fee\" n_coins : uint256 = MAX_PLAIN_COINS rate_multipliers : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): coin : address = _coins [ i ] if coin == ZERO_ADDRESS : assert i > 1 , \"Insufficient coins\" n_coins = i break assert self . base_pool_assets [ coin ] == False , \"Invalid asset, deploy a metapool\" if _coins [ i ] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE : assert i == 0 , \"ETH must be first coin\" decimals [ 0 ] = 18 else : decimals [ i ] = ERC20 ( coin ) . decimals () assert decimals [ i ] < 19 , \"Max 18 decimals for coins\" rate_multipliers [ i ] = 10 ** ( 36 - decimals [ i ]) for x in range ( i , i + MAX_PLAIN_COINS ): if x + 1 == MAX_PLAIN_COINS : break if _coins [ x + 1 ] == ZERO_ADDRESS : break assert coin != _coins [ x + 1 ], \"Duplicate coins\" implementation : address = self . plain_implementations [ n_coins ][ _implementation_idx ] assert implementation != ZERO_ADDRESS , \"Invalid implementation index\" pool : address = create_forwarder_to ( implementation ) CurvePlainPool ( pool ) . initialize ( _name , _symbol , _coins , rate_multipliers , _A , _fee ) length : uint256 = self . pool_count self . pool_list [ length ] = pool self . pool_count = length + 1 self . pool_data [ pool ] . decimals = decimals self . pool_data [ pool ] . n_coins = n_coins self . pool_data [ pool ] . base_pool = ZERO_ADDRESS self . pool_data [ pool ] . implementation = implementation if _asset_type != 0 : self . pool_data [ pool ] . asset_type = _asset_type for i in range ( MAX_PLAIN_COINS ): coin : address = _coins [ i ] if coin == ZERO_ADDRESS : break self . pool_data [ pool ] . coins [ i ] = coin raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ) ) ) for j in range ( MAX_PLAIN_COINS ): if i < j : swappable_coin : address = _coins [ j ] key : uint256 = bitwise_xor ( convert ( coin , uint256 ), convert ( swappable_coin , uint256 )) length = self . market_counts [ key ] self . markets [ key ][ length ] = pool self . market_counts [ key ] = length + 1 log PlainPoolDeployed ( _coins , _A , _fee , msg . sender ) return pool Example >>> factory = Contract ( '0xB9fC157394Af804a3578134A6585C0dc9cc990d4' ) >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> todo: Factory.deploy_metapool \u00b6 Factory.deploy_metapool(_base_pool: address, _name: String[32], _symbol: String[10], _coin: address, _A: uint256, _fee: uint256) \u2192 address: nonpayable Deploys a new metapool. Returns address of the deployed pool. Input Type Description _base_pool address Address of the base pool to use within the new metapool _name String[32] Name of the new metapool _symbol String[10] Symbol for the new metapool\u2019s LP token. This value will be concatenated with the base pool symbol. _coin address Address of the coin being used in the metapool _A uint256 Amplification coefficient _fee uint256 Trade fee, given as an integer with 1e10 precision Emits: MetaPoolDeployed Source code @external def deploy_metapool ( _base_pool : address , _name : String [ 32 ], _symbol : String [ 10 ], _coin : address , _A : uint256 , _fee : uint256 , _implementation_idx : uint256 = 0 , ) -> address : \"\"\" @notice Deploy a new metapool @param _base_pool Address of the base pool to use within the metapool @param _name Name of the new metapool @param _symbol Symbol for the new metapool - will be concatenated with the base pool symbol @param _coin Address of the coin being used in the metapool @param _A Amplification co-efficient - a higher value here means less tolerance for imbalance within the pool's assets. Suggested values include: * Uncollateralized algorithmic stablecoins: 5-10 * Non-redeemable, collateralized assets: 100 * Redeemable assets: 200-400 @param _fee Trade fee, given as an integer with 1e10 precision. The minimum fee is 0.04% (4000000), the maximum is 1% (100000000). 50% of the fee is distributed to veCRV holders. @param _implementation_idx Index of the implementation to use. All possible implementations for a BASE_POOL can be publicly accessed via `metapool_implementations(BASE_POOL)` @return Address of the deployed pool \"\"\" # fee must be between 0.04% and 1% assert _fee >= 4000000 and _fee <= 100000000 , \"Invalid fee\" implementation : address = self . base_pool_data [ _base_pool ] . implementations [ _implementation_idx ] assert implementation != ZERO_ADDRESS , \"Invalid implementation index\" # things break if a token has >18 decimals decimals : uint256 = ERC20 ( _coin ) . decimals () assert decimals < 19 , \"Max 18 decimals for coins\" pool : address = create_forwarder_to ( implementation ) CurvePool ( pool ) . initialize ( _name , _symbol , _coin , 10 ** ( 36 - decimals ), _A , _fee ) ERC20 ( _coin ) . approve ( pool , MAX_UINT256 ) # add pool to pool_list length : uint256 = self . pool_count self . pool_list [ length ] = pool self . pool_count = length + 1 base_lp_token : address = self . base_pool_data [ _base_pool ] . lp_token self . pool_data [ pool ] . decimals = [ decimals , 0 , 0 , 0 ] self . pool_data [ pool ] . n_coins = 2 self . pool_data [ pool ] . base_pool = _base_pool self . pool_data [ pool ] . coins [ 0 ] = _coin self . pool_data [ pool ] . coins [ 1 ] = self . base_pool_data [ _base_pool ] . lp_token self . pool_data [ pool ] . implementation = implementation is_finished : bool = False for i in range ( MAX_COINS ): swappable_coin : address = self . base_pool_data [ _base_pool ] . coins [ i ] if swappable_coin == ZERO_ADDRESS : is_finished = True swappable_coin = base_lp_token key : uint256 = bitwise_xor ( convert ( _coin , uint256 ), convert ( swappable_coin , uint256 )) length = self . market_counts [ key ] self . markets [ key ][ length ] = pool self . market_counts [ key ] = length + 1 if is_finished : break log MetaPoolDeployed ( _coin , _base_pool , _A , _fee , msg . sender ) return pool Example >>> factory = Contract ( '0xB9fC157394Af804a3578134A6585C0dc9cc990d4' ) >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> threepool = Contract ( '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7' ) >>> tx = factory.deploy_metapool ( threepool, \"Empty Set Dollar\" , \"ESD\" , esd, 10 , 4000000 , { 'from' : alice }) Transaction sent: 0x2702cfc4b96be1877f853c246be567cbe8f80ef7a56348ace1d17c026bc31b68 Gas price: 20 gwei Gas limit: 1100000 Nonce: 9 >>> tx.return_value \"0xFD9f9784ac00432794c8D370d4910D2a3782324C\" Deploy Gauge \u00b6 Factory.deploy_gauge \u00b6 Factory.deploy_gauge(_pool: address) -> address Deploy a liquidity gauge for a factory pool. The deployed gauge implementation is whatever the factory admin has set Factory.gauge_implementation to. Input Type Description _pool address Factory pool address to deploy a gauge for Source code @external def deploy_gauge ( _pool : address ) -> address : \"\"\" @notice Deploy a liquidity gauge for a factory pool @param _pool Factory pool address to deploy a gauge for @return Address of the deployed gauge \"\"\" assert self . pool_data [ _pool ] . coins [ 0 ] != ZERO_ADDRESS , \"Unknown pool\" assert self . pool_data [ _pool ] . liquidity_gauge == ZERO_ADDRESS , \"Gauge already deployed\" implementation : address = self . gauge_implementation assert implementation != ZERO_ADDRESS , \"Gauge implementation not set\" gauge : address = create_forwarder_to ( implementation ) LiquidityGauge ( gauge ) . initialize ( _pool ) self . pool_data [ _pool ] . liquidity_gauge = gauge log LiquidityGaugeDeployed ( _pool , gauge ) return gauge Example >>> todo:","title":"Deployer API"},{"location":"factory/deployer_api/#deployer-api","text":"","title":"Deployer API"},{"location":"factory/deployer_api/#deploy-pool","text":"Note After deploying a pool, you must also add initial liquidity before the pool can be used.","title":"Deploy Pool"},{"location":"factory/deployer_api/#factorydeploy_plain_pool","text":"Factory.deploy_plain_pool(_name: String[32], _symbol: String[10], _coins: address[4], _A: uint256, _fee: uint256, _asset_type: uint256 = 0, _implementation_idx: uint256 = 0) \u2192 address: nonpayable Deploys a new plain pool. Returns address of the deployed pool. Input Type Description _name String[32] Name of the new plain pool _symbol String[10] Symbol for the new metapool\u2019s LP token. This value will be concatenated with the factory symbol. _coins address[4] List of addresses of the coins being used in the pool _A uint256 Amplification coefficient _fee uint256 Trade fee, given as an integer with 1e10 precision _asset_type uint256 Asset type of the pool as an integer. 0 = USD , 1 = ETH , 2 = BTC , 3 = Other. _implementation_idx uint256 Index of the implementation to use. All possible implementations for a pool of N_COINS can be publicly accessed via plain_implementations(N_COINS) . Emits: PlainPoolDeployed Source code MAX_PLAIN_COINS : constant ( int128 ) = 4 # max coins in a plain pool ... @external def deploy_plain_pool ( _name : String [ 32 ], _symbol : String [ 10 ], _coins : address [ MAX_PLAIN_COINS ], _A : uint256 , _fee : uint256 , _asset_type : uint256 = 0 , _implementation_idx : uint256 = 0 , ) -> address : \"\"\" @notice Deploy a new plain pool @param _name Name of the new plain pool @param _symbol Symbol for the new plain pool - will be concatenated with factory symbol @param _coins List of addresses of the coins being used in the pool. @param _A Amplification co-efficient - a lower value here means less tolerance for imbalance within the pool's assets. Suggested values include: * Uncollateralized algorithmic stablecoins: 5-10 * Non-redeemable, collateralized assets: 100 * Redeemable assets: 200-400 @param _fee Trade fee, given as an integer with 1e10 precision. The minimum fee is 0.04% (4000000), the maximum is 1% (100000000). 50% of the fee is distributed to veCRV holders. @param _asset_type Asset type for pool, as an integer 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _implementation_idx Index of the implementation to use. All possible implementations for a pool of N_COINS can be publicly accessed via `plain_implementations(N_COINS)` @return Address of the deployed pool \"\"\" # fee must be between 0.04% and 1% assert _fee >= 4000000 and _fee <= 100000000 , \"Invalid fee\" n_coins : uint256 = MAX_PLAIN_COINS rate_multipliers : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): coin : address = _coins [ i ] if coin == ZERO_ADDRESS : assert i > 1 , \"Insufficient coins\" n_coins = i break assert self . base_pool_assets [ coin ] == False , \"Invalid asset, deploy a metapool\" if _coins [ i ] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE : assert i == 0 , \"ETH must be first coin\" decimals [ 0 ] = 18 else : decimals [ i ] = ERC20 ( coin ) . decimals () assert decimals [ i ] < 19 , \"Max 18 decimals for coins\" rate_multipliers [ i ] = 10 ** ( 36 - decimals [ i ]) for x in range ( i , i + MAX_PLAIN_COINS ): if x + 1 == MAX_PLAIN_COINS : break if _coins [ x + 1 ] == ZERO_ADDRESS : break assert coin != _coins [ x + 1 ], \"Duplicate coins\" implementation : address = self . plain_implementations [ n_coins ][ _implementation_idx ] assert implementation != ZERO_ADDRESS , \"Invalid implementation index\" pool : address = create_forwarder_to ( implementation ) CurvePlainPool ( pool ) . initialize ( _name , _symbol , _coins , rate_multipliers , _A , _fee ) length : uint256 = self . pool_count self . pool_list [ length ] = pool self . pool_count = length + 1 self . pool_data [ pool ] . decimals = decimals self . pool_data [ pool ] . n_coins = n_coins self . pool_data [ pool ] . base_pool = ZERO_ADDRESS self . pool_data [ pool ] . implementation = implementation if _asset_type != 0 : self . pool_data [ pool ] . asset_type = _asset_type for i in range ( MAX_PLAIN_COINS ): coin : address = _coins [ i ] if coin == ZERO_ADDRESS : break self . pool_data [ pool ] . coins [ i ] = coin raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ) ) ) for j in range ( MAX_PLAIN_COINS ): if i < j : swappable_coin : address = _coins [ j ] key : uint256 = bitwise_xor ( convert ( coin , uint256 ), convert ( swappable_coin , uint256 )) length = self . market_counts [ key ] self . markets [ key ][ length ] = pool self . market_counts [ key ] = length + 1 log PlainPoolDeployed ( _coins , _A , _fee , msg . sender ) return pool Example >>> factory = Contract ( '0xB9fC157394Af804a3578134A6585C0dc9cc990d4' ) >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> todo:","title":"Factory.deploy_plain_pool"},{"location":"factory/deployer_api/#factorydeploy_metapool","text":"Factory.deploy_metapool(_base_pool: address, _name: String[32], _symbol: String[10], _coin: address, _A: uint256, _fee: uint256) \u2192 address: nonpayable Deploys a new metapool. Returns address of the deployed pool. Input Type Description _base_pool address Address of the base pool to use within the new metapool _name String[32] Name of the new metapool _symbol String[10] Symbol for the new metapool\u2019s LP token. This value will be concatenated with the base pool symbol. _coin address Address of the coin being used in the metapool _A uint256 Amplification coefficient _fee uint256 Trade fee, given as an integer with 1e10 precision Emits: MetaPoolDeployed Source code @external def deploy_metapool ( _base_pool : address , _name : String [ 32 ], _symbol : String [ 10 ], _coin : address , _A : uint256 , _fee : uint256 , _implementation_idx : uint256 = 0 , ) -> address : \"\"\" @notice Deploy a new metapool @param _base_pool Address of the base pool to use within the metapool @param _name Name of the new metapool @param _symbol Symbol for the new metapool - will be concatenated with the base pool symbol @param _coin Address of the coin being used in the metapool @param _A Amplification co-efficient - a higher value here means less tolerance for imbalance within the pool's assets. Suggested values include: * Uncollateralized algorithmic stablecoins: 5-10 * Non-redeemable, collateralized assets: 100 * Redeemable assets: 200-400 @param _fee Trade fee, given as an integer with 1e10 precision. The minimum fee is 0.04% (4000000), the maximum is 1% (100000000). 50% of the fee is distributed to veCRV holders. @param _implementation_idx Index of the implementation to use. All possible implementations for a BASE_POOL can be publicly accessed via `metapool_implementations(BASE_POOL)` @return Address of the deployed pool \"\"\" # fee must be between 0.04% and 1% assert _fee >= 4000000 and _fee <= 100000000 , \"Invalid fee\" implementation : address = self . base_pool_data [ _base_pool ] . implementations [ _implementation_idx ] assert implementation != ZERO_ADDRESS , \"Invalid implementation index\" # things break if a token has >18 decimals decimals : uint256 = ERC20 ( _coin ) . decimals () assert decimals < 19 , \"Max 18 decimals for coins\" pool : address = create_forwarder_to ( implementation ) CurvePool ( pool ) . initialize ( _name , _symbol , _coin , 10 ** ( 36 - decimals ), _A , _fee ) ERC20 ( _coin ) . approve ( pool , MAX_UINT256 ) # add pool to pool_list length : uint256 = self . pool_count self . pool_list [ length ] = pool self . pool_count = length + 1 base_lp_token : address = self . base_pool_data [ _base_pool ] . lp_token self . pool_data [ pool ] . decimals = [ decimals , 0 , 0 , 0 ] self . pool_data [ pool ] . n_coins = 2 self . pool_data [ pool ] . base_pool = _base_pool self . pool_data [ pool ] . coins [ 0 ] = _coin self . pool_data [ pool ] . coins [ 1 ] = self . base_pool_data [ _base_pool ] . lp_token self . pool_data [ pool ] . implementation = implementation is_finished : bool = False for i in range ( MAX_COINS ): swappable_coin : address = self . base_pool_data [ _base_pool ] . coins [ i ] if swappable_coin == ZERO_ADDRESS : is_finished = True swappable_coin = base_lp_token key : uint256 = bitwise_xor ( convert ( _coin , uint256 ), convert ( swappable_coin , uint256 )) length = self . market_counts [ key ] self . markets [ key ][ length ] = pool self . market_counts [ key ] = length + 1 if is_finished : break log MetaPoolDeployed ( _coin , _base_pool , _A , _fee , msg . sender ) return pool Example >>> factory = Contract ( '0xB9fC157394Af804a3578134A6585C0dc9cc990d4' ) >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> threepool = Contract ( '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7' ) >>> tx = factory.deploy_metapool ( threepool, \"Empty Set Dollar\" , \"ESD\" , esd, 10 , 4000000 , { 'from' : alice }) Transaction sent: 0x2702cfc4b96be1877f853c246be567cbe8f80ef7a56348ace1d17c026bc31b68 Gas price: 20 gwei Gas limit: 1100000 Nonce: 9 >>> tx.return_value \"0xFD9f9784ac00432794c8D370d4910D2a3782324C\"","title":"Factory.deploy_metapool"},{"location":"factory/deployer_api/#deploy-gauge","text":"","title":"Deploy Gauge"},{"location":"factory/deployer_api/#factorydeploy_gauge","text":"Factory.deploy_gauge(_pool: address) -> address Deploy a liquidity gauge for a factory pool. The deployed gauge implementation is whatever the factory admin has set Factory.gauge_implementation to. Input Type Description _pool address Factory pool address to deploy a gauge for Source code @external def deploy_gauge ( _pool : address ) -> address : \"\"\" @notice Deploy a liquidity gauge for a factory pool @param _pool Factory pool address to deploy a gauge for @return Address of the deployed gauge \"\"\" assert self . pool_data [ _pool ] . coins [ 0 ] != ZERO_ADDRESS , \"Unknown pool\" assert self . pool_data [ _pool ] . liquidity_gauge == ZERO_ADDRESS , \"Gauge already deployed\" implementation : address = self . gauge_implementation assert implementation != ZERO_ADDRESS , \"Gauge implementation not set\" gauge : address = create_forwarder_to ( implementation ) LiquidityGauge ( gauge ) . initialize ( _pool ) self . pool_data [ _pool ] . liquidity_gauge = gauge log LiquidityGaugeDeployed ( _pool , gauge ) return gauge Example >>> todo:","title":"Factory.deploy_gauge"},{"location":"factory/overview/","text":"Curve Factory \u00b6 The factory allows for permissionless deployment of Curve pools and gauges. Source code for factory contracts may be viewed on Github . Organization \u00b6 The factory has several core components: The factory is the main contract used to deploy new pools and gauges. It also acts a registry for finding the deployed pools and querying information about them. Pools are deployed via a proxy contract . The implementation contract targetted by the proxy is determined according to the base pool. This is the same technique used to create pools in Uniswap V1. Deposit contracts (\u201czaps\u201d) are used for wrapping and unwrapping underlying assets when depositing into or withdrawing from pools. The Factory contract is used to deploy new Curve pools and gauges. It also acts as a registry, which is useful for finding deployed curve pools and gauges. It is deployed to the mainnet at the following address: 0xB9fC157394Af804a3578134A6585C0dc9cc990d4 Source code for this contract is may be viewed on Github . Limitations Please carefully review the limitations of the factory prior to deploying a new pool. Deploying a pool using an incompatible token could result in permanent losses to liquidity providers and/or traders . Factory pools cannot be killed and tokens cannot be rescued from them! The token within the new pool must expose a decimals method and use a maximum of 18 decimal places. The token\u2019s transfer and transferFrom methods must revert upon failure. Successful token transfers must move exactly the specified number of tokens between the sender and receiver. Tokens that take a fee upon a successful transfer may cause the pool to break or act in unexpected ways. Pools deployed by the factory cannot be paused or killed. Pools deployed by the factory are not eligible for CRV rewards. The factory can be used to deploy the following: plain pools metapools (paired against admin-approved base pools) gauges Base Pools \u00b6 A metapool pairs a coin against the LP token of another pool. This other pool is referred to as the \u201cbase pool\u201d. By using LP tokens, metapools allow swaps against any asset within their base pool, without diluting the base pool\u2019s liquidity. The factory allows deployment of metapools that use the following base pools: 3pool (USD denominated assets): 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7 sBTC (BTC denominated assets): 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714 It is possible to enable additional base pools through a DAO vote. Choosing an Amplification Coefficient \u00b6 The amplification coefficient (\u201cA\u201d) determines a pool\u2019s tolerance for imbalance between the assets within it. A higher value means that trades will incur slippage sooner as the assets within the pool become imbalanced. The appropriate value for A is dependent upon the type of coin being used within the pool. We recommend the following values: Uncollateralized algorithmic stablecoins: 5-10 Non-redeemable, collateralized assets: 100 Redeemable assets: 200-400 It is possible to modify the amplification coefficient for a pool after it has been deployed. However, it requires a vote within the Curve DAO and must reach a 15% quorum. Trade Fees \u00b6 Curve pools charge a fee for token exchanges and when adding or removing liquidity in an imbalanced manner. 50% of the fees are given to liquidity providers, 50% are distributed to veCRV holders. For factory pools, the size of the fee is set at deployment. The minimum fee is 0.04% (represented as 4000000 ). The maximum fee is 1% ( 100000000 ). The fee cannot be changed after a pool has been deployed.","title":"Overview"},{"location":"factory/overview/#curve-factory","text":"The factory allows for permissionless deployment of Curve pools and gauges. Source code for factory contracts may be viewed on Github .","title":"Curve Factory"},{"location":"factory/overview/#organization","text":"The factory has several core components: The factory is the main contract used to deploy new pools and gauges. It also acts a registry for finding the deployed pools and querying information about them. Pools are deployed via a proxy contract . The implementation contract targetted by the proxy is determined according to the base pool. This is the same technique used to create pools in Uniswap V1. Deposit contracts (\u201czaps\u201d) are used for wrapping and unwrapping underlying assets when depositing into or withdrawing from pools. The Factory contract is used to deploy new Curve pools and gauges. It also acts as a registry, which is useful for finding deployed curve pools and gauges. It is deployed to the mainnet at the following address: 0xB9fC157394Af804a3578134A6585C0dc9cc990d4 Source code for this contract is may be viewed on Github . Limitations Please carefully review the limitations of the factory prior to deploying a new pool. Deploying a pool using an incompatible token could result in permanent losses to liquidity providers and/or traders . Factory pools cannot be killed and tokens cannot be rescued from them! The token within the new pool must expose a decimals method and use a maximum of 18 decimal places. The token\u2019s transfer and transferFrom methods must revert upon failure. Successful token transfers must move exactly the specified number of tokens between the sender and receiver. Tokens that take a fee upon a successful transfer may cause the pool to break or act in unexpected ways. Pools deployed by the factory cannot be paused or killed. Pools deployed by the factory are not eligible for CRV rewards. The factory can be used to deploy the following: plain pools metapools (paired against admin-approved base pools) gauges","title":"Organization"},{"location":"factory/overview/#base-pools","text":"A metapool pairs a coin against the LP token of another pool. This other pool is referred to as the \u201cbase pool\u201d. By using LP tokens, metapools allow swaps against any asset within their base pool, without diluting the base pool\u2019s liquidity. The factory allows deployment of metapools that use the following base pools: 3pool (USD denominated assets): 0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7 sBTC (BTC denominated assets): 0x7fC77b5c7614E1533320Ea6DDc2Eb61fa00A9714 It is possible to enable additional base pools through a DAO vote.","title":"Base Pools"},{"location":"factory/overview/#choosing-an-amplification-coefficient","text":"The amplification coefficient (\u201cA\u201d) determines a pool\u2019s tolerance for imbalance between the assets within it. A higher value means that trades will incur slippage sooner as the assets within the pool become imbalanced. The appropriate value for A is dependent upon the type of coin being used within the pool. We recommend the following values: Uncollateralized algorithmic stablecoins: 5-10 Non-redeemable, collateralized assets: 100 Redeemable assets: 200-400 It is possible to modify the amplification coefficient for a pool after it has been deployed. However, it requires a vote within the Curve DAO and must reach a 15% quorum.","title":"Choosing an Amplification Coefficient"},{"location":"factory/overview/#trade-fees","text":"Curve pools charge a fee for token exchanges and when adding or removing liquidity in an imbalanced manner. 50% of the fees are given to liquidity providers, 50% are distributed to veCRV holders. For factory pools, the size of the fee is set at deployment. The minimum fee is 0.04% (represented as 4000000 ). The maximum fee is 1% ( 100000000 ). The fee cannot be changed after a pool has been deployed.","title":"Trade Fees"},{"location":"factory/pool_migrator/","text":"","title":"Pool migrator"},{"location":"factory/registry_api/","text":"Factory Getters \u00b6 Factory.metapool_implementations \u00b6 Factory.metapool_implementations(_base_pool: address) -> address[10] Get a list of implementation contracts for metapools targetting the given base pool. Input Type Description _base_pool address Address of the base pool Source code @view @external def metapool_implementations ( _base_pool : address ) -> address [ 10 ]: \"\"\" @notice Get a list of implementation contracts for metapools targetting the given base pool @dev A base pool is the pool for the LP token contained within the metapool @param _base_pool Address of the base pool @return List of implementation contract addresses \"\"\" return self . base_pool_data [ _base_pool ] . implementations Example >>> todo: Find Pools \u00b6 The following getter methods are available for finding pools that were deployed via the factory: Factory.pool_count \u00b6 Factory.pool_count() \u2192 uint256: view Returns the total number of pools that have been deployed by the factory. Source code pool_count : public ( uint256 ) # actual length of pool_list ... Example >>> todo: Factory.pool_list \u00b6 Factory.pool_list(i: uint256) \u2192 address: view Returns the n\u2019th entry in a zero-indexed array of deployed pools. Returns ZERO_ADDRESS when i is greater than the number of deployed pools. Input Type Description i uint256 Pool index Source code pool_list : public ( address [ 4294967296 ]) # master list of pools ... Example >>> todo: Note As factory-deployed pools are not killable, they also cannot be removed from the registry. For this reason the ordering of pools within this array will never change. Factory.find_pool_for_coins \u00b6 Factory.find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) \u2192 address: view Finds a pool that allows for swaps between _from and _to . You can optionally include i to get the i-th pool, when multiple pools exist for the given pairing. The order of _from and _to does not affect the result. Returns ZERO_ADDRESS when swaps are not possible for the pair or i exceeds the number of available pools. Input Type Description _from address Coin to swap from _to address Coin to swap to i uint256 Optional index to get the i-th pool from the output. Defaults to zero. Source code @view @external def find_pool_for_coins ( _from : address , _to : address , i : uint256 = 0 ) -> address : \"\"\" @notice Find an available pool for exchanging two coins @param _from Address of coin to be sent @param _to Address of coin to be received @param i Index value. When multiple pools are available this value is used to return the n'th address. @return Pool address \"\"\" key : uint256 = bitwise_xor ( convert ( _from , uint256 ), convert ( _to , uint256 )) return self . markets [ key ][ i ] Example >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> usdc = Contract ( '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' ) >>> factory.find_pool_for_coins ( esd, usdc ) '0xFD9f9784ac00432794c8D370d4910D2a3782324C' Get Pool Info \u00b6 The factory has a similar API to that of the main Registry, which can be used to query information about existing pools. Coins and Coin Info \u00b6 Factory.get_n_coins \u00b6 Factory.get_n_coins(pool: address) \u2192 (uint256): view Get the number of coins and underlying coins within a pool. Returns a tuple of uint256 representing number of coins at their respective indices in the pool being queried. Input Type Description pool address Address of the pool Source code @view @external def get_n_coins ( _pool : address ) -> ( uint256 ): \"\"\" @notice Get the number of coins in a pool @param _pool Pool address @return Number of coins \"\"\" return self . pool_data [ _pool ] . n_coins Example >>> factory.get_n_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) todo: Factory.get_coins \u00b6 Factory.get_coins(_pool: address) -> address[4] Get a list of the swappable coins within a pool. Returns a list of address of coins at their respective indices. Input Type Description _pool address Address of the pool Source code @view @external def get_coins ( _pool : address ) -> address [ 4 ]: \"\"\" @notice Get the coins within a pool @param _pool Pool address @return List of coin addresses \"\"\" return self . pool_data [ _pool ] . coins Example >>> factory.get_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( \"0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723\" , \"0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490\" ) Factory.get_underlying_coins \u00b6 Factory.get_underlying_coins(pool: address) \u2192 address[8]: view Get a list of the swappable underlying coins within a pool. Returns a list of address of coins at their respective indices. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_coins ( _pool : address ) -> address [ MAX_COINS ]: \"\"\" @notice Get the underlying coins within a pool @dev Reverts if a pool does not exist or is not a metapool @param _pool Pool address @return List of coin addresses \"\"\" coins : address [ MAX_COINS ] = empty ( address [ MAX_COINS ]) base_pool : address = self . pool_data [ _pool ] . base_pool assert base_pool != ZERO_ADDRESS # dev: pool is not metapool coins [ 0 ] = self . pool_data [ _pool ] . coins [ 0 ] for i in range ( 1 , MAX_COINS ): coins [ i ] = self . base_pool_data [ base_pool ] . coins [ i - 1 ] if coins [ i ] == ZERO_ADDRESS : break return coins Example >>> factory.get_underlying_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( \"0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723\" , \"0x6B175474E89094C44Da98b954EedeAC495271d0F\" , \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , \"0xdAC17F958D2ee523a2206206994597C13D831ec7\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" ) Factory.get_decimals \u00b6 Factory.get_decimals(pool: address) \u2192 uint256[8]: view Get a list of decimal places for each coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_decimals ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get decimal places for each coin within a pool @param _pool Pool address @return uint256 list of decimals \"\"\" if self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS : decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) decimals = self . pool_data [ _pool ] . decimals decimals [ 1 ] = 18 return decimals return self . pool_data [ _pool ] . decimals Example >>> factory.get_decimals ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 18 , 18 , 0 , 0 , 0 , 0 , 0 , 0 ) Factory.get_underlying_decimals \u00b6 Factory.get_underlying_decimals(pool: address) \u2192 uint256[8]: view Get a list of decimal places for each underlying coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_decimals ( _pool : address ) -> uint256 [ MAX_COINS ]: \"\"\" @notice Get decimal places for each underlying coin within a pool @param _pool Pool address @return uint256 list of decimals \"\"\" # decimals are tightly packed as a series of uint8 within a little-endian bytes32 # the packed value is stored as uint256 to simplify unpacking via shift and modulo pool_decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) pool_decimals = self . pool_data [ _pool ] . decimals decimals : uint256 [ MAX_COINS ] = empty ( uint256 [ MAX_COINS ]) decimals [ 0 ] = pool_decimals [ 0 ] base_pool : address = self . pool_data [ _pool ] . base_pool packed_decimals : uint256 = self . base_pool_data [ base_pool ] . decimals for i in range ( MAX_COINS ): unpacked : uint256 = shift ( packed_decimals , - 8 * i ) % 256 if unpacked == 0 : break decimals [ i + 1 ] = unpacked return decimals Example >>> factory.get_decimals ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 18 , 18 , 0 , 0 , 0 , 0 , 0 , 0 ) Note For pools that do not involve lending, the return value is identical to Registry.get_decimals . Non-lending coins that still involve querying a rate (e.g. renBTC) are marked as having 0 decimals. Factory.get_coin_indices \u00b6 Factory.get_coin_indices(pool: address, _from: address, _to: address) \u2192 (int128, int128, bool): view Convert coin addresses into indices for use with pool methods. Returns the index of _from , index of _to , and a bool indicating if the coins are considered underlying in the given pool. Input Type Description pool address Address of the pool _from address Address of the from coin _to address Address of the to coin Source code @view @external def get_coin_indices ( _pool : address , _from : address , _to : address ) -> ( int128 , int128 , bool ): \"\"\" @notice Convert coin addresses to indices for use with pool methods @param _pool Pool address @param _from Coin address to be used as `i` within a pool @param _to Coin address to be used as `j` within a pool @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins \"\"\" coin : address = self . pool_data [ _pool ] . coins [ 0 ] base_pool : address = self . pool_data [ _pool ] . base_pool if coin in [ _from , _to ] and base_pool != ZERO_ADDRESS : base_lp_token : address = self . pool_data [ _pool ] . coins [ 1 ] if base_lp_token in [ _from , _to ]: # True and False convert to 1 and 0 - a bit of voodoo that # works because we only ever have 2 non-underlying coins if base pool is ZERO_ADDRESS return convert ( _to == coin , int128 ), convert ( _from == coin , int128 ), False found_market : bool = False i : int128 = 0 j : int128 = 0 for x in range ( MAX_COINS ): if base_pool == ZERO_ADDRESS : if x >= MAX_PLAIN_COINS : raise \"No available market\" if x != 0 : coin = self . pool_data [ _pool ] . coins [ x ] else : if x != 0 : coin = self . base_pool_data [ base_pool ] . coins [ x - 1 ] if coin == ZERO_ADDRESS : raise \"No available market\" if coin == _from : i = x elif coin == _to : j = x else : continue if found_market : # the second time we find a match, break out of the loop break # the first time we find a match, set `found_market` to True found_market = True return i , j , True Example >>> factory.get_coin_indices ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' , '0xdac17f958d2ee523a2206206994597c13d831ec7' , '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' ) ( 2 , 1 , True ) Based on the above call, we know: the index of the coin we are swapping out of is 2 the index of the coin we are swapping into is 1 the coins are considered underlying, so we must call exchange_underlying From this information we can perform a token swap: >>> swap = Contract ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) >>> swap.exchange_underlying ( 2 , 1 , 1e18, 0 , { 'from' : alice }) Factory.get_gauge \u00b6 Factory.get_gauge(_pool: address) -> address Get the address of the liquidity gauge contract for a factory pool. Input Type Description _pool address Address of the pool Source code @view @external def get_gauge ( _pool : address ) -> address : \"\"\" @notice Get the address of the liquidity gauge contract for a factory pool @dev Returns `ZERO_ADDRESS` if a gauge has not been deployed @param _pool Pool address @return Implementation contract address \"\"\" return self . pool_data [ _pool ] . liquidity_gauge Example >>> todo: Factory.get_implementation_address \u00b6 Factory.get_implementation_address(_pool: address) -> address Get the address of the implementation contract used for a factory pool. Input Type Description _pool address Address of the pool Source code @view @external def get_implementation_address ( _pool : address ) -> address : \"\"\" @notice Get the address of the implementation contract used for a factory pool @param _pool Pool address @return Implementation contract address \"\"\" return self . pool_data [ _pool ] . implementation Example >>> todo: Factory.is_meta \u00b6 Factory.is_meta(_pool: address) -> bool Verify _pool is a metapool. Returns True if pool is indeed a metapool, else False . Input Type Description _pool address Address of the pool Source code @view @external def is_meta ( _pool : address ) -> bool : \"\"\" @notice Verify `_pool` is a metapool @param _pool Pool address @return True if `_pool` is a metapool \"\"\" return self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS Example >>> todo: Factory.get_pool_asset_type \u00b6 Factory.get_pool_asset_type(_pool: address) -> uint256 Query the asset type of _pool . Returns: 0 = USD, 1 = ETH, 2 = BTC, 3 = Other Input Type Description _pool address Address of the pool Source code @view @external def get_pool_asset_type ( _pool : address ) -> uint256 : \"\"\" @notice Query the asset type of `_pool` @dev 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _pool Pool Address @return Integer indicating the pool asset type \"\"\" base_pool : address = self . pool_data [ _pool ] . base_pool if base_pool == ZERO_ADDRESS : return self . pool_data [ _pool ] . asset_type else : return self . base_pool_data [ base_pool ] . asset_type Example >>> todo: Factory.get_fee_receiver \u00b6 Factory.get_fee_receiver(_pool: address) -> address Get the address of the fee receiver of a factory deployed pool. Input Type Description _pool address Address of the pool Source code @view @external def get_fee_receiver ( _pool : address ) -> address : base_pool : address = self . pool_data [ _pool ] . base_pool if base_pool == ZERO_ADDRESS : return self . fee_receiver else : return self . base_pool_data [ base_pool ] . fee_receiver Example >>> todo: Balances and Rates \u00b6 Factory.get_balances \u00b6 Factory.get_balances(_pool: address) \u2192 uint256[2]: view Get available balances for each coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_balances ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get balances for each coin within a pool @dev For pools using lending, these are the wrapped coin balances @param _pool Pool address @return uint256 list of balances \"\"\" if self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS : return [ CurvePool ( _pool ) . balances ( 0 ), CurvePool ( _pool ) . balances ( 1 ), 0 , 0 ] n_coins : uint256 = self . pool_data [ _pool ] . n_coins balances : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): if i < n_coins : balances [ i ] = CurvePool ( _pool ) . balances ( i ) else : balances [ i ] = 0 return balances Example >>> factory.get_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 11428161394428689823275227 , 47831326741306 ) Note These values are not necessarily the same as calling Token.balanceOf(pool) as the total balance also includes unclaimed admin fees. Factory.get_underlying_balances \u00b6 Factory.get_underlying_balances(pool: address) \u2192 uint256[8]: view Get balances for each underlying coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_balances ( _pool : address ) -> uint256 [ MAX_COINS ]: \"\"\" @notice Get balances for each underlying coin within a metapool @param _pool Metapool address @return uint256 list of underlying balances \"\"\" underlying_balances : uint256 [ MAX_COINS ] = empty ( uint256 [ MAX_COINS ]) underlying_balances [ 0 ] = CurvePool ( _pool ) . balances ( 0 ) base_total_supply : uint256 = ERC20 ( self . pool_data [ _pool ] . coins [ 1 ]) . totalSupply () if base_total_supply > 0 : underlying_pct : uint256 = CurvePool ( _pool ) . balances ( 1 ) * 10 ** 36 / base_total_supply base_pool : address = self . pool_data [ _pool ] . base_pool assert base_pool != ZERO_ADDRESS # dev: pool is not a metapool n_coins : uint256 = self . base_pool_data [ base_pool ] . n_coins for i in range ( MAX_COINS ): if i == n_coins : break underlying_balances [ i + 1 ] = CurvePool ( base_pool ) . balances ( i ) * underlying_pct / 10 ** 36 return underlying_balances Example >>> factory.get_underlying_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 11876658145799734093379928 , 48715210997790596223520238 , 46553896776332824101242804 , 49543896565857325657915396 , 0 , 0 , 0 , 0 ) Factory.get_admin_balances \u00b6 Factory.get_admin_balances(pool: address) \u2192 uint256[2]: view Get the current admin balances (uncollected fees) for a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_admin_balances ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get the current admin balances (uncollected fees) for a pool @param _pool Pool address @return List of uint256 admin balances \"\"\" n_coins : uint256 = self . pool_data [ _pool ] . n_coins admin_balances : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): if i == n_coins : break admin_balances [ i ] = CurvePool ( _pool ) . admin_balances ( i ) return admin_balances Example >>> factory.get_admin_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 10800690926373756722358 , 30891687335 ) Factory.get_metapool_rates \u00b6 Factory.get_metapool_rates(_pool: address) \u2192 uint256[2]: view Get rates for coins within a metapool. Returns rates for each coin, precision normalized to 10**18 precision. Input Type Description _pool address Address of the pool Source code @view @external def get_metapool_rates ( _pool : address ) -> uint256 [ 2 ]: \"\"\" @notice Get rates for coins within a metapool @param _pool Pool address @return Rates for each coin, precision normalized to 10**18 \"\"\" rates : uint256 [ 2 ] = [ 10 ** 18 , 0 ] rates [ 1 ] = CurvePool ( self . pool_data [ _pool ] . base_pool ) . get_virtual_price () return rates Example >>> factory.get_rates ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) todo:","title":"Registry API"},{"location":"factory/registry_api/#factory-getters","text":"","title":"Factory Getters"},{"location":"factory/registry_api/#factorymetapool_implementations","text":"Factory.metapool_implementations(_base_pool: address) -> address[10] Get a list of implementation contracts for metapools targetting the given base pool. Input Type Description _base_pool address Address of the base pool Source code @view @external def metapool_implementations ( _base_pool : address ) -> address [ 10 ]: \"\"\" @notice Get a list of implementation contracts for metapools targetting the given base pool @dev A base pool is the pool for the LP token contained within the metapool @param _base_pool Address of the base pool @return List of implementation contract addresses \"\"\" return self . base_pool_data [ _base_pool ] . implementations Example >>> todo:","title":"Factory.metapool_implementations"},{"location":"factory/registry_api/#find-pools","text":"The following getter methods are available for finding pools that were deployed via the factory:","title":"Find Pools"},{"location":"factory/registry_api/#factorypool_count","text":"Factory.pool_count() \u2192 uint256: view Returns the total number of pools that have been deployed by the factory. Source code pool_count : public ( uint256 ) # actual length of pool_list ... Example >>> todo:","title":"Factory.pool_count"},{"location":"factory/registry_api/#factorypool_list","text":"Factory.pool_list(i: uint256) \u2192 address: view Returns the n\u2019th entry in a zero-indexed array of deployed pools. Returns ZERO_ADDRESS when i is greater than the number of deployed pools. Input Type Description i uint256 Pool index Source code pool_list : public ( address [ 4294967296 ]) # master list of pools ... Example >>> todo: Note As factory-deployed pools are not killable, they also cannot be removed from the registry. For this reason the ordering of pools within this array will never change.","title":"Factory.pool_list"},{"location":"factory/registry_api/#factoryfind_pool_for_coins","text":"Factory.find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) \u2192 address: view Finds a pool that allows for swaps between _from and _to . You can optionally include i to get the i-th pool, when multiple pools exist for the given pairing. The order of _from and _to does not affect the result. Returns ZERO_ADDRESS when swaps are not possible for the pair or i exceeds the number of available pools. Input Type Description _from address Coin to swap from _to address Coin to swap to i uint256 Optional index to get the i-th pool from the output. Defaults to zero. Source code @view @external def find_pool_for_coins ( _from : address , _to : address , i : uint256 = 0 ) -> address : \"\"\" @notice Find an available pool for exchanging two coins @param _from Address of coin to be sent @param _to Address of coin to be received @param i Index value. When multiple pools are available this value is used to return the n'th address. @return Pool address \"\"\" key : uint256 = bitwise_xor ( convert ( _from , uint256 ), convert ( _to , uint256 )) return self . markets [ key ][ i ] Example >>> esd = Contract ( '0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723' ) >>> usdc = Contract ( '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' ) >>> factory.find_pool_for_coins ( esd, usdc ) '0xFD9f9784ac00432794c8D370d4910D2a3782324C'","title":"Factory.find_pool_for_coins"},{"location":"factory/registry_api/#get-pool-info","text":"The factory has a similar API to that of the main Registry, which can be used to query information about existing pools.","title":"Get Pool Info"},{"location":"factory/registry_api/#coins-and-coin-info","text":"","title":"Coins and Coin Info"},{"location":"factory/registry_api/#factoryget_n_coins","text":"Factory.get_n_coins(pool: address) \u2192 (uint256): view Get the number of coins and underlying coins within a pool. Returns a tuple of uint256 representing number of coins at their respective indices in the pool being queried. Input Type Description pool address Address of the pool Source code @view @external def get_n_coins ( _pool : address ) -> ( uint256 ): \"\"\" @notice Get the number of coins in a pool @param _pool Pool address @return Number of coins \"\"\" return self . pool_data [ _pool ] . n_coins Example >>> factory.get_n_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) todo:","title":"Factory.get_n_coins"},{"location":"factory/registry_api/#factoryget_coins","text":"Factory.get_coins(_pool: address) -> address[4] Get a list of the swappable coins within a pool. Returns a list of address of coins at their respective indices. Input Type Description _pool address Address of the pool Source code @view @external def get_coins ( _pool : address ) -> address [ 4 ]: \"\"\" @notice Get the coins within a pool @param _pool Pool address @return List of coin addresses \"\"\" return self . pool_data [ _pool ] . coins Example >>> factory.get_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( \"0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723\" , \"0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490\" )","title":"Factory.get_coins"},{"location":"factory/registry_api/#factoryget_underlying_coins","text":"Factory.get_underlying_coins(pool: address) \u2192 address[8]: view Get a list of the swappable underlying coins within a pool. Returns a list of address of coins at their respective indices. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_coins ( _pool : address ) -> address [ MAX_COINS ]: \"\"\" @notice Get the underlying coins within a pool @dev Reverts if a pool does not exist or is not a metapool @param _pool Pool address @return List of coin addresses \"\"\" coins : address [ MAX_COINS ] = empty ( address [ MAX_COINS ]) base_pool : address = self . pool_data [ _pool ] . base_pool assert base_pool != ZERO_ADDRESS # dev: pool is not metapool coins [ 0 ] = self . pool_data [ _pool ] . coins [ 0 ] for i in range ( 1 , MAX_COINS ): coins [ i ] = self . base_pool_data [ base_pool ] . coins [ i - 1 ] if coins [ i ] == ZERO_ADDRESS : break return coins Example >>> factory.get_underlying_coins ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( \"0x36F3FD68E7325a35EB768F1AedaAe9EA0689d723\" , \"0x6B175474E89094C44Da98b954EedeAC495271d0F\" , \"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\" , \"0xdAC17F958D2ee523a2206206994597C13D831ec7\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" , \"0x0000000000000000000000000000000000000000\" )","title":"Factory.get_underlying_coins"},{"location":"factory/registry_api/#factoryget_decimals","text":"Factory.get_decimals(pool: address) \u2192 uint256[8]: view Get a list of decimal places for each coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_decimals ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get decimal places for each coin within a pool @param _pool Pool address @return uint256 list of decimals \"\"\" if self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS : decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) decimals = self . pool_data [ _pool ] . decimals decimals [ 1 ] = 18 return decimals return self . pool_data [ _pool ] . decimals Example >>> factory.get_decimals ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 18 , 18 , 0 , 0 , 0 , 0 , 0 , 0 )","title":"Factory.get_decimals"},{"location":"factory/registry_api/#factoryget_underlying_decimals","text":"Factory.get_underlying_decimals(pool: address) \u2192 uint256[8]: view Get a list of decimal places for each underlying coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_decimals ( _pool : address ) -> uint256 [ MAX_COINS ]: \"\"\" @notice Get decimal places for each underlying coin within a pool @param _pool Pool address @return uint256 list of decimals \"\"\" # decimals are tightly packed as a series of uint8 within a little-endian bytes32 # the packed value is stored as uint256 to simplify unpacking via shift and modulo pool_decimals : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) pool_decimals = self . pool_data [ _pool ] . decimals decimals : uint256 [ MAX_COINS ] = empty ( uint256 [ MAX_COINS ]) decimals [ 0 ] = pool_decimals [ 0 ] base_pool : address = self . pool_data [ _pool ] . base_pool packed_decimals : uint256 = self . base_pool_data [ base_pool ] . decimals for i in range ( MAX_COINS ): unpacked : uint256 = shift ( packed_decimals , - 8 * i ) % 256 if unpacked == 0 : break decimals [ i + 1 ] = unpacked return decimals Example >>> factory.get_decimals ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 18 , 18 , 0 , 0 , 0 , 0 , 0 , 0 ) Note For pools that do not involve lending, the return value is identical to Registry.get_decimals . Non-lending coins that still involve querying a rate (e.g. renBTC) are marked as having 0 decimals.","title":"Factory.get_underlying_decimals"},{"location":"factory/registry_api/#factoryget_coin_indices","text":"Factory.get_coin_indices(pool: address, _from: address, _to: address) \u2192 (int128, int128, bool): view Convert coin addresses into indices for use with pool methods. Returns the index of _from , index of _to , and a bool indicating if the coins are considered underlying in the given pool. Input Type Description pool address Address of the pool _from address Address of the from coin _to address Address of the to coin Source code @view @external def get_coin_indices ( _pool : address , _from : address , _to : address ) -> ( int128 , int128 , bool ): \"\"\" @notice Convert coin addresses to indices for use with pool methods @param _pool Pool address @param _from Coin address to be used as `i` within a pool @param _to Coin address to be used as `j` within a pool @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins \"\"\" coin : address = self . pool_data [ _pool ] . coins [ 0 ] base_pool : address = self . pool_data [ _pool ] . base_pool if coin in [ _from , _to ] and base_pool != ZERO_ADDRESS : base_lp_token : address = self . pool_data [ _pool ] . coins [ 1 ] if base_lp_token in [ _from , _to ]: # True and False convert to 1 and 0 - a bit of voodoo that # works because we only ever have 2 non-underlying coins if base pool is ZERO_ADDRESS return convert ( _to == coin , int128 ), convert ( _from == coin , int128 ), False found_market : bool = False i : int128 = 0 j : int128 = 0 for x in range ( MAX_COINS ): if base_pool == ZERO_ADDRESS : if x >= MAX_PLAIN_COINS : raise \"No available market\" if x != 0 : coin = self . pool_data [ _pool ] . coins [ x ] else : if x != 0 : coin = self . base_pool_data [ base_pool ] . coins [ x - 1 ] if coin == ZERO_ADDRESS : raise \"No available market\" if coin == _from : i = x elif coin == _to : j = x else : continue if found_market : # the second time we find a match, break out of the loop break # the first time we find a match, set `found_market` to True found_market = True return i , j , True Example >>> factory.get_coin_indices ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' , '0xdac17f958d2ee523a2206206994597c13d831ec7' , '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' ) ( 2 , 1 , True ) Based on the above call, we know: the index of the coin we are swapping out of is 2 the index of the coin we are swapping into is 1 the coins are considered underlying, so we must call exchange_underlying From this information we can perform a token swap: >>> swap = Contract ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) >>> swap.exchange_underlying ( 2 , 1 , 1e18, 0 , { 'from' : alice })","title":"Factory.get_coin_indices"},{"location":"factory/registry_api/#factoryget_gauge","text":"Factory.get_gauge(_pool: address) -> address Get the address of the liquidity gauge contract for a factory pool. Input Type Description _pool address Address of the pool Source code @view @external def get_gauge ( _pool : address ) -> address : \"\"\" @notice Get the address of the liquidity gauge contract for a factory pool @dev Returns `ZERO_ADDRESS` if a gauge has not been deployed @param _pool Pool address @return Implementation contract address \"\"\" return self . pool_data [ _pool ] . liquidity_gauge Example >>> todo:","title":"Factory.get_gauge"},{"location":"factory/registry_api/#factoryget_implementation_address","text":"Factory.get_implementation_address(_pool: address) -> address Get the address of the implementation contract used for a factory pool. Input Type Description _pool address Address of the pool Source code @view @external def get_implementation_address ( _pool : address ) -> address : \"\"\" @notice Get the address of the implementation contract used for a factory pool @param _pool Pool address @return Implementation contract address \"\"\" return self . pool_data [ _pool ] . implementation Example >>> todo:","title":"Factory.get_implementation_address"},{"location":"factory/registry_api/#factoryis_meta","text":"Factory.is_meta(_pool: address) -> bool Verify _pool is a metapool. Returns True if pool is indeed a metapool, else False . Input Type Description _pool address Address of the pool Source code @view @external def is_meta ( _pool : address ) -> bool : \"\"\" @notice Verify `_pool` is a metapool @param _pool Pool address @return True if `_pool` is a metapool \"\"\" return self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS Example >>> todo:","title":"Factory.is_meta"},{"location":"factory/registry_api/#factoryget_pool_asset_type","text":"Factory.get_pool_asset_type(_pool: address) -> uint256 Query the asset type of _pool . Returns: 0 = USD, 1 = ETH, 2 = BTC, 3 = Other Input Type Description _pool address Address of the pool Source code @view @external def get_pool_asset_type ( _pool : address ) -> uint256 : \"\"\" @notice Query the asset type of `_pool` @dev 0 = USD, 1 = ETH, 2 = BTC, 3 = Other @param _pool Pool Address @return Integer indicating the pool asset type \"\"\" base_pool : address = self . pool_data [ _pool ] . base_pool if base_pool == ZERO_ADDRESS : return self . pool_data [ _pool ] . asset_type else : return self . base_pool_data [ base_pool ] . asset_type Example >>> todo:","title":"Factory.get_pool_asset_type"},{"location":"factory/registry_api/#factoryget_fee_receiver","text":"Factory.get_fee_receiver(_pool: address) -> address Get the address of the fee receiver of a factory deployed pool. Input Type Description _pool address Address of the pool Source code @view @external def get_fee_receiver ( _pool : address ) -> address : base_pool : address = self . pool_data [ _pool ] . base_pool if base_pool == ZERO_ADDRESS : return self . fee_receiver else : return self . base_pool_data [ base_pool ] . fee_receiver Example >>> todo:","title":"Factory.get_fee_receiver"},{"location":"factory/registry_api/#balances-and-rates","text":"","title":"Balances and Rates"},{"location":"factory/registry_api/#factoryget_balances","text":"Factory.get_balances(_pool: address) \u2192 uint256[2]: view Get available balances for each coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_balances ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get balances for each coin within a pool @dev For pools using lending, these are the wrapped coin balances @param _pool Pool address @return uint256 list of balances \"\"\" if self . pool_data [ _pool ] . base_pool != ZERO_ADDRESS : return [ CurvePool ( _pool ) . balances ( 0 ), CurvePool ( _pool ) . balances ( 1 ), 0 , 0 ] n_coins : uint256 = self . pool_data [ _pool ] . n_coins balances : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): if i < n_coins : balances [ i ] = CurvePool ( _pool ) . balances ( i ) else : balances [ i ] = 0 return balances Example >>> factory.get_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 11428161394428689823275227 , 47831326741306 ) Note These values are not necessarily the same as calling Token.balanceOf(pool) as the total balance also includes unclaimed admin fees.","title":"Factory.get_balances"},{"location":"factory/registry_api/#factoryget_underlying_balances","text":"Factory.get_underlying_balances(pool: address) \u2192 uint256[8]: view Get balances for each underlying coin within a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_underlying_balances ( _pool : address ) -> uint256 [ MAX_COINS ]: \"\"\" @notice Get balances for each underlying coin within a metapool @param _pool Metapool address @return uint256 list of underlying balances \"\"\" underlying_balances : uint256 [ MAX_COINS ] = empty ( uint256 [ MAX_COINS ]) underlying_balances [ 0 ] = CurvePool ( _pool ) . balances ( 0 ) base_total_supply : uint256 = ERC20 ( self . pool_data [ _pool ] . coins [ 1 ]) . totalSupply () if base_total_supply > 0 : underlying_pct : uint256 = CurvePool ( _pool ) . balances ( 1 ) * 10 ** 36 / base_total_supply base_pool : address = self . pool_data [ _pool ] . base_pool assert base_pool != ZERO_ADDRESS # dev: pool is not a metapool n_coins : uint256 = self . base_pool_data [ base_pool ] . n_coins for i in range ( MAX_COINS ): if i == n_coins : break underlying_balances [ i + 1 ] = CurvePool ( base_pool ) . balances ( i ) * underlying_pct / 10 ** 36 return underlying_balances Example >>> factory.get_underlying_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 11876658145799734093379928 , 48715210997790596223520238 , 46553896776332824101242804 , 49543896565857325657915396 , 0 , 0 , 0 , 0 )","title":"Factory.get_underlying_balances"},{"location":"factory/registry_api/#factoryget_admin_balances","text":"Factory.get_admin_balances(pool: address) \u2192 uint256[2]: view Get the current admin balances (uncollected fees) for a pool. Input Type Description _pool address Address of the pool Source code @view @external def get_admin_balances ( _pool : address ) -> uint256 [ MAX_PLAIN_COINS ]: \"\"\" @notice Get the current admin balances (uncollected fees) for a pool @param _pool Pool address @return List of uint256 admin balances \"\"\" n_coins : uint256 = self . pool_data [ _pool ] . n_coins admin_balances : uint256 [ MAX_PLAIN_COINS ] = empty ( uint256 [ MAX_PLAIN_COINS ]) for i in range ( MAX_PLAIN_COINS ): if i == n_coins : break admin_balances [ i ] = CurvePool ( _pool ) . admin_balances ( i ) return admin_balances Example >>> factory.get_admin_balances ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) ( 10800690926373756722358 , 30891687335 )","title":"Factory.get_admin_balances"},{"location":"factory/registry_api/#factoryget_metapool_rates","text":"Factory.get_metapool_rates(_pool: address) \u2192 uint256[2]: view Get rates for coins within a metapool. Returns rates for each coin, precision normalized to 10**18 precision. Input Type Description _pool address Address of the pool Source code @view @external def get_metapool_rates ( _pool : address ) -> uint256 [ 2 ]: \"\"\" @notice Get rates for coins within a metapool @param _pool Pool address @return Rates for each coin, precision normalized to 10**18 \"\"\" rates : uint256 [ 2 ] = [ 10 ** 18 , 0 ] rates [ 1 ] = CurvePool ( self . pool_data [ _pool ] . base_pool ) . get_virtual_price () return rates Example >>> factory.get_rates ( '0xFD9f9784ac00432794c8D370d4910D2a3782324C' ) todo:","title":"Factory.get_metapool_rates"},{"location":"registry/overview/","text":"","title":"Overview"},{"location":"stableswap_exchange/overview/","text":"Curve StableSwap Exchange: Overview \u00b6 Curve achieves extremely efficient stablecoin trades by implementing the StableSwap invariant, which has significantly lower slippage for stablecoin trades than many other prominent invariants (e.g., constant-product). Note that in this context stablecoins refers to tokens that are stable representations of one another. This includes, for example, USD-pegged stablecoins (like DAI and USDC), but also ETH and sETH (synthetic ETH) or different versions of wrapped BTC. For a detailed overview of the StableSwap invariant design, please read the official StableSwap whitepaper . A Curve pool is essentially a smart contract that implements the StableSwap invariant and therefore contains the logic for exchanging stable tokens. However, while all Curve pools implement the StableSwap invariant, they may come in different pool flavors. In its simplest form, a Curve pool is an implementation of the StableSwap invariant with 2 or more tokens, which can be referred to as a plain pool. Alternative and more complex pool flavors include pools with lending functionality, so-called lending pools, as well as metapools, which are pools that allow for the exchange of one or more tokens with the tokens of one or more underlying base pools. Curve also integrates with Synthetix to offer cross-asset swaps. All exchange functionality that Curve supports, as well as noteworthy implementation details, are explained in technical depth in this section.","title":"Overview"},{"location":"stableswap_exchange/overview/#curve-stableswap-exchange-overview","text":"Curve achieves extremely efficient stablecoin trades by implementing the StableSwap invariant, which has significantly lower slippage for stablecoin trades than many other prominent invariants (e.g., constant-product). Note that in this context stablecoins refers to tokens that are stable representations of one another. This includes, for example, USD-pegged stablecoins (like DAI and USDC), but also ETH and sETH (synthetic ETH) or different versions of wrapped BTC. For a detailed overview of the StableSwap invariant design, please read the official StableSwap whitepaper . A Curve pool is essentially a smart contract that implements the StableSwap invariant and therefore contains the logic for exchanging stable tokens. However, while all Curve pools implement the StableSwap invariant, they may come in different pool flavors. In its simplest form, a Curve pool is an implementation of the StableSwap invariant with 2 or more tokens, which can be referred to as a plain pool. Alternative and more complex pool flavors include pools with lending functionality, so-called lending pools, as well as metapools, which are pools that allow for the exchange of one or more tokens with the tokens of one or more underlying base pools. Curve also integrates with Synthetix to offer cross-asset swaps. All exchange functionality that Curve supports, as well as noteworthy implementation details, are explained in technical depth in this section.","title":"Curve StableSwap Exchange: Overview"},{"location":"stableswap_exchange/cross_asset_swaps/overview/","text":"Curve integrates with Synthetix to allow large scale swaps between different asset classes with minimal slippage. Utilizing Synthetix\u2019 zero-slippage synth conversions and Curve\u2019s deep liquidity and low fees, we can perform fully on-chain cross asset swaps at scale with a 0.38% fee and minimal slippage. Cross asset swaps are performed using the SynthSwap contract, deployed to the mainnet at 0x58A3c68e2D3aAf316239c003779F71aCb870Ee47 . Source code and information on the technical implementation are available on Github . How SynthSwap works \u00b6 As an example, suppose we have asset A and wish to exchange it for asset D . For this swap to be possible, A and D must meet the following requirements: must be of different asset classes (e.g. USD, EUR, BTC, ETH), must be exchangeable for a Synthetic asset within one of Curve\u2019s pools (e.g. sUSD, sBTC). The swap can be visualized as A -> B -> C | C -> D : The initial asset A is exchanged on Curve for B , a synth of the same asset class. B is converted to C , a synth of the same asset class as D . A settlement period passes to account for sudden price movements between B and C . Once the settlement period has passed, C is exchanged on Curve for the desired asset D . For a more detailed reasoning behind the settlement period logic, refer to Synthetix SIP-37 . Settler NFT \u00b6 Swaps cannot occur atomically due to the Synthetix settlement period. Each unsettled swap is represented by an ERC721 non-fungible token. Each NFT has a unique token ID. Token IDs are never re-used. The NFT is minted upon initiating the swap and burned when the swap is completed. The NFT, and associated right to claim, is fully transferable. It is not possible to transfer the rights to a partial claim. The approved operator for an NFT also has the right to complete the swap with the underlying asset. Token IDs are not sequential. This contract does not support the enumerable ERC721 extension. This decision is based on gas efficiency. Front-running Considerations \u00b6 The benefits from these swaps are most apparent when the exchange amount is greater than $1m USD equivalent. As such, the initiation of a swap gives a strong indicator other market participants that a 2 nd post-settlement swap will be coming. We attempt to minimize the risks from this in several ways: C -> D is not declared on-chain when performing the swap from A -> C . It is possible to perform a partial swap from C -> D , and to swap into multiple final assets. The NFT persists until it has no remaining underlying balance of C . There is no fixed time frame for the second swap. A user can perform it immediately or wait until market conditions are more favorable. It is possible to withdraw C without performing a second swap. It is possible to perform additional A -> B -> C swaps to increase the balance of an already existing NFT. The range of available actions and time frames make it significantly more difficult to predict the outcome of a swap and trade against it.","title":"Overview"},{"location":"stableswap_exchange/cross_asset_swaps/overview/#how-synthswap-works","text":"As an example, suppose we have asset A and wish to exchange it for asset D . For this swap to be possible, A and D must meet the following requirements: must be of different asset classes (e.g. USD, EUR, BTC, ETH), must be exchangeable for a Synthetic asset within one of Curve\u2019s pools (e.g. sUSD, sBTC). The swap can be visualized as A -> B -> C | C -> D : The initial asset A is exchanged on Curve for B , a synth of the same asset class. B is converted to C , a synth of the same asset class as D . A settlement period passes to account for sudden price movements between B and C . Once the settlement period has passed, C is exchanged on Curve for the desired asset D . For a more detailed reasoning behind the settlement period logic, refer to Synthetix SIP-37 .","title":"How SynthSwap works"},{"location":"stableswap_exchange/cross_asset_swaps/overview/#settler-nft","text":"Swaps cannot occur atomically due to the Synthetix settlement period. Each unsettled swap is represented by an ERC721 non-fungible token. Each NFT has a unique token ID. Token IDs are never re-used. The NFT is minted upon initiating the swap and burned when the swap is completed. The NFT, and associated right to claim, is fully transferable. It is not possible to transfer the rights to a partial claim. The approved operator for an NFT also has the right to complete the swap with the underlying asset. Token IDs are not sequential. This contract does not support the enumerable ERC721 extension. This decision is based on gas efficiency.","title":"Settler NFT"},{"location":"stableswap_exchange/cross_asset_swaps/overview/#front-running-considerations","text":"The benefits from these swaps are most apparent when the exchange amount is greater than $1m USD equivalent. As such, the initiation of a swap gives a strong indicator other market participants that a 2 nd post-settlement swap will be coming. We attempt to minimize the risks from this in several ways: C -> D is not declared on-chain when performing the swap from A -> C . It is possible to perform a partial swap from C -> D , and to swap into multiple final assets. The NFT persists until it has no remaining underlying balance of C . There is no fixed time frame for the second swap. A user can perform it immediately or wait until market conditions are more favorable. It is possible to withdraw C without performing a second swap. It is possible to perform additional A -> B -> C swaps to increase the balance of an already existing NFT. The range of available actions and time frames make it significantly more difficult to predict the outcome of a swap and trade against it.","title":"Front-running Considerations"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/","text":"This section discusses the different methods in the Curve SynthSwap contract. Adding and Finding Swappable Assets \u00b6 In general, any asset that is within a Curve pool also containing a Synth may be used in a cross asset swap. SynthSwap.add_synth \u00b6 def add_synth(_synth: address, _pool: address) Add a new swappable synth. This method is callable by anyone, however _pool must exist within the Curve pool registry and _synth must be a valid synth that is swappable within the pool. Input Type Description _synth address Address of the synth _pool address Address of Curve pool containing the synth Emits: NewSynth Source code @external def add_synth ( _synth : address , _pool : address ): \"\"\" @notice Add a new swappable synth @dev Callable by anyone, however `_pool` must exist within the Curve pool registry and `_synth` must be a valid synth that is swappable within the pool @param _synth Address of the synth to add @param _pool Address of the Curve pool where `_synth` is swappable \"\"\" assert self . synth_pools [ _synth ] == ZERO_ADDRESS # dev: already added # this will revert if `_synth` is not actually a synth self . currency_keys [ _synth ] = Synth ( _synth ) . currencyKey () registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool_coins : address [ 8 ] = Registry ( registry ) . get_coins ( _pool ) has_synth : bool = False for coin in pool_coins : if coin == ZERO_ADDRESS : assert has_synth # dev: synth not in pool break if coin == _synth : self . synth_pools [ _synth ] = _pool has_synth = True self . swappable_synth [ coin ] = _synth log NewSynth ( _synth , _pool ) Example >>> todo: SynthSwap.synth_pools \u00b6 SynthSwap.synth_pools(_synth: address) \u2192 address: view Get the address of the Curve pool used to swap a synthetic asset. If this function returns ZERO_ADDRESS , the given synth cannot be used within cross-asset swaps. Input Type Description _synth address Address of the synth Source code # synth -> curve pool where it can be traded synth_pools : public ( HashMap [ address , address ]) ... Example >>> todo: SynthSwap.swappable_synth \u00b6 SynthSwap.swappable_synth(_token: address) \u2192 address: view Get the address of the synthetic asset that _token may be directly swapped for. If this function returns ZERO_ADDRESS , _token cannot be used within a cross-asset swap. Input Type Description _token address Address of the synth Source code # synth -> curve pool where it can be traded synth_pools : public ( HashMap [ address , address ]) ... Example >>> todo: Estimate Swap Amounts \u00b6 SynthSwap.get_swap_into_synth_amount \u00b6 SynthSwap.get_swap_into_synth_amount(_from: address, _synth: address, _amount: uint256) \u2192 uint256: view Returns the expected amount of _synth received in the swap. Input Type Description _from address Address of the initial asset being exchanged _synth address Address of the synth being swapped into _amount uint256 Amount of _from to swap Source code @view @internal def _get_swap_into ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () intermediate_synth : address = self . swappable_synth [ _from ] pool : address = self . synth_pools [ intermediate_synth ] synth_amount : uint256 = _amount if _from != intermediate_synth : i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _from , intermediate_synth ) synth_amount = Curve ( pool ) . get_dy ( i , j , _amount ) return self . exchanger . getAmountsForExchange ( synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ], )[ 0 ] @view @external def get_swap_into_synth_amount ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Return the amount received when performing a cross-asset swap @dev Used to calculate `_expected` when calling `swap_into_synth`. Be sure to reduce the value slightly to account for market movement prior to the transaction confirmation. @param _from Address of the initial asset being exchanged @param _synth Address of the synth being swapped into @param _amount Amount of `_from` to swap @return uint256 Expected amount of `_synth` received \"\"\" return self . _get_swap_into ( _from , _synth , _amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> synthswap.get_swap_into_synth_amount ( dai, sbtc, 100000 * 1e18 ) 2720559215249173192 Note This method is used to calculate _expected when calling swap_into_synth . You should reduce the value slightly to account for market movement prior to the transaction confirming. SynthSwap.get_swap_from_synth_amount \u00b6 SynthSwap.get_swap_from_synth_amount(_synth: address, _to: address, _amount: uint256) \u2192 uint256: view Returns the expected amount of _to received in the swap. Input Type Description _synth address Address of the synth being swapped out of _to address Address of the asset to swap into _amount uint256 Amount of _synth to swap Source code @view @internal def _get_swap_from ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool : address = self . synth_pools [ _synth ] i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _synth , _to ) return Curve ( pool ) . get_dy ( i , j , _amount ) @view @external def get_swap_from_synth_amount ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Return the amount received when swapping out of a settled synth @dev Used to calculate `_expected` when calling `swap_from_synth`. Be sure to reduce the value slightly to account for market movement prior to the transaction confirmation. @param _synth Address of the synth being swapped out of @param _to Address of the asset to swap into @param _amount Amount of `_synth` being exchanged @return uint256 Expected amount of `_to` received \"\"\" return self . _get_swap_from ( _synth , _to , _amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> synthswap.get_swap_from_synth_amount ( sbtc, wbtc, 2720559215249173192 ) 273663013 SynthSwap.get_estimated_swap_amount \u00b6 SynthSwap.get_estimated_swap_amount(_from: address, _to: address, _amount: uint256) \u2192 uint256: view Estimate the final amount of _to received when swapping between _from and _to . Input Type Description _from address Address of the initial asset being exchanged _to address Address of the asset to swap into _amount uint256 Amount of _from to swap Source code @view @internal def _get_swap_into ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () intermediate_synth : address = self . swappable_synth [ _from ] pool : address = self . synth_pools [ intermediate_synth ] synth_amount : uint256 = _amount if _from != intermediate_synth : i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _from , intermediate_synth ) synth_amount = Curve ( pool ) . get_dy ( i , j , _amount ) return self . exchanger . getAmountsForExchange ( synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ], )[ 0 ] ... @view @internal def _get_swap_from ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool : address = self . synth_pools [ _synth ] i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _synth , _to ) return Curve ( pool ) . get_dy ( i , j , _amount ) ... @view @external def get_estimated_swap_amount ( _from : address , _to : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Estimate the final amount received when swapping between `_from` and `_to` @dev Actual received amount may be different if synth rates change during settlement @param _from Address of the initial asset being exchanged @param _to Address of the asset to swap into @param _amount Amount of `_from` being exchanged @return uint256 Estimated amount of `_to` received \"\"\" synth : address = self . swappable_synth [ _to ] synth_amount : uint256 = self . _get_swap_into ( _from , synth , _amount ) return self . _get_swap_from ( synth , _to , synth_amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> synthswap.get_estimated_swap_amount ( dai, wbtc, 100000 * 1e18 ) 273663013 Note This method is for estimating the received amount from a complete swap over two transactions. If _to is a Synth, you should use get_swap_into_synth_amount instead. Note As swaps take a settlement period into account, the actual received amount may be different due to rate changes during the settlement period. Initiate a Swap \u00b6 SynthSwap.swap_into_synth \u00b6 SynthSwap.swap_into_synth(_from: address, _synth: address, _amount: uint256, _expected: uint256, _receiver: address = msg.sender, _existing_token_id: uint256 = 0) \u2192 uint256: payable Perform a cross-asset swap between _from and _synth . Returns the uint256 token ID of the NFT representing the unsettled swap. The token ID is also available from the emitted TokenUpdate event. Input Type Description _from address Address of the initial asset being exchanged. For Ether swaps, use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE . _synth address Address of the synth to swap into _amount uint256 Amount of _from to swap. If you are swapping from Ether, you must also send exactly this much Ether with the transaction. If you are swapping any other asset, you must have given approval to the swap contract to transfer at least this amount. _expected uint256 Minimum amount of _synth to receive _receiver address Address of the recipient of _synth . Defaults to the msg.sender . _existing_token_id uint256 Token ID to deposit _synth into. If not given, a new NFT is minted for the generated synth. When set as non-zero, the token ID must be owned by the caller and must already represent the same synth as is being swapped into. Emits: NewSettler Transfer TokenUpdate Source code @payable @external def swap_into_synth ( _from : address , _synth : address , _amount : uint256 , _expected : uint256 , _receiver : address = msg . sender , _existing_token_id : uint256 = 0 , ) -> uint256 : \"\"\" @notice Perform a cross-asset swap between `_from` and `_synth` @dev Synth swaps require a settlement time to complete and so the newly generated synth cannot immediately be transferred onward. Calling this function mints an NFT which represents ownership of the generated synth. Once the settlement time has passed, the owner may claim the synth by calling to `swap_from_synth` or `withdraw`. @param _from Address of the initial asset being exchanged @param _synth Address of the synth being swapped into @param _amount Amount of `_from` to swap @param _expected Minimum amount of `_synth` to receive @param _receiver Address of the recipient of `_synth`, if not given defaults to `msg.sender` @param _existing_token_id Token ID to deposit `_synth` into. If left as 0, a new NFT is minted for the generated synth. If non-zero, the token ID must be owned by `msg.sender` and must represent the same synth as is being swapped into. @return uint256 NFT token ID \"\"\" settler : address = ZERO_ADDRESS token_id : uint256 = 0 if _existing_token_id == 0 : # if no token ID is given we are initiating a new swap count : uint256 = self . id_count if count == 0 : # if there are no availale settler contracts we must deploy a new one settler = create_forwarder_to ( self . settler_implementation ) Settler ( settler ) . initialize () token_id = convert ( settler , uint256 ) log NewSettler ( settler ) else : count -= 1 token_id = self . available_token_ids [ count ] settler = convert ( token_id % ( 2 ** 160 ), address ) self . id_count = count else : # if a token ID is given we are adding to the balance of an existing swap # so must check to make sure this is a permitted action settler = convert ( _existing_token_id % ( 2 ** 160 ), address ) token_id = _existing_token_id owner : address = self . id_to_owner [ _existing_token_id ] if msg . sender != owner : assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _existing_token_id ] ), \"Caller is not owner or operator\" assert owner == _receiver , \"Receiver is not owner\" assert Settler ( settler ) . synth () == _synth , \"Incorrect synth for Token ID\" registry_swap : address = AddressProvider ( ADDRESS_PROVIDER ) . get_address ( 2 ) intermediate_synth : address = self . swappable_synth [ _from ] synth_amount : uint256 = 0 if intermediate_synth == _from : # if `_from` is already a synth, no initial curve exchange is required assert ERC20 ( _from ) . transferFrom ( msg . sender , settler , _amount ) synth_amount = _amount else : if _from != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE : # Vyper equivalent of SafeERC20Transfer, handles most ERC20 return values response : Bytes [ 32 ] = raw_call ( _from , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( _amount , bytes32 ), ), max_outsize = 32 , ) if len ( response ) != 0 : assert convert ( response , bool ) if not self . is_approved [ _from ][ registry_swap ]: response = raw_call ( _from , concat ( method_id ( \"approve(address,uint256)\" ), convert ( registry_swap , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( response ) != 0 : assert convert ( response , bool ) self . is_approved [ _from ][ registry_swap ] = True # use Curve to exchange for initial synth, which is sent to the settler synth_amount = RegistrySwap ( registry_swap ) . exchange ( self . synth_pools [ intermediate_synth ], _from , intermediate_synth , _amount , 0 , settler , value = msg . value ) # use Synthetix to convert initial synth into the target synth initial_balance : uint256 = ERC20 ( _synth ) . balanceOf ( settler ) Settler ( settler ) . convert_synth ( _synth , synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ] ) final_balance : uint256 = ERC20 ( _synth ) . balanceOf ( settler ) assert final_balance - initial_balance >= _expected , \"Rekt by slippage\" # if this is a new swap, mint an NFT to represent the unsettled conversion if _existing_token_id == 0 : self . id_to_owner [ token_id ] = _receiver self . owner_to_token_count [ _receiver ] += 1 log Transfer ( ZERO_ADDRESS , _receiver , token_id ) log TokenUpdate ( token_id , _receiver , _synth , final_balance ) return token_id Example >>> alice = accounts [ 0 ] >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> expected = synth_swap.get_swap_into_synth_amount ( dai, sbtc, dai.balanceOf ( alice )) * 0 .99 >>> tx = synth_swap.swap_into_synth ( dai, sbtc, expected, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 1200000 Nonce: 5 >>> tx.events [ 'TokenUpdate' ][ 'token_id' ] 2423994707895209386239865227163451060473904619065 Note Synth swaps require a settlement time to complete and so the newly generated synth cannot immediately be transferred onward. Calling this function mints an NFT representing ownership of the unsettled synth. Get Info about an Unsettled Swap \u00b6 SynthSwap.token_info \u00b6 SynthSwap.token_info(_token_id: uint256) \u2192 address, address, uint256, uint256: view Get information about the underlying synth represented by an NFT. Returns: the address of the owner of the NFT the address of the underlying synth the balance ( uint256 ) of the underlying synth the current maximum number of seconds until the synth may be settled ( uint256 ) Input Type Description _token_id uint256 NFT token ID to query info about. Reverts if the token ID does not exist. Source code @view @external def token_info ( _token_id : uint256 ) -> TokenInfo : \"\"\" @notice Get information about the synth represented by an NFT @param _token_id NFT token ID to query info about @return NFT owner Address of synth within the NFT Balance of the synth Max settlement time in seconds \"\"\" info : TokenInfo = empty ( TokenInfo ) info . owner = self . id_to_owner [ _token_id ] assert info . owner != ZERO_ADDRESS settler : address = convert ( _token_id % ( 2 ** 160 ), address ) info . synth = Settler ( settler ) . synth () info . underlying_balance = ERC20 ( info . synth ) . balanceOf ( settler ) if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ info . synth ] reclaim : uint256 = 0 rebate : uint256 = 0 reclaim , rebate = self . exchanger . settlementOwing ( settler , currency_key ) info . underlying_balance = info . underlying_balance - reclaim + rebate info . time_to_settle = self . exchanger . maxSecsLeftInWaitingPeriod ( settler , currency_key ) return info Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> synthswap.token_info ( 2423994707895209386239865227163451060473904619065 ) .dict () { 'owner' : \"0xEF422dBBF46120dE627fFb913C9AFaD44c735618\" , 'synth' : \"0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\" , 'time_to_settle' : 0 , 'underlying_balance' : 1155647333395694644849 } Complete a Swap \u00b6 SynthSwap.swap_from_synth \u00b6 SynthSwap.swap_from_synth(_token_id: uint256, _to: address, _amount: uint256, _expected: uint256, _receiver: address = msg.sender) \u2192 uint256: nonpayable Swap the underlying synth represented by an NFT into another asset. Callable by the owner or operator of _token_id after the synth settlement period has passed. If _amount is equal to the total remaining balance of the synth represented by the NFT, the NFT is burned. Returns the remaining balance of the underlying synth within the active NFT. Input Type Description _token_id uint256 The identifier for an NFT _to address Address of the asset to swap into _amount uint256 Amount of the underlying synth to swap _expected uint256 Minimum amount of _to to receive _receiver address Address to send the final received asset to. Defaults to msg.sender . Emits: Transfer TokenUpdate Source code @external def swap_from_synth ( _token_id : uint256 , _to : address , _amount : uint256 , _expected : uint256 , _receiver : address = msg . sender , ) -> uint256 : \"\"\" @notice Swap the synth represented by an NFT into another asset. @dev Callable by the owner or operator of `_token_id` after the synth settlement period has passed. If `_amount` is equal to the entire balance within the NFT, the NFT is burned. @param _token_id The identifier for an NFT @param _to Address of the asset to swap into @param _amount Amount of the synth to swap @param _expected Minimum amount of `_to` to receive @param _receiver Address of the recipient of the synth, if not given defaults to `msg.sender` @return uint256 Synth balance remaining in `_token_id` \"\"\" owner : address = self . id_to_owner [ _token_id ] if msg . sender != self . id_to_owner [ _token_id ]: assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _token_id ] ), \"Caller is not owner or operator\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = self . swappable_synth [ _to ] pool : address = self . synth_pools [ synth ] # ensure the synth is settled prior to swapping if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) self . is_settled [ _token_id ] = True # use Curve to exchange the synth for another asset which is sent to the receiver remaining : uint256 = Settler ( settler ) . exchange ( _to , pool , _amount , _expected , _receiver ) # if the balance of the synth within the NFT is now zero, burn the NFT if remaining == 0 : self . id_to_owner [ _token_id ] = ZERO_ADDRESS self . id_to_approval [ _token_id ] = ZERO_ADDRESS self . is_settled [ _token_id ] = False self . owner_to_token_count [ msg . sender ] -= 1 count : uint256 = self . id_count # add 2**160 to increment the nonce for next time this settler is used self . available_token_ids [ count ] = _token_id + 2 ** 160 self . id_count = count + 1 owner = ZERO_ADDRESS synth = ZERO_ADDRESS log Transfer ( msg . sender , ZERO_ADDRESS , _token_id ) log TokenUpdate ( _token_id , owner , synth , remaining ) return remaining Example >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> amount = synth_swap.token_info ( token_id )[ 'underlying_balance' ] >>> expected = swynth_swap.get_swap_from_synth_amount ( sbtc, wbtc, amount ) * 0 .99 >>> synth_swap.swap_from_synth ( token_id, wbtc, amount, expected, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 800000 Nonce: 6 SynthSwap.withdraw \u00b6 StableSwap.withdraw(_token_id: uint256, _amount: uint256, _receiver: address = msg.sender) \u2192 uint256: nonpayable Withdraw the underlying synth represented by an NFT. Callable by the owner or operator of _token_id after the synth settlement period has passed. If _amount is equal to the total remaining balance of the synth represented by the NFT, the NFT is burned. Returns the remaining balance of the underlying synth within the active NFT. Input Type Description _token_id uint256 The identifier for an NFT _amount uint256 Amount of the underlying synth to swap _receiver address Address of the recipient of the withdrawn synth. Defaults to the msg.sender . Emits: Transfer TokenUpdate Source code @external def withdraw ( _token_id : uint256 , _amount : uint256 , _receiver : address = msg . sender ) -> uint256 : \"\"\" @notice Withdraw the synth represented by an NFT. @dev Callable by the owner or operator of `_token_id` after the synth settlement period has passed. If `_amount` is equal to the entire balance within the NFT, the NFT is burned. @param _token_id The identifier for an NFT @param _amount Amount of the synth to withdraw @param _receiver Address of the recipient of the synth, if not given defaults to `msg.sender` @return uint256 Synth balance remaining in `_token_id` \"\"\" owner : address = self . id_to_owner [ _token_id ] if msg . sender != self . id_to_owner [ _token_id ]: assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _token_id ] ), \"Caller is not owner or operator\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = Settler ( settler ) . synth () # ensure the synth is settled prior to withdrawal if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) self . is_settled [ _token_id ] = True remaining : uint256 = Settler ( settler ) . withdraw ( _receiver , _amount ) # if the balance of the synth within the NFT is now zero, burn the NFT if remaining == 0 : self . id_to_owner [ _token_id ] = ZERO_ADDRESS self . id_to_approval [ _token_id ] = ZERO_ADDRESS self . is_settled [ _token_id ] = False self . owner_to_token_count [ msg . sender ] -= 1 count : uint256 = self . id_count # add 2**160 to increment the nonce for next time this settler is used self . available_token_ids [ count ] = _token_id + 2 ** 160 self . id_count = count + 1 owner = ZERO_ADDRESS synth = ZERO_ADDRESS log Transfer ( msg . sender , ZERO_ADDRESS , _token_id ) log TokenUpdate ( _token_id , owner , synth , remaining ) return remaining Example >>> amount = synth_swap.token_info ( token_id )[ 'underlying_balance' ] >>> synth_swap.withdraw ( token_id, amount, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 800000 Nonce: 6 SynthSwap.settle \u00b6 StableSwap.settle(_token_id: uint256) \u2192 bool: nonpayable Settle the synth represented in an NFT. Note that settlement is performed when swapping or withdrawing, there is no requirement to call this function separately. Returns True . Input Type Description _token_id uint256 The identifier for an NFT Source code @external def settle ( _token_id : uint256 ) -> bool : \"\"\" @notice Settle the synth represented in an NFT. @dev Settlement is performed when swapping or withdrawing, there is no requirement to call this function separately. @param _token_id The identifier for an NFT @return bool Success \"\"\" if not self . is_settled [ _token_id ]: assert self . id_to_owner [ _token_id ] != ZERO_ADDRESS , \"Unknown Token ID\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = Settler ( settler ) . synth () currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) # dev: settlement failed self . is_settled [ _token_id ] = True return True","title":"SynthSwap"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#adding-and-finding-swappable-assets","text":"In general, any asset that is within a Curve pool also containing a Synth may be used in a cross asset swap.","title":"Adding and Finding Swappable Assets"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapadd_synth","text":"def add_synth(_synth: address, _pool: address) Add a new swappable synth. This method is callable by anyone, however _pool must exist within the Curve pool registry and _synth must be a valid synth that is swappable within the pool. Input Type Description _synth address Address of the synth _pool address Address of Curve pool containing the synth Emits: NewSynth Source code @external def add_synth ( _synth : address , _pool : address ): \"\"\" @notice Add a new swappable synth @dev Callable by anyone, however `_pool` must exist within the Curve pool registry and `_synth` must be a valid synth that is swappable within the pool @param _synth Address of the synth to add @param _pool Address of the Curve pool where `_synth` is swappable \"\"\" assert self . synth_pools [ _synth ] == ZERO_ADDRESS # dev: already added # this will revert if `_synth` is not actually a synth self . currency_keys [ _synth ] = Synth ( _synth ) . currencyKey () registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool_coins : address [ 8 ] = Registry ( registry ) . get_coins ( _pool ) has_synth : bool = False for coin in pool_coins : if coin == ZERO_ADDRESS : assert has_synth # dev: synth not in pool break if coin == _synth : self . synth_pools [ _synth ] = _pool has_synth = True self . swappable_synth [ coin ] = _synth log NewSynth ( _synth , _pool ) Example >>> todo:","title":"SynthSwap.add_synth"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapsynth_pools","text":"SynthSwap.synth_pools(_synth: address) \u2192 address: view Get the address of the Curve pool used to swap a synthetic asset. If this function returns ZERO_ADDRESS , the given synth cannot be used within cross-asset swaps. Input Type Description _synth address Address of the synth Source code # synth -> curve pool where it can be traded synth_pools : public ( HashMap [ address , address ]) ... Example >>> todo:","title":"SynthSwap.synth_pools"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapswappable_synth","text":"SynthSwap.swappable_synth(_token: address) \u2192 address: view Get the address of the synthetic asset that _token may be directly swapped for. If this function returns ZERO_ADDRESS , _token cannot be used within a cross-asset swap. Input Type Description _token address Address of the synth Source code # synth -> curve pool where it can be traded synth_pools : public ( HashMap [ address , address ]) ... Example >>> todo:","title":"SynthSwap.swappable_synth"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#estimate-swap-amounts","text":"","title":"Estimate Swap Amounts"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapget_swap_into_synth_amount","text":"SynthSwap.get_swap_into_synth_amount(_from: address, _synth: address, _amount: uint256) \u2192 uint256: view Returns the expected amount of _synth received in the swap. Input Type Description _from address Address of the initial asset being exchanged _synth address Address of the synth being swapped into _amount uint256 Amount of _from to swap Source code @view @internal def _get_swap_into ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () intermediate_synth : address = self . swappable_synth [ _from ] pool : address = self . synth_pools [ intermediate_synth ] synth_amount : uint256 = _amount if _from != intermediate_synth : i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _from , intermediate_synth ) synth_amount = Curve ( pool ) . get_dy ( i , j , _amount ) return self . exchanger . getAmountsForExchange ( synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ], )[ 0 ] @view @external def get_swap_into_synth_amount ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Return the amount received when performing a cross-asset swap @dev Used to calculate `_expected` when calling `swap_into_synth`. Be sure to reduce the value slightly to account for market movement prior to the transaction confirmation. @param _from Address of the initial asset being exchanged @param _synth Address of the synth being swapped into @param _amount Amount of `_from` to swap @return uint256 Expected amount of `_synth` received \"\"\" return self . _get_swap_into ( _from , _synth , _amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> synthswap.get_swap_into_synth_amount ( dai, sbtc, 100000 * 1e18 ) 2720559215249173192 Note This method is used to calculate _expected when calling swap_into_synth . You should reduce the value slightly to account for market movement prior to the transaction confirming.","title":"SynthSwap.get_swap_into_synth_amount"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapget_swap_from_synth_amount","text":"SynthSwap.get_swap_from_synth_amount(_synth: address, _to: address, _amount: uint256) \u2192 uint256: view Returns the expected amount of _to received in the swap. Input Type Description _synth address Address of the synth being swapped out of _to address Address of the asset to swap into _amount uint256 Amount of _synth to swap Source code @view @internal def _get_swap_from ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool : address = self . synth_pools [ _synth ] i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _synth , _to ) return Curve ( pool ) . get_dy ( i , j , _amount ) @view @external def get_swap_from_synth_amount ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Return the amount received when swapping out of a settled synth @dev Used to calculate `_expected` when calling `swap_from_synth`. Be sure to reduce the value slightly to account for market movement prior to the transaction confirmation. @param _synth Address of the synth being swapped out of @param _to Address of the asset to swap into @param _amount Amount of `_synth` being exchanged @return uint256 Expected amount of `_to` received \"\"\" return self . _get_swap_from ( _synth , _to , _amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> synthswap.get_swap_from_synth_amount ( sbtc, wbtc, 2720559215249173192 ) 273663013","title":"SynthSwap.get_swap_from_synth_amount"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapget_estimated_swap_amount","text":"SynthSwap.get_estimated_swap_amount(_from: address, _to: address, _amount: uint256) \u2192 uint256: view Estimate the final amount of _to received when swapping between _from and _to . Input Type Description _from address Address of the initial asset being exchanged _to address Address of the asset to swap into _amount uint256 Amount of _from to swap Source code @view @internal def _get_swap_into ( _from : address , _synth : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () intermediate_synth : address = self . swappable_synth [ _from ] pool : address = self . synth_pools [ intermediate_synth ] synth_amount : uint256 = _amount if _from != intermediate_synth : i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _from , intermediate_synth ) synth_amount = Curve ( pool ) . get_dy ( i , j , _amount ) return self . exchanger . getAmountsForExchange ( synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ], )[ 0 ] ... @view @internal def _get_swap_from ( _synth : address , _to : address , _amount : uint256 ) -> uint256 : registry : address = AddressProvider ( ADDRESS_PROVIDER ) . get_registry () pool : address = self . synth_pools [ _synth ] i : int128 = 0 j : int128 = 0 i , j = Registry ( registry ) . get_coin_indices ( pool , _synth , _to ) return Curve ( pool ) . get_dy ( i , j , _amount ) ... @view @external def get_estimated_swap_amount ( _from : address , _to : address , _amount : uint256 ) -> uint256 : \"\"\" @notice Estimate the final amount received when swapping between `_from` and `_to` @dev Actual received amount may be different if synth rates change during settlement @param _from Address of the initial asset being exchanged @param _to Address of the asset to swap into @param _amount Amount of `_from` being exchanged @return uint256 Estimated amount of `_to` received \"\"\" synth : address = self . swappable_synth [ _to ] synth_amount : uint256 = self . _get_swap_into ( _from , synth , _amount ) return self . _get_swap_from ( synth , _to , synth_amount ) Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> synthswap.get_estimated_swap_amount ( dai, wbtc, 100000 * 1e18 ) 273663013 Note This method is for estimating the received amount from a complete swap over two transactions. If _to is a Synth, you should use get_swap_into_synth_amount instead. Note As swaps take a settlement period into account, the actual received amount may be different due to rate changes during the settlement period.","title":"SynthSwap.get_estimated_swap_amount"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#initiate-a-swap","text":"","title":"Initiate a Swap"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapswap_into_synth","text":"SynthSwap.swap_into_synth(_from: address, _synth: address, _amount: uint256, _expected: uint256, _receiver: address = msg.sender, _existing_token_id: uint256 = 0) \u2192 uint256: payable Perform a cross-asset swap between _from and _synth . Returns the uint256 token ID of the NFT representing the unsettled swap. The token ID is also available from the emitted TokenUpdate event. Input Type Description _from address Address of the initial asset being exchanged. For Ether swaps, use 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE . _synth address Address of the synth to swap into _amount uint256 Amount of _from to swap. If you are swapping from Ether, you must also send exactly this much Ether with the transaction. If you are swapping any other asset, you must have given approval to the swap contract to transfer at least this amount. _expected uint256 Minimum amount of _synth to receive _receiver address Address of the recipient of _synth . Defaults to the msg.sender . _existing_token_id uint256 Token ID to deposit _synth into. If not given, a new NFT is minted for the generated synth. When set as non-zero, the token ID must be owned by the caller and must already represent the same synth as is being swapped into. Emits: NewSettler Transfer TokenUpdate Source code @payable @external def swap_into_synth ( _from : address , _synth : address , _amount : uint256 , _expected : uint256 , _receiver : address = msg . sender , _existing_token_id : uint256 = 0 , ) -> uint256 : \"\"\" @notice Perform a cross-asset swap between `_from` and `_synth` @dev Synth swaps require a settlement time to complete and so the newly generated synth cannot immediately be transferred onward. Calling this function mints an NFT which represents ownership of the generated synth. Once the settlement time has passed, the owner may claim the synth by calling to `swap_from_synth` or `withdraw`. @param _from Address of the initial asset being exchanged @param _synth Address of the synth being swapped into @param _amount Amount of `_from` to swap @param _expected Minimum amount of `_synth` to receive @param _receiver Address of the recipient of `_synth`, if not given defaults to `msg.sender` @param _existing_token_id Token ID to deposit `_synth` into. If left as 0, a new NFT is minted for the generated synth. If non-zero, the token ID must be owned by `msg.sender` and must represent the same synth as is being swapped into. @return uint256 NFT token ID \"\"\" settler : address = ZERO_ADDRESS token_id : uint256 = 0 if _existing_token_id == 0 : # if no token ID is given we are initiating a new swap count : uint256 = self . id_count if count == 0 : # if there are no availale settler contracts we must deploy a new one settler = create_forwarder_to ( self . settler_implementation ) Settler ( settler ) . initialize () token_id = convert ( settler , uint256 ) log NewSettler ( settler ) else : count -= 1 token_id = self . available_token_ids [ count ] settler = convert ( token_id % ( 2 ** 160 ), address ) self . id_count = count else : # if a token ID is given we are adding to the balance of an existing swap # so must check to make sure this is a permitted action settler = convert ( _existing_token_id % ( 2 ** 160 ), address ) token_id = _existing_token_id owner : address = self . id_to_owner [ _existing_token_id ] if msg . sender != owner : assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _existing_token_id ] ), \"Caller is not owner or operator\" assert owner == _receiver , \"Receiver is not owner\" assert Settler ( settler ) . synth () == _synth , \"Incorrect synth for Token ID\" registry_swap : address = AddressProvider ( ADDRESS_PROVIDER ) . get_address ( 2 ) intermediate_synth : address = self . swappable_synth [ _from ] synth_amount : uint256 = 0 if intermediate_synth == _from : # if `_from` is already a synth, no initial curve exchange is required assert ERC20 ( _from ) . transferFrom ( msg . sender , settler , _amount ) synth_amount = _amount else : if _from != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE : # Vyper equivalent of SafeERC20Transfer, handles most ERC20 return values response : Bytes [ 32 ] = raw_call ( _from , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( _amount , bytes32 ), ), max_outsize = 32 , ) if len ( response ) != 0 : assert convert ( response , bool ) if not self . is_approved [ _from ][ registry_swap ]: response = raw_call ( _from , concat ( method_id ( \"approve(address,uint256)\" ), convert ( registry_swap , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( response ) != 0 : assert convert ( response , bool ) self . is_approved [ _from ][ registry_swap ] = True # use Curve to exchange for initial synth, which is sent to the settler synth_amount = RegistrySwap ( registry_swap ) . exchange ( self . synth_pools [ intermediate_synth ], _from , intermediate_synth , _amount , 0 , settler , value = msg . value ) # use Synthetix to convert initial synth into the target synth initial_balance : uint256 = ERC20 ( _synth ) . balanceOf ( settler ) Settler ( settler ) . convert_synth ( _synth , synth_amount , self . currency_keys [ intermediate_synth ], self . currency_keys [ _synth ] ) final_balance : uint256 = ERC20 ( _synth ) . balanceOf ( settler ) assert final_balance - initial_balance >= _expected , \"Rekt by slippage\" # if this is a new swap, mint an NFT to represent the unsettled conversion if _existing_token_id == 0 : self . id_to_owner [ token_id ] = _receiver self . owner_to_token_count [ _receiver ] += 1 log Transfer ( ZERO_ADDRESS , _receiver , token_id ) log TokenUpdate ( token_id , _receiver , _synth , final_balance ) return token_id Example >>> alice = accounts [ 0 ] >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> dai = Contract ( '0x6b175474e89094c44da98b954eedeac495271d0f' ) >>> sbtc = Contract ( '0xfe18be6b3bd88a2d2a7f928d00292e7a9963cfc6' ) >>> expected = synth_swap.get_swap_into_synth_amount ( dai, sbtc, dai.balanceOf ( alice )) * 0 .99 >>> tx = synth_swap.swap_into_synth ( dai, sbtc, expected, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 1200000 Nonce: 5 >>> tx.events [ 'TokenUpdate' ][ 'token_id' ] 2423994707895209386239865227163451060473904619065 Note Synth swaps require a settlement time to complete and so the newly generated synth cannot immediately be transferred onward. Calling this function mints an NFT representing ownership of the unsettled synth.","title":"SynthSwap.swap_into_synth"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#get-info-about-an-unsettled-swap","text":"","title":"Get Info about an Unsettled Swap"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswaptoken_info","text":"SynthSwap.token_info(_token_id: uint256) \u2192 address, address, uint256, uint256: view Get information about the underlying synth represented by an NFT. Returns: the address of the owner of the NFT the address of the underlying synth the balance ( uint256 ) of the underlying synth the current maximum number of seconds until the synth may be settled ( uint256 ) Input Type Description _token_id uint256 NFT token ID to query info about. Reverts if the token ID does not exist. Source code @view @external def token_info ( _token_id : uint256 ) -> TokenInfo : \"\"\" @notice Get information about the synth represented by an NFT @param _token_id NFT token ID to query info about @return NFT owner Address of synth within the NFT Balance of the synth Max settlement time in seconds \"\"\" info : TokenInfo = empty ( TokenInfo ) info . owner = self . id_to_owner [ _token_id ] assert info . owner != ZERO_ADDRESS settler : address = convert ( _token_id % ( 2 ** 160 ), address ) info . synth = Settler ( settler ) . synth () info . underlying_balance = ERC20 ( info . synth ) . balanceOf ( settler ) if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ info . synth ] reclaim : uint256 = 0 rebate : uint256 = 0 reclaim , rebate = self . exchanger . settlementOwing ( settler , currency_key ) info . underlying_balance = info . underlying_balance - reclaim + rebate info . time_to_settle = self . exchanger . maxSecsLeftInWaitingPeriod ( settler , currency_key ) return info Example >>> synth_swap = Contract ( '0x58A3c68e2D3aAf316239c003779F71aCb870Ee47' ) >>> synthswap.token_info ( 2423994707895209386239865227163451060473904619065 ) .dict () { 'owner' : \"0xEF422dBBF46120dE627fFb913C9AFaD44c735618\" , 'synth' : \"0x57Ab1ec28D129707052df4dF418D58a2D46d5f51\" , 'time_to_settle' : 0 , 'underlying_balance' : 1155647333395694644849 }","title":"SynthSwap.token_info"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#complete-a-swap","text":"","title":"Complete a Swap"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapswap_from_synth","text":"SynthSwap.swap_from_synth(_token_id: uint256, _to: address, _amount: uint256, _expected: uint256, _receiver: address = msg.sender) \u2192 uint256: nonpayable Swap the underlying synth represented by an NFT into another asset. Callable by the owner or operator of _token_id after the synth settlement period has passed. If _amount is equal to the total remaining balance of the synth represented by the NFT, the NFT is burned. Returns the remaining balance of the underlying synth within the active NFT. Input Type Description _token_id uint256 The identifier for an NFT _to address Address of the asset to swap into _amount uint256 Amount of the underlying synth to swap _expected uint256 Minimum amount of _to to receive _receiver address Address to send the final received asset to. Defaults to msg.sender . Emits: Transfer TokenUpdate Source code @external def swap_from_synth ( _token_id : uint256 , _to : address , _amount : uint256 , _expected : uint256 , _receiver : address = msg . sender , ) -> uint256 : \"\"\" @notice Swap the synth represented by an NFT into another asset. @dev Callable by the owner or operator of `_token_id` after the synth settlement period has passed. If `_amount` is equal to the entire balance within the NFT, the NFT is burned. @param _token_id The identifier for an NFT @param _to Address of the asset to swap into @param _amount Amount of the synth to swap @param _expected Minimum amount of `_to` to receive @param _receiver Address of the recipient of the synth, if not given defaults to `msg.sender` @return uint256 Synth balance remaining in `_token_id` \"\"\" owner : address = self . id_to_owner [ _token_id ] if msg . sender != self . id_to_owner [ _token_id ]: assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _token_id ] ), \"Caller is not owner or operator\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = self . swappable_synth [ _to ] pool : address = self . synth_pools [ synth ] # ensure the synth is settled prior to swapping if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) self . is_settled [ _token_id ] = True # use Curve to exchange the synth for another asset which is sent to the receiver remaining : uint256 = Settler ( settler ) . exchange ( _to , pool , _amount , _expected , _receiver ) # if the balance of the synth within the NFT is now zero, burn the NFT if remaining == 0 : self . id_to_owner [ _token_id ] = ZERO_ADDRESS self . id_to_approval [ _token_id ] = ZERO_ADDRESS self . is_settled [ _token_id ] = False self . owner_to_token_count [ msg . sender ] -= 1 count : uint256 = self . id_count # add 2**160 to increment the nonce for next time this settler is used self . available_token_ids [ count ] = _token_id + 2 ** 160 self . id_count = count + 1 owner = ZERO_ADDRESS synth = ZERO_ADDRESS log Transfer ( msg . sender , ZERO_ADDRESS , _token_id ) log TokenUpdate ( _token_id , owner , synth , remaining ) return remaining Example >>> wbtc = Contract ( '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ) >>> amount = synth_swap.token_info ( token_id )[ 'underlying_balance' ] >>> expected = swynth_swap.get_swap_from_synth_amount ( sbtc, wbtc, amount ) * 0 .99 >>> synth_swap.swap_from_synth ( token_id, wbtc, amount, expected, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 800000 Nonce: 6","title":"SynthSwap.swap_from_synth"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapwithdraw","text":"StableSwap.withdraw(_token_id: uint256, _amount: uint256, _receiver: address = msg.sender) \u2192 uint256: nonpayable Withdraw the underlying synth represented by an NFT. Callable by the owner or operator of _token_id after the synth settlement period has passed. If _amount is equal to the total remaining balance of the synth represented by the NFT, the NFT is burned. Returns the remaining balance of the underlying synth within the active NFT. Input Type Description _token_id uint256 The identifier for an NFT _amount uint256 Amount of the underlying synth to swap _receiver address Address of the recipient of the withdrawn synth. Defaults to the msg.sender . Emits: Transfer TokenUpdate Source code @external def withdraw ( _token_id : uint256 , _amount : uint256 , _receiver : address = msg . sender ) -> uint256 : \"\"\" @notice Withdraw the synth represented by an NFT. @dev Callable by the owner or operator of `_token_id` after the synth settlement period has passed. If `_amount` is equal to the entire balance within the NFT, the NFT is burned. @param _token_id The identifier for an NFT @param _amount Amount of the synth to withdraw @param _receiver Address of the recipient of the synth, if not given defaults to `msg.sender` @return uint256 Synth balance remaining in `_token_id` \"\"\" owner : address = self . id_to_owner [ _token_id ] if msg . sender != self . id_to_owner [ _token_id ]: assert owner != ZERO_ADDRESS , \"Unknown Token ID\" assert ( self . owner_to_operators [ owner ][ msg . sender ] or msg . sender == self . id_to_approval [ _token_id ] ), \"Caller is not owner or operator\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = Settler ( settler ) . synth () # ensure the synth is settled prior to withdrawal if not self . is_settled [ _token_id ]: currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) self . is_settled [ _token_id ] = True remaining : uint256 = Settler ( settler ) . withdraw ( _receiver , _amount ) # if the balance of the synth within the NFT is now zero, burn the NFT if remaining == 0 : self . id_to_owner [ _token_id ] = ZERO_ADDRESS self . id_to_approval [ _token_id ] = ZERO_ADDRESS self . is_settled [ _token_id ] = False self . owner_to_token_count [ msg . sender ] -= 1 count : uint256 = self . id_count # add 2**160 to increment the nonce for next time this settler is used self . available_token_ids [ count ] = _token_id + 2 ** 160 self . id_count = count + 1 owner = ZERO_ADDRESS synth = ZERO_ADDRESS log Transfer ( msg . sender , ZERO_ADDRESS , _token_id ) log TokenUpdate ( _token_id , owner , synth , remaining ) return remaining Example >>> amount = synth_swap.token_info ( token_id )[ 'underlying_balance' ] >>> synth_swap.withdraw ( token_id, amount, { 'from' : alice }) Transaction sent: 0x83b311af19be08b8ec6241c3e834ccdf3b22586971de82a76a641e43bdf2b3ee Gas price: 20 gwei Gas limit: 800000 Nonce: 6","title":"SynthSwap.withdraw"},{"location":"stableswap_exchange/cross_asset_swaps/synthswap_exchange/#synthswapsettle","text":"StableSwap.settle(_token_id: uint256) \u2192 bool: nonpayable Settle the synth represented in an NFT. Note that settlement is performed when swapping or withdrawing, there is no requirement to call this function separately. Returns True . Input Type Description _token_id uint256 The identifier for an NFT Source code @external def settle ( _token_id : uint256 ) -> bool : \"\"\" @notice Settle the synth represented in an NFT. @dev Settlement is performed when swapping or withdrawing, there is no requirement to call this function separately. @param _token_id The identifier for an NFT @return bool Success \"\"\" if not self . is_settled [ _token_id ]: assert self . id_to_owner [ _token_id ] != ZERO_ADDRESS , \"Unknown Token ID\" settler : address = convert ( _token_id % ( 2 ** 160 ), address ) synth : address = Settler ( settler ) . synth () currency_key : bytes32 = self . currency_keys [ synth ] self . exchanger . settle ( settler , currency_key ) # dev: settlement failed self . is_settled [ _token_id ] = True return True","title":"SynthSwap.settle"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/","text":"While Curve lending pools support swaps in both the wrapped and underlying coins, not all lending pools allow liquidity providers to deposit or withdraw the underlying coin. For example, the Compound Pool allows swaps between cDai and cUSDC (wrapped coins), as well as swaps between DAI and USDC (underlying coins). However, liquidity providers are not able to deposit DAI or USDC to the pool directly. The main reason for why this is not supported by all Curve lending pools lies in the size limit of contracts . Lending pools may differ in complexity and can end up being very close to the contract byte code size limit. In order to overcome this restriction, liquidity can be added and removed to and from a lending pool in the underlying coins via a different contract, called a deposit zap, tailored to lending pools. For an overview of the Curve lending pool implementation, please refer to the Lending Pool section. The template source code for a lending pool deposit zap may be viewed on GitHub . Note Lending pool deposit zaps may differ in their API. Older pools do not implement the newer API template . Deposit Zap (Old) \u00b6 Older Curve lending pool deposit zaps do not implement the template API . The deposit zaps which employ an older API are: DepositBUSD : BUSD pool deposit zap DepositCompound : Compound pool deposit zap DepositPAX : PAX pool deposit zap DepositUSDT : USDT pool deposit zap DepositY : Y pool deposit zap While not a lending pool, note that the following contract also implements the newer deposit zap API: DepositSUSD : SUSD pool deposit zap Note Getters generated for public arrays changed between Vyper 0.1.x and 0.2.x to accept uint256 instead of int128 in order to handle the lookups. Older deposit zap contracts (v1) use vyper 0.1.x... , while newer zaps (v2) use vyper 0.2.x... . The following Brownie console interaction examples are using the Compound Pool Deposit Zap . Get Deposit Zap Information \u00b6 DepositZap.curve \u00b6 DepositZap.curve() \u2192 address: view Getter for the pool associated with this deposit contract. Source code coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.curve () '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56' DepositZap.underlying_coins \u00b6 DepositZap.underlying_coins(i: int128) \u2192 address: view Getter for the array of underlying coins within the associated pool. Input Type Description i int128 Index of the underlying coin for which to get the address Source code N_COINS : constant ( int128 ) = 4 ... coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.underlying_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> zap.underlying_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' DepositZap.coins \u00b6 DepositZap.coins(i: int128) \u2192 address: view Getter for the array of wrapped coins within the associated pool. Input Type Description i int128 Index of the coin for which to get the address Source code N_COINS : constant ( int128 ) = 4 ... coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563' DepositZap.token \u00b6 DepositZap.token() \u2192 address: view Getter for the LP token of the associated pool. Source code coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563' Add/Remove Liquidity \u00b6 DepositZap.add_liquidity \u00b6 DepositZap.add_liquidity(uamounts: uint256[N_COINS], min_mint_amount: uint256) Wrap underlying coins and deposit them in the pool. Input Type Description uamounts uint256[N_COINS] List of amounts of underlying coins to deposit min_mint_amount uint256 Minimum amount of LP token to mint from the deposit Emits: AddLiquidity Transfer Source code Zap Contract Methods Pool Methods Pool Token Methods USE_LENDING : constant ( bool [ N_COINS ]) = [ True , True ] ... @public @nonreentrant ( 'lock' ) def add_liquidity ( uamounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED amounts : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): uamount : uint256 = uamounts [ i ] if uamount > 0 : # Transfer the underlying coin from owner if tethered [ i ]: USDT ( self . underlying_coins [ i ]) . transferFrom ( msg . sender , self , uamount ) else : assert_modifiable ( ERC20 ( self . underlying_coins [ i ]) \\ . transferFrom ( msg . sender , self , uamount )) # Mint if needed if use_lending [ i ]: ERC20 ( self . underlying_coins [ i ]) . approve ( self . coins [ i ], uamount ) ok : uint256 = cERC20 ( self . coins [ i ]) . mint ( uamount ) if ok > 0 : raise \"Could not mint coin\" amounts [ i ] = cERC20 ( self . coins [ i ]) . balanceOf ( self ) ERC20 ( self . coins [ i ]) . approve ( self . curve , amounts [ i ]) else : amounts [ i ] = uamount ERC20 ( self . underlying_coins [ i ]) . approve ( self . curve , uamount ) Curve ( self . curve ) . add_liquidity ( amounts , min_mint_amount ) tokens : uint256 = ERC20 ( self . token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( self . token ) . transfer ( msg . sender , tokens )) @public @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): # Amounts is amounts of c-tokens assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING fees : uint256 [ N_COINS ] = ZEROS _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee token_supply : uint256 = self . token . totalSupply () rates : uint256 [ N_COINS ] = self . _current_rates () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( rates , old_balances ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( rates , new_balances ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 if token_supply > 0 : # Only account for fees if we are not the first to deposit for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( rates , new_balances ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transferFrom ( msg . sender , self , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , amounts [ i ])) # Mint pool tokens self . token . mint ( msg . sender , mint_amount ) log . AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) @public def mint ( _to : address , _value : uint256 ): \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log . Transfer ( ZERO_ADDRESS , _to , _value ) Example >>> todo: DepositZap.remove_liquidity \u00b6 DepositZap.remove_liquidity(_amount: uint256, min_uamounts: uint256[N_COINS]) Withdraw and unwrap coins from the pool. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal min_uamounts uint256[N_COINS] Minimum amounts of underlying coins to receive Emits: Transfer RemoveLiquidity Source code Zap Contract Methods Pool Methods Pool Token Methods @private def _send_all ( _addr : address , min_uamounts : uint256 [ N_COINS ], one : int128 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED for i in range ( N_COINS ): if ( one < 0 ) or ( i == one ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = cERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue ok : uint256 = cERC20 ( _coin ) . redeem ( _balance ) if ok > 0 : raise \"Could not redeem coin\" _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= min_uamounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount >= 0 : if tethered [ i ]: USDT ( _ucoin ) . transfer ( _addr , _uamount ) else : assert_modifiable ( ERC20 ( _ucoin ) . transfer ( _addr , _uamount )) @public @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_uamounts : uint256 [ N_COINS ]): zeros : uint256 [ N_COINS ] = ZEROS assert_modifiable ( ERC20 ( self . token ) . transferFrom ( msg . sender , self , _amount )) Curve ( self . curve ) . remove_liquidity ( _amount , zeros ) self . _send_all ( msg . sender , min_uamounts , - 1 ) @public @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]): total_supply : uint256 = self . token . totalSupply () amounts : uint256 [ N_COINS ] = ZEROS fees : uint256 [ N_COINS ] = ZEROS tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , value ) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , value )) self . token . burnFrom ( msg . sender , _amount ) # Will raise if not enough log . RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Example >>> todo: DepositZap.remove_liquidity_imbalance \u00b6 DepositZap.remove_liquidity_imbalance(uamounts: uint256[N_COINS], max_burn_amount: uint256) Withdraw and unwrap coins from the pool in an imbalanced amount. Input Type Description uamounts uint256[N_COINS] List of amounts of underlying coins to withdraw max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods Pool Token Methods @private def _send_all ( _addr : address , min_uamounts : uint256 [ N_COINS ], one : int128 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED for i in range ( N_COINS ): if ( one < 0 ) or ( i == one ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = cERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue ok : uint256 = cERC20 ( _coin ) . redeem ( _balance ) if ok > 0 : raise \"Could not redeem coin\" _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= min_uamounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount >= 0 : if tethered [ i ]: USDT ( _ucoin ) . transfer ( _addr , _uamount ) else : assert_modifiable ( ERC20 ( _ucoin ) . transfer ( _addr , _uamount )) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( uamounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): \"\"\" Get max_burn_amount in, remove requested liquidity and transfer back what is left \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED _token : address = self . token amounts : uint256 [ N_COINS ] = uamounts for i in range ( N_COINS ): if use_lending [ i ] and amounts [ i ] > 0 : rate : uint256 = cERC20 ( self . coins [ i ]) . exchangeRateCurrent () amounts [ i ] = amounts [ i ] * LENDING_PRECISION / rate # if not use_lending - all good already # Transfrer max tokens in _tokens : uint256 = ERC20 ( _token ) . balanceOf ( msg . sender ) if _tokens > max_burn_amount : _tokens = max_burn_amount assert_modifiable ( ERC20 ( _token ) . transferFrom ( msg . sender , self , _tokens )) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , max_burn_amount ) # Transfer unused tokens back _tokens = ERC20 ( _token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( _token ) . transfer ( msg . sender , _tokens )) # Unwrap and transfer all the coins we've got self . _send_all ( msg . sender , ZEROS , - 1 ) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING token_supply : uint256 = self . token . totalSupply () assert token_supply > 0 _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee rates : uint256 [ N_COINS ] = self . _current_rates () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( rates , old_balances ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( rates , new_balances ) fees : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( rates , new_balances ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount > 0 assert token_amount <= max_burn_amount , \"Slippage screwed you\" for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ])) self . token . burnFrom ( msg . sender , token_amount ) # Will raise if not enough log . RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Example >>> todo: DepositZap.remove_liquidity_one_coin \u00b6 DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False) Withdraw and unwrap a single coin from the pool. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw min_uamount uint256 Minimum amount of underlying coin to receive donate_dust bool Donates collected dust liquidity to msg.sender Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods Pool Token Methods @public @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , min_uamount : uint256 , donate_dust : bool = False ): \"\"\" Remove _amount of liquidity all in a form of coin i \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING rates : uint256 [ N_COINS ] = ZEROS _token : address = self . token for j in range ( N_COINS ): if use_lending [ j ]: rates [ j ] = cERC20 ( self . coins [ j ]) . exchangeRateCurrent () else : rates [ j ] = LENDING_PRECISION dy : uint256 = self . _calc_withdraw_one_coin ( _token_amount , i , rates ) assert dy >= min_uamount , \"Not enough coins removed\" assert_modifiable ( ERC20 ( self . token ) . transferFrom ( msg . sender , self , _token_amount )) amounts : uint256 [ N_COINS ] = ZEROS amounts [ i ] = dy * LENDING_PRECISION / rates [ i ] token_amount_before : uint256 = ERC20 ( _token ) . balanceOf ( self ) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , _token_amount ) # Unwrap and transfer all the coins we've got self . _send_all ( msg . sender , ZEROS , i ) if not donate_dust : # Transfer unused tokens back token_amount_after : uint256 = ERC20 ( _token ) . balanceOf ( self ) if token_amount_after > token_amount_before : assert_modifiable ( ERC20 ( _token ) . transfer ( msg . sender , token_amount_after - token_amount_before ) ) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING token_supply : uint256 = self . token . totalSupply () assert token_supply > 0 _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee rates : uint256 [ N_COINS ] = self . _current_rates () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( rates , old_balances ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( rates , new_balances ) fees : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( rates , new_balances ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount > 0 assert token_amount <= max_burn_amount , \"Slippage screwed you\" for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ])) self . token . burnFrom ( msg . sender , token_amount ) # Will raise if not enough log . RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Note The underlying pool method called when the older DepositZap contract's remove_liquidity_one_coin is called emits RemoveLiquidityImbalance whereas the newer contract emits RemoveLiquidityOne . This is because the older contracts do not have the remove_liquidity_one_coin , and instead use remove_liquidity_imbalance . Example >>> todo: DepositZap.calc_withdraw_one_coin \u00b6 DepositZap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing a single underlying coin. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw Source code @private @constant def _calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 , rates : uint256 [ N_COINS ]) -> uint256 : # First, need to calculate # * Get current D # * Solve Eqn against y_i for D - _token_amount use_lending : bool [ N_COINS ] = USE_LENDING # tethered: bool[N_COINS] = TETHERED crv : address = self . curve A : uint256 = Curve ( crv ) . A () fee : uint256 = Curve ( crv ) . fee () * N_COINS / ( 4 * ( N_COINS - 1 )) fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR # Overcharge to account for imprecision precisions : uint256 [ N_COINS ] = PRECISION_MUL total_supply : uint256 = ERC20 ( self . token ) . totalSupply () xp : uint256 [ N_COINS ] = PRECISION_MUL S : uint256 = 0 for j in range ( N_COINS ): xp [ j ] *= Curve ( crv ) . balances ( j ) if use_lending [ j ]: # Use stored rate b/c we have imprecision anyway xp [ j ] = xp [ j ] * rates [ j ] / LENDING_PRECISION S += xp [ j ] # if not use_lending - all good already D0 : uint256 = self . get_D ( A , xp ) D1 : uint256 = D0 - _token_amount * D0 / total_supply xp_reduced : uint256 [ N_COINS ] = xp # xp = xp - fee * | xp * D1 / D0 - (xp - S * dD / D0 * (0, ... 1, ..0))| for j in range ( N_COINS ): dx_expected : uint256 = 0 b_ideal : uint256 = xp [ j ] * D1 / D0 b_expected : uint256 = xp [ j ] if j == i : b_expected -= S * ( D0 - D1 ) / D0 if b_ideal >= b_expected : dx_expected = ( b_ideal - b_expected ) else : dx_expected = ( b_expected - b_ideal ) xp_reduced [ j ] -= fee * dx_expected / FEE_DENOMINATOR dy : uint256 = xp_reduced [ i ] - self . get_y ( A , i , xp_reduced , D1 ) dy = dy / precisions [ i ] return dy @public @constant def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : rates : uint256 [ N_COINS ] = ZEROS use_lending : bool [ N_COINS ] = USE_LENDING for j in range ( N_COINS ): if use_lending [ j ]: rates [ j ] = cERC20 ( self . coins [ j ]) . exchangeRateStored () else : rates [ j ] = 10 ** 18 return self . _calc_withdraw_one_coin ( _token_amount , i , rates ) Example >>> todo: DepositZap.withdraw_donated_dust \u00b6 DepositZap.withdraw_donated_dust() Donates any LP tokens of the associated pool held by this contract to the contract owner. Source code @public @nonreentrant ( 'lock' ) def withdraw_donated_dust (): owner : address = Curve ( self . curve ) . owner () assert msg . sender == owner _token : address = self . token assert_modifiable ( ERC20 ( _token ) . transfer ( owner , ERC20 ( _token ) . balanceOf ( self ))) Example >>> todo: Deposit Zap (New) \u00b6 Compared to the older deposit zaps, the newer zaps mainly optimize for gas efficiency. The API is only modified in part, specifically with regards to return values and variable naming. Get Deposit Zap Information \u00b6 DepositZap.curve \u00b6 DepositZap.curve() \u2192 address: view Getter for the pool associated with this deposit contract. Source code @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.curve () '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56' DepositZap.underlying_coins \u00b6 DepositZap.underlying_coins(i: int128) \u2192 address: view Getter for the array of underlying coins within the associated pool. Input Type Description i int128 Index of the underlying coin for which to get the address Source code underlying_coins : public ( address [ N_COINS ]) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.underlying_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> zap.underlying_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' DepositZap.coins \u00b6 DepositZap.coins(i: int128) \u2192 address: view Getter for the array of wrapped coins within the associated pool. Input Type Description i int128 Index of the coin for which to get the address Source code coins : public ( address [ N_COINS ]) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563' DepositZap.token \u00b6 DepositZap.token() \u2192 address: view Getter for the LP token of the associated pool. Source code lp_token : public ( address ) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563' Add/Remove Liquidity \u00b6 DepositZap.add_liquidity \u00b6 DepositZap.add_liquidity(_underlying_amounts: uint256[N_COINS], _min_mint_amount: uint256) -> uint256 Wrap underlying coins and deposit them in the pool. Returns the amount of LP token received in exchange for the deposited amounts. Input Type Description _underlying_amounts uint256[N_COINS] List of amounts of underlying coins to deposit _min_mint_amount uint256 Minimum amount of LP token to mint from the deposit Emits: Transfer AddLiquidity Source code Zap Contract Methods Pool Methods @public @nonreentrant ( 'lock' ) def add_liquidity ( uamounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): tethered : bool [ N_COINS ] = TETHERED amounts : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): uamount : uint256 = uamounts [ i ] if uamount > 0 : # Transfer the underlying coin from owner if tethered [ i ]: USDT ( self . underlying_coins [ i ]) . transferFrom ( msg . sender , self , uamount ) else : assert_modifiable ( ERC20 ( self . underlying_coins [ i ]) \\ . transferFrom ( msg . sender , self , uamount )) # Mint if needed ERC20 ( self . underlying_coins [ i ]) . approve ( self . coins [ i ], uamount ) yERC20 ( self . coins [ i ]) . deposit ( uamount ) amounts [ i ] = yERC20 ( self . coins [ i ]) . balanceOf ( self ) ERC20 ( self . coins [ i ]) . approve ( self . curve , amounts [ i ]) Curve ( self . curve ) . add_liquidity ( amounts , min_mint_amount ) tokens : uint256 = ERC20 ( self . token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( self . token ) . transfer ( msg . sender , tokens )) @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # dev: initial deposit requires all coins # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) if token_supply > 0 : # Only account for fees if we are not the first to deposit _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( new_balances , amp ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if amounts [ i ] > 0 : # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # Mint pool tokens CurveToken ( _lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> todo: DepositZap.remove_liquidity \u00b6 DepositZap.remove_liquidity(_amount: uint256, _min_underlying_amounts: uint256[N_COINS]) -> uint256[N_COINS] Withdraw and unwrap coins from the pool. Returns list of amounts of underlying coins that were withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal _min_underlying_amounts uint256[N_COINS] Minimum amounts of underlying coins to receive Emits: Transfer RemoveLiquidity Source code Zap Contract Methods Pool Methods @internal def _unwrap_and_transfer ( _addr : address , _min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: # unwrap coins and transfer them to the sender use_lending : bool [ N_COINS ] = USE_LENDING _amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue yERC20 ( _coin ) . withdraw ( _balance ) _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= _min_amounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount != 0 : _response : Bytes [ 32 ] = raw_call ( _ucoin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( _addr , bytes32 ), convert ( _uamount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) > 0 : assert convert ( _response , bool ) _amounts [ i ] = _uamount return _amounts @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , _min_underlying_amounts : uint256 [ N_COINS ] ) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param _min_underlying_amounts Minimum amounts of underlying coins to receive @return List of amounts of underlying coins that were withdrawn \"\"\" assert ERC20 ( self . lp_token ) . transferFrom ( msg . sender , self , _amount ) Curve ( self . curve ) . remove_liquidity ( _amount , empty ( uint256 [ N_COINS ])) return self . _unwrap_and_transfer ( msg . sender , _min_underlying_amounts ) @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param min_amounts Minimum amounts of underlying coins to receive @return List of amounts of coins that were withdrawn \"\"\" _lp_token : address = self . lp_token total_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Fees are unused but we've got them historically in event for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( value , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) CurveToken ( _lp_token ) . burnFrom ( msg . sender , _amount ) # dev: insufficient funds log RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) return amounts Example >>> todo: DepositZap.remove_liquidity_imbalance \u00b6 DepositZap.remove_liquidity_imbalance(_underlying_amounts: uint256[N_COINS], _max_burn_amount: uint256) Withdraw and unwrap coins from the pool in an imbalanced amount. Amounts in _underlying_amounts correspond to withdrawn amounts before any fees charge for unwrapping Returns list of amounts of underlying coins that were withdrawn. Input Type Description _underlying_amounts uint256[N_COINS] List of amounts of underlying coins to withdraw _max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods @internal def _unwrap_and_transfer ( _addr : address , _min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: # unwrap coins and transfer them to the sender use_lending : bool [ N_COINS ] = USE_LENDING _amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue yERC20 ( _coin ) . withdraw ( _balance ) _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= _min_amounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount != 0 : _response : Bytes [ 32 ] = raw_call ( _ucoin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( _addr , bytes32 ), convert ( _uamount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) > 0 : assert convert ( _response , bool ) _amounts [ i ] = _uamount return _amounts @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( _underlying_amounts : uint256 [ N_COINS ], _max_burn_amount : uint256 ) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool in an imbalanced amount @dev Amounts in `_underlying_amounts` correspond to withdrawn amounts before any fees charge for unwrapping. @param _underlying_amounts List of amounts of underlying coins to withdraw @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal @return List of amounts of underlying coins that were withdrawn \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING lp_token : address = self . lp_token amounts : uint256 [ N_COINS ] = _underlying_amounts for i in range ( N_COINS ): _amount : uint256 = amounts [ i ] if use_lending [ i ] and _amount > 0 : rate : uint256 = yERC20 ( self . coins [ i ]) . getPricePerFullShare () amounts [ i ] = _amount * LENDING_PRECISION / rate # if not use_lending - all good already # Transfer max tokens in _lp_amount : uint256 = ERC20 ( lp_token ) . balanceOf ( msg . sender ) if _lp_amount > _max_burn_amount : _lp_amount = _max_burn_amount assert ERC20 ( lp_token ) . transferFrom ( msg . sender , self , _lp_amount ) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , _max_burn_amount ) # Transfer unused LP tokens back _lp_amount = ERC20 ( lp_token ) . balanceOf ( self ) if _lp_amount != 0 : assert ERC20 ( lp_token ) . transfer ( msg . sender , _lp_amount ) # Unwrap and transfer all the coins we've got return self . _unwrap_and_transfer ( msg . sender , empty ( uint256 [ N_COINS ])) @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( old_balances , amp ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( new_balances , amp ) _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () assert token_supply != 0 # dev: zero total supply _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( new_balances , amp ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount != 0 # dev: zero tokens burned token_amount += 1 # In case of rounding errors - make it unfavorable for the \"attacker\" assert token_amount <= max_burn_amount , \"Slippage screwed you\" CurveToken ( _lp_token ) . burnFrom ( msg . sender , token_amount ) # dev: insufficient funds for i in range ( N_COINS ): if amounts [ i ] != 0 : _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) return token_amount Example >>> todo: DepositZap.remove_liquidity_one_coin \u00b6 DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False) Withdraw and unwrap a single coin from the pool. Returns amount of underlying coin received. Input Type Description _amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_underlying_amount uint256 Minimum amount of underlying coin to receive Emits: Transfer RemoveLiquidityOne Source code Zap Contract Methods Pool Methods @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _amount : uint256 , i : int128 , _min_underlying_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw and unwrap a single coin from the pool @param _amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_underlying_amount Minimum amount of underlying coin to receive @return Amount of underlying coin received \"\"\" assert ERC20 ( self . lp_token ) . transferFrom ( msg . sender , self , _amount ) Curve ( self . curve ) . remove_liquidity_one_coin ( _amount , i , 0 ) use_lending : bool [ N_COINS ] = USE_LENDING if use_lending [ i ]: coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( coin ) . balanceOf ( self ) yERC20 ( coin ) . withdraw ( _balance ) coin : address = self . underlying_coins [ i ] _balance : uint256 = ERC20 ( coin ) . balanceOf ( self ) assert _balance >= _min_underlying_amount , \"Not enough coins removed\" _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( _balance , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) return _balance @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed dy : uint256 = 0 dy_fee : uint256 = 0 total_supply : uint256 = 0 dy , dy_fee , total_supply = self . _calc_withdraw_one_coin ( _token_amount , i ) assert dy >= _min_amount , \"Not enough coins removed\" self . balances [ i ] -= ( dy + dy_fee * self . admin_fee / FEE_DENOMINATOR ) CurveToken ( self . lp_token ) . burnFrom ( msg . sender , _token_amount ) # dev: insufficient funds _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityOne ( msg . sender , _token_amount , dy , total_supply - _token_amount ) return dy Example >>> todo:","title":"Lending Pool Deposits"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#deposit-zap-old","text":"Older Curve lending pool deposit zaps do not implement the template API . The deposit zaps which employ an older API are: DepositBUSD : BUSD pool deposit zap DepositCompound : Compound pool deposit zap DepositPAX : PAX pool deposit zap DepositUSDT : USDT pool deposit zap DepositY : Y pool deposit zap While not a lending pool, note that the following contract also implements the newer deposit zap API: DepositSUSD : SUSD pool deposit zap Note Getters generated for public arrays changed between Vyper 0.1.x and 0.2.x to accept uint256 instead of int128 in order to handle the lookups. Older deposit zap contracts (v1) use vyper 0.1.x... , while newer zaps (v2) use vyper 0.2.x... . The following Brownie console interaction examples are using the Compound Pool Deposit Zap .","title":"Deposit Zap (Old)"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#get-deposit-zap-information","text":"","title":"Get Deposit Zap Information"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapcurve","text":"DepositZap.curve() \u2192 address: view Getter for the pool associated with this deposit contract. Source code coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.curve () '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56'","title":"DepositZap.curve"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapunderlying_coins","text":"DepositZap.underlying_coins(i: int128) \u2192 address: view Getter for the array of underlying coins within the associated pool. Input Type Description i int128 Index of the underlying coin for which to get the address Source code N_COINS : constant ( int128 ) = 4 ... coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.underlying_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> zap.underlying_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'","title":"DepositZap.underlying_coins"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapcoins","text":"DepositZap.coins(i: int128) \u2192 address: view Getter for the array of wrapped coins within the associated pool. Input Type Description i int128 Index of the coin for which to get the address Source code N_COINS : constant ( int128 ) = 4 ... coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563'","title":"DepositZap.coins"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzaptoken","text":"DepositZap.token() \u2192 address: view Getter for the LP token of the associated pool. Source code coins : public ( address [ N_COINS ]) underlying_coins : public ( address [ N_COINS ]) curve : public ( address ) token : public ( address ) ... @public def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563'","title":"DepositZap.token"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#addremove-liquidity","text":"","title":"Add/Remove Liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapadd_liquidity","text":"DepositZap.add_liquidity(uamounts: uint256[N_COINS], min_mint_amount: uint256) Wrap underlying coins and deposit them in the pool. Input Type Description uamounts uint256[N_COINS] List of amounts of underlying coins to deposit min_mint_amount uint256 Minimum amount of LP token to mint from the deposit Emits: AddLiquidity Transfer Source code Zap Contract Methods Pool Methods Pool Token Methods USE_LENDING : constant ( bool [ N_COINS ]) = [ True , True ] ... @public @nonreentrant ( 'lock' ) def add_liquidity ( uamounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED amounts : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): uamount : uint256 = uamounts [ i ] if uamount > 0 : # Transfer the underlying coin from owner if tethered [ i ]: USDT ( self . underlying_coins [ i ]) . transferFrom ( msg . sender , self , uamount ) else : assert_modifiable ( ERC20 ( self . underlying_coins [ i ]) \\ . transferFrom ( msg . sender , self , uamount )) # Mint if needed if use_lending [ i ]: ERC20 ( self . underlying_coins [ i ]) . approve ( self . coins [ i ], uamount ) ok : uint256 = cERC20 ( self . coins [ i ]) . mint ( uamount ) if ok > 0 : raise \"Could not mint coin\" amounts [ i ] = cERC20 ( self . coins [ i ]) . balanceOf ( self ) ERC20 ( self . coins [ i ]) . approve ( self . curve , amounts [ i ]) else : amounts [ i ] = uamount ERC20 ( self . underlying_coins [ i ]) . approve ( self . curve , uamount ) Curve ( self . curve ) . add_liquidity ( amounts , min_mint_amount ) tokens : uint256 = ERC20 ( self . token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( self . token ) . transfer ( msg . sender , tokens )) @public @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): # Amounts is amounts of c-tokens assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING fees : uint256 [ N_COINS ] = ZEROS _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee token_supply : uint256 = self . token . totalSupply () rates : uint256 [ N_COINS ] = self . _current_rates () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( rates , old_balances ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( rates , new_balances ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 if token_supply > 0 : # Only account for fees if we are not the first to deposit for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( rates , new_balances ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transferFrom ( msg . sender , self , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , amounts [ i ])) # Mint pool tokens self . token . mint ( msg . sender , mint_amount ) log . AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) @public def mint ( _to : address , _value : uint256 ): \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log . Transfer ( ZERO_ADDRESS , _to , _value ) Example >>> todo:","title":"DepositZap.add_liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity","text":"DepositZap.remove_liquidity(_amount: uint256, min_uamounts: uint256[N_COINS]) Withdraw and unwrap coins from the pool. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal min_uamounts uint256[N_COINS] Minimum amounts of underlying coins to receive Emits: Transfer RemoveLiquidity Source code Zap Contract Methods Pool Methods Pool Token Methods @private def _send_all ( _addr : address , min_uamounts : uint256 [ N_COINS ], one : int128 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED for i in range ( N_COINS ): if ( one < 0 ) or ( i == one ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = cERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue ok : uint256 = cERC20 ( _coin ) . redeem ( _balance ) if ok > 0 : raise \"Could not redeem coin\" _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= min_uamounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount >= 0 : if tethered [ i ]: USDT ( _ucoin ) . transfer ( _addr , _uamount ) else : assert_modifiable ( ERC20 ( _ucoin ) . transfer ( _addr , _uamount )) @public @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_uamounts : uint256 [ N_COINS ]): zeros : uint256 [ N_COINS ] = ZEROS assert_modifiable ( ERC20 ( self . token ) . transferFrom ( msg . sender , self , _amount )) Curve ( self . curve ) . remove_liquidity ( _amount , zeros ) self . _send_all ( msg . sender , min_uamounts , - 1 ) @public @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]): total_supply : uint256 = self . token . totalSupply () amounts : uint256 [ N_COINS ] = ZEROS fees : uint256 [ N_COINS ] = ZEROS tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , value ) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , value )) self . token . burnFrom ( msg . sender , _amount ) # Will raise if not enough log . RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Example >>> todo:","title":"DepositZap.remove_liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity_imbalance","text":"DepositZap.remove_liquidity_imbalance(uamounts: uint256[N_COINS], max_burn_amount: uint256) Withdraw and unwrap coins from the pool in an imbalanced amount. Input Type Description uamounts uint256[N_COINS] List of amounts of underlying coins to withdraw max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods Pool Token Methods @private def _send_all ( _addr : address , min_uamounts : uint256 [ N_COINS ], one : int128 ): use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED for i in range ( N_COINS ): if ( one < 0 ) or ( i == one ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = cERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue ok : uint256 = cERC20 ( _coin ) . redeem ( _balance ) if ok > 0 : raise \"Could not redeem coin\" _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= min_uamounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount >= 0 : if tethered [ i ]: USDT ( _ucoin ) . transfer ( _addr , _uamount ) else : assert_modifiable ( ERC20 ( _ucoin ) . transfer ( _addr , _uamount )) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( uamounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): \"\"\" Get max_burn_amount in, remove requested liquidity and transfer back what is left \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING tethered : bool [ N_COINS ] = TETHERED _token : address = self . token amounts : uint256 [ N_COINS ] = uamounts for i in range ( N_COINS ): if use_lending [ i ] and amounts [ i ] > 0 : rate : uint256 = cERC20 ( self . coins [ i ]) . exchangeRateCurrent () amounts [ i ] = amounts [ i ] * LENDING_PRECISION / rate # if not use_lending - all good already # Transfrer max tokens in _tokens : uint256 = ERC20 ( _token ) . balanceOf ( msg . sender ) if _tokens > max_burn_amount : _tokens = max_burn_amount assert_modifiable ( ERC20 ( _token ) . transferFrom ( msg . sender , self , _tokens )) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , max_burn_amount ) # Transfer unused tokens back _tokens = ERC20 ( _token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( _token ) . transfer ( msg . sender , _tokens )) # Unwrap and transfer all the coins we've got self . _send_all ( msg . sender , ZEROS , - 1 ) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING token_supply : uint256 = self . token . totalSupply () assert token_supply > 0 _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee rates : uint256 [ N_COINS ] = self . _current_rates () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( rates , old_balances ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( rates , new_balances ) fees : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( rates , new_balances ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount > 0 assert token_amount <= max_burn_amount , \"Slippage screwed you\" for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ])) self . token . burnFrom ( msg . sender , token_amount ) # Will raise if not enough log . RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Example >>> todo:","title":"DepositZap.remove_liquidity_imbalance"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity_one_coin","text":"DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False) Withdraw and unwrap a single coin from the pool. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw min_uamount uint256 Minimum amount of underlying coin to receive donate_dust bool Donates collected dust liquidity to msg.sender Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods Pool Token Methods @public @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , min_uamount : uint256 , donate_dust : bool = False ): \"\"\" Remove _amount of liquidity all in a form of coin i \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING rates : uint256 [ N_COINS ] = ZEROS _token : address = self . token for j in range ( N_COINS ): if use_lending [ j ]: rates [ j ] = cERC20 ( self . coins [ j ]) . exchangeRateCurrent () else : rates [ j ] = LENDING_PRECISION dy : uint256 = self . _calc_withdraw_one_coin ( _token_amount , i , rates ) assert dy >= min_uamount , \"Not enough coins removed\" assert_modifiable ( ERC20 ( self . token ) . transferFrom ( msg . sender , self , _token_amount )) amounts : uint256 [ N_COINS ] = ZEROS amounts [ i ] = dy * LENDING_PRECISION / rates [ i ] token_amount_before : uint256 = ERC20 ( _token ) . balanceOf ( self ) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , _token_amount ) # Unwrap and transfer all the coins we've got self . _send_all ( msg . sender , ZEROS , i ) if not donate_dust : # Transfer unused tokens back token_amount_after : uint256 = ERC20 ( _token ) . balanceOf ( self ) if token_amount_after > token_amount_before : assert_modifiable ( ERC20 ( _token ) . transfer ( msg . sender , token_amount_after - token_amount_before ) ) @public @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ): assert not self . is_killed tethered : bool [ N_COINS ] = TETHERED use_lending : bool [ N_COINS ] = USE_LENDING token_supply : uint256 = self . token . totalSupply () assert token_supply > 0 _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee rates : uint256 [ N_COINS ] = self . _current_rates () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( rates , old_balances ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( rates , new_balances ) fees : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( rates , new_balances ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount > 0 assert token_amount <= max_burn_amount , \"Slippage screwed you\" for i in range ( N_COINS ): if tethered [ i ] and not use_lending [ i ]: USDT ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ]) else : assert_modifiable ( cERC20 ( self . coins [ i ]) . transfer ( msg . sender , amounts [ i ])) self . token . burnFrom ( msg . sender , token_amount ) # Will raise if not enough log . RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) ... @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) Note The underlying pool method called when the older DepositZap contract's remove_liquidity_one_coin is called emits RemoveLiquidityImbalance whereas the newer contract emits RemoveLiquidityOne . This is because the older contracts do not have the remove_liquidity_one_coin , and instead use remove_liquidity_imbalance . Example >>> todo:","title":"DepositZap.remove_liquidity_one_coin"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapcalc_withdraw_one_coin","text":"DepositZap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing a single underlying coin. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw Source code @private @constant def _calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 , rates : uint256 [ N_COINS ]) -> uint256 : # First, need to calculate # * Get current D # * Solve Eqn against y_i for D - _token_amount use_lending : bool [ N_COINS ] = USE_LENDING # tethered: bool[N_COINS] = TETHERED crv : address = self . curve A : uint256 = Curve ( crv ) . A () fee : uint256 = Curve ( crv ) . fee () * N_COINS / ( 4 * ( N_COINS - 1 )) fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR # Overcharge to account for imprecision precisions : uint256 [ N_COINS ] = PRECISION_MUL total_supply : uint256 = ERC20 ( self . token ) . totalSupply () xp : uint256 [ N_COINS ] = PRECISION_MUL S : uint256 = 0 for j in range ( N_COINS ): xp [ j ] *= Curve ( crv ) . balances ( j ) if use_lending [ j ]: # Use stored rate b/c we have imprecision anyway xp [ j ] = xp [ j ] * rates [ j ] / LENDING_PRECISION S += xp [ j ] # if not use_lending - all good already D0 : uint256 = self . get_D ( A , xp ) D1 : uint256 = D0 - _token_amount * D0 / total_supply xp_reduced : uint256 [ N_COINS ] = xp # xp = xp - fee * | xp * D1 / D0 - (xp - S * dD / D0 * (0, ... 1, ..0))| for j in range ( N_COINS ): dx_expected : uint256 = 0 b_ideal : uint256 = xp [ j ] * D1 / D0 b_expected : uint256 = xp [ j ] if j == i : b_expected -= S * ( D0 - D1 ) / D0 if b_ideal >= b_expected : dx_expected = ( b_ideal - b_expected ) else : dx_expected = ( b_expected - b_ideal ) xp_reduced [ j ] -= fee * dx_expected / FEE_DENOMINATOR dy : uint256 = xp_reduced [ i ] - self . get_y ( A , i , xp_reduced , D1 ) dy = dy / precisions [ i ] return dy @public @constant def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : rates : uint256 [ N_COINS ] = ZEROS use_lending : bool [ N_COINS ] = USE_LENDING for j in range ( N_COINS ): if use_lending [ j ]: rates [ j ] = cERC20 ( self . coins [ j ]) . exchangeRateStored () else : rates [ j ] = 10 ** 18 return self . _calc_withdraw_one_coin ( _token_amount , i , rates ) Example >>> todo:","title":"DepositZap.calc_withdraw_one_coin"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapwithdraw_donated_dust","text":"DepositZap.withdraw_donated_dust() Donates any LP tokens of the associated pool held by this contract to the contract owner. Source code @public @nonreentrant ( 'lock' ) def withdraw_donated_dust (): owner : address = Curve ( self . curve ) . owner () assert msg . sender == owner _token : address = self . token assert_modifiable ( ERC20 ( _token ) . transfer ( owner , ERC20 ( _token ) . balanceOf ( self ))) Example >>> todo:","title":"DepositZap.withdraw_donated_dust"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#deposit-zap-new","text":"Compared to the older deposit zaps, the newer zaps mainly optimize for gas efficiency. The API is only modified in part, specifically with regards to return values and variable naming.","title":"Deposit Zap (New)"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#get-deposit-zap-information_1","text":"","title":"Get Deposit Zap Information"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapcurve_1","text":"DepositZap.curve() \u2192 address: view Getter for the pool associated with this deposit contract. Source code @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.curve () '0xA2B47E3D5c44877cca798226B7B8118F9BFb7A56'","title":"DepositZap.curve"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapunderlying_coins_1","text":"DepositZap.underlying_coins(i: int128) \u2192 address: view Getter for the array of underlying coins within the associated pool. Input Type Description i int128 Index of the underlying coin for which to get the address Source code underlying_coins : public ( address [ N_COINS ]) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.underlying_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> zap.underlying_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'","title":"DepositZap.underlying_coins"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapcoins_1","text":"DepositZap.coins(i: int128) \u2192 address: view Getter for the array of wrapped coins within the associated pool. Input Type Description i int128 Index of the coin for which to get the address Source code coins : public ( address [ N_COINS ]) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563'","title":"DepositZap.coins"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzaptoken_1","text":"DepositZap.token() \u2192 address: view Getter for the LP token of the associated pool. Source code lp_token : public ( address ) ... @external def __init__ ( _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _curve : address , _token : address ): \"\"\" @notice Contract constructor @dev Where a token does not use wrapping, use the same address for `_coins` and `_underlying_coins` @param _coins List of wrapped coin addresses @param _underlying_coins List of underlying coin addresses @param _curve Pool address @param _token Pool LP token address \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying and wrapped coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( _coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _curve , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . curve = _curve self . lp_token = _token Example >>> zap.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> zap.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563'","title":"DepositZap.token"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#addremove-liquidity_1","text":"","title":"Add/Remove Liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapadd_liquidity_1","text":"DepositZap.add_liquidity(_underlying_amounts: uint256[N_COINS], _min_mint_amount: uint256) -> uint256 Wrap underlying coins and deposit them in the pool. Returns the amount of LP token received in exchange for the deposited amounts. Input Type Description _underlying_amounts uint256[N_COINS] List of amounts of underlying coins to deposit _min_mint_amount uint256 Minimum amount of LP token to mint from the deposit Emits: Transfer AddLiquidity Source code Zap Contract Methods Pool Methods @public @nonreentrant ( 'lock' ) def add_liquidity ( uamounts : uint256 [ N_COINS ], min_mint_amount : uint256 ): tethered : bool [ N_COINS ] = TETHERED amounts : uint256 [ N_COINS ] = ZEROS for i in range ( N_COINS ): uamount : uint256 = uamounts [ i ] if uamount > 0 : # Transfer the underlying coin from owner if tethered [ i ]: USDT ( self . underlying_coins [ i ]) . transferFrom ( msg . sender , self , uamount ) else : assert_modifiable ( ERC20 ( self . underlying_coins [ i ]) \\ . transferFrom ( msg . sender , self , uamount )) # Mint if needed ERC20 ( self . underlying_coins [ i ]) . approve ( self . coins [ i ], uamount ) yERC20 ( self . coins [ i ]) . deposit ( uamount ) amounts [ i ] = yERC20 ( self . coins [ i ]) . balanceOf ( self ) ERC20 ( self . coins [ i ]) . approve ( self . curve , amounts [ i ]) Curve ( self . curve ) . add_liquidity ( amounts , min_mint_amount ) tokens : uint256 = ERC20 ( self . token ) . balanceOf ( self ) assert_modifiable ( ERC20 ( self . token ) . transfer ( msg . sender , tokens )) @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # dev: initial deposit requires all coins # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) if token_supply > 0 : # Only account for fees if we are not the first to deposit _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( new_balances , amp ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if amounts [ i ] > 0 : # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # Mint pool tokens CurveToken ( _lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> todo:","title":"DepositZap.add_liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity_1","text":"DepositZap.remove_liquidity(_amount: uint256, _min_underlying_amounts: uint256[N_COINS]) -> uint256[N_COINS] Withdraw and unwrap coins from the pool. Returns list of amounts of underlying coins that were withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal _min_underlying_amounts uint256[N_COINS] Minimum amounts of underlying coins to receive Emits: Transfer RemoveLiquidity Source code Zap Contract Methods Pool Methods @internal def _unwrap_and_transfer ( _addr : address , _min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: # unwrap coins and transfer them to the sender use_lending : bool [ N_COINS ] = USE_LENDING _amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue yERC20 ( _coin ) . withdraw ( _balance ) _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= _min_amounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount != 0 : _response : Bytes [ 32 ] = raw_call ( _ucoin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( _addr , bytes32 ), convert ( _uamount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) > 0 : assert convert ( _response , bool ) _amounts [ i ] = _uamount return _amounts @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , _min_underlying_amounts : uint256 [ N_COINS ] ) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param _min_underlying_amounts Minimum amounts of underlying coins to receive @return List of amounts of underlying coins that were withdrawn \"\"\" assert ERC20 ( self . lp_token ) . transferFrom ( msg . sender , self , _amount ) Curve ( self . curve ) . remove_liquidity ( _amount , empty ( uint256 [ N_COINS ])) return self . _unwrap_and_transfer ( msg . sender , _min_underlying_amounts ) @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param min_amounts Minimum amounts of underlying coins to receive @return List of amounts of coins that were withdrawn \"\"\" _lp_token : address = self . lp_token total_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Fees are unused but we've got them historically in event for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( value , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) CurveToken ( _lp_token ) . burnFrom ( msg . sender , _amount ) # dev: insufficient funds log RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) return amounts Example >>> todo:","title":"DepositZap.remove_liquidity"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity_imbalance_1","text":"DepositZap.remove_liquidity_imbalance(_underlying_amounts: uint256[N_COINS], _max_burn_amount: uint256) Withdraw and unwrap coins from the pool in an imbalanced amount. Amounts in _underlying_amounts correspond to withdrawn amounts before any fees charge for unwrapping Returns list of amounts of underlying coins that were withdrawn. Input Type Description _underlying_amounts uint256[N_COINS] List of amounts of underlying coins to withdraw _max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: Transfer RemoveLiquidityImbalance Source code Zap Contract Methods Pool Methods @internal def _unwrap_and_transfer ( _addr : address , _min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: # unwrap coins and transfer them to the sender use_lending : bool [ N_COINS ] = USE_LENDING _amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): if use_lending [ i ]: _coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( _coin ) . balanceOf ( self ) if _balance == 0 : # Do nothing if there are 0 coins continue yERC20 ( _coin ) . withdraw ( _balance ) _ucoin : address = self . underlying_coins [ i ] _uamount : uint256 = ERC20 ( _ucoin ) . balanceOf ( self ) assert _uamount >= _min_amounts [ i ], \"Not enough coins withdrawn\" # Send only if we have something to send if _uamount != 0 : _response : Bytes [ 32 ] = raw_call ( _ucoin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( _addr , bytes32 ), convert ( _uamount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) > 0 : assert convert ( _response , bool ) _amounts [ i ] = _uamount return _amounts @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( _underlying_amounts : uint256 [ N_COINS ], _max_burn_amount : uint256 ) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool in an imbalanced amount @dev Amounts in `_underlying_amounts` correspond to withdrawn amounts before any fees charge for unwrapping. @param _underlying_amounts List of amounts of underlying coins to withdraw @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal @return List of amounts of underlying coins that were withdrawn \"\"\" use_lending : bool [ N_COINS ] = USE_LENDING lp_token : address = self . lp_token amounts : uint256 [ N_COINS ] = _underlying_amounts for i in range ( N_COINS ): _amount : uint256 = amounts [ i ] if use_lending [ i ] and _amount > 0 : rate : uint256 = yERC20 ( self . coins [ i ]) . getPricePerFullShare () amounts [ i ] = _amount * LENDING_PRECISION / rate # if not use_lending - all good already # Transfer max tokens in _lp_amount : uint256 = ERC20 ( lp_token ) . balanceOf ( msg . sender ) if _lp_amount > _max_burn_amount : _lp_amount = _max_burn_amount assert ERC20 ( lp_token ) . transferFrom ( msg . sender , self , _lp_amount ) Curve ( self . curve ) . remove_liquidity_imbalance ( amounts , _max_burn_amount ) # Transfer unused LP tokens back _lp_amount = ERC20 ( lp_token ) . balanceOf ( self ) if _lp_amount != 0 : assert ERC20 ( lp_token ) . transfer ( msg . sender , _lp_amount ) # Unwrap and transfer all the coins we've got return self . _unwrap_and_transfer ( msg . sender , empty ( uint256 [ N_COINS ])) @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( old_balances , amp ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( new_balances , amp ) _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () assert token_supply != 0 # dev: zero total supply _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( new_balances , amp ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount != 0 # dev: zero tokens burned token_amount += 1 # In case of rounding errors - make it unfavorable for the \"attacker\" assert token_amount <= max_burn_amount , \"Slippage screwed you\" CurveToken ( _lp_token ) . burnFrom ( msg . sender , token_amount ) # dev: insufficient funds for i in range ( N_COINS ): if amounts [ i ] != 0 : _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) return token_amount Example >>> todo:","title":"DepositZap.remove_liquidity_imbalance"},{"location":"stableswap_exchange/deposit_contracts/lending_pool_deposits/#depositzapremove_liquidity_one_coin_1","text":"DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, min_uamount: uint256, donate_dust: bool = False) Withdraw and unwrap a single coin from the pool. Returns amount of underlying coin received. Input Type Description _amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_underlying_amount uint256 Minimum amount of underlying coin to receive Emits: Transfer RemoveLiquidityOne Source code Zap Contract Methods Pool Methods @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _amount : uint256 , i : int128 , _min_underlying_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw and unwrap a single coin from the pool @param _amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_underlying_amount Minimum amount of underlying coin to receive @return Amount of underlying coin received \"\"\" assert ERC20 ( self . lp_token ) . transferFrom ( msg . sender , self , _amount ) Curve ( self . curve ) . remove_liquidity_one_coin ( _amount , i , 0 ) use_lending : bool [ N_COINS ] = USE_LENDING if use_lending [ i ]: coin : address = self . coins [ i ] _balance : uint256 = ERC20 ( coin ) . balanceOf ( self ) yERC20 ( coin ) . withdraw ( _balance ) coin : address = self . underlying_coins [ i ] _balance : uint256 = ERC20 ( coin ) . balanceOf ( self ) assert _balance >= _min_underlying_amount , \"Not enough coins removed\" _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( _balance , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) return _balance @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed dy : uint256 = 0 dy_fee : uint256 = 0 total_supply : uint256 = 0 dy , dy_fee , total_supply = self . _calc_withdraw_one_coin ( _token_amount , i ) assert dy >= _min_amount , \"Not enough coins removed\" self . balances [ i ] -= ( dy + dy_fee * self . admin_fee / FEE_DENOMINATOR ) CurveToken ( self . lp_token ) . burnFrom ( msg . sender , _token_amount ) # dev: insufficient funds _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityOne ( msg . sender , _token_amount , dy , total_supply - _token_amount ) return dy Example >>> todo:","title":"DepositZap.remove_liquidity_one_coin"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/","text":"While Curve metapools support swaps between base pool coins, the base pool LP token and metapool coins, they do not allow liquidity providers to deposit and/or withdraw base pool coins. For example, the GUSD metapool is a pool consisting of GUSD and 3CRV (the LP token of the 3Pool ) and allows for swaps between GUSD , DAI , USDC , USDT and 3CRV . However, liquidity providers are not able to deposit DAI , USDC or USDT to the pool directly. The main reason why this is not possible lies in the maximum byte code size of contracts. Metapools are complex and can therefore end up being very close to the contract byte code size limit. In order to overcome this restriction, liquidity can be added and removed to and from a metapool in the base pool\u2019s coins through a metapool deposit zap. The template source code for a metapool deposit \u201czap\u201d may be viewed on GitHub . Note Metapool deposit zaps contain the following private and hardcoded constants: N_COINS : Number of coins in the metapool (excluding base pool coins) BASE_N_COINS : Number of coins in the base pool N_ALL_COINS : All coins in the metapool, excluding the base pool LP token ( N_COINS + BASE_N_COINS - 1 ) Get Deposit Zap Information \u00b6 DepositZap.pool \u00b6 DepositZap.pool() \u2192 address: view Getter for the metapool associated with this deposit contract. Source code pool : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool ... Example >>> todo: DepositZap.base_pool \u00b6 DepositZap.base_pool() \u2192 address: view Getter for the base pool of the metapool associated with this deposit contract. Source code base_pool : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token base_pool : address = CurveMeta ( _pool ) . base_pool () self . base_pool = base_pool ... Example >>> todo: DepositZap.base_coins \u00b6 DepositZap.base_coins(i: uint256) \u2192 address: view Getter for the array of the coins of the metapool\u2019s base pool. Input Type Description i int128 Index of the coin for which to get the address Source code base_coins : public ( address [ BASE_N_COINS ]) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token base_pool : address = CurveMeta ( _pool ) . base_pool () self . base_pool = base_pool for i in range ( N_COINS ): coin : address = CurveMeta ( _pool ) . coins ( i ) self . coins [ i ] = coin # approve coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) for i in range ( BASE_N_COINS ): coin : address = CurveBase ( base_pool ) . coins ( i ) self . base_coins [ i ] = coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) ... Example >>> todo: DepositZap.token \u00b6 DepositZap.token() \u2192 address: view Getter for the LP token of the associated metapool. Source code token : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token ... Example >>> todo: Add/Remove Liquidity \u00b6 Note For methods taking the index argument i , a number in the range from 0 to N_ALL_COINS - 1 is valid. This refers to all coins apart from the base pool LP token. DepositZap.add_liquidity \u00b6 DepositZap.add_liquidity(_amounts: uint256[N_ALL_COINS], _min_mint_amount: uint256) \u2192 uint256 Wrap underlying coins and deposit them in the pool. Returns the amount of LP token received in exchange for depositing. Input Type Description _amounts uint256[N_ALL_COINS] List of amounts of underlying coins to deposit _min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit Emits: AddLiquidity Transfer Source code @external def add_liquidity ( _amounts : uint256 [ N_ALL_COINS ], _min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Wrap underlying coins and deposit them in the pool @param _amounts List of amounts of underlying coins to deposit @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" meta_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) base_amounts : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) deposit_base : bool = False # Transfer all coins in for i in range ( N_ALL_COINS ): amount : uint256 = _amounts [ i ] if amount == 0 : continue coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] meta_amounts [ i ] = amount else : x : int128 = i - MAX_COIN coin = self . base_coins [ x ] base_amounts [ x ] = amount deposit_base = True # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransferFrom\" # Handle potential Tether fees if coin == FEE_ASSET : amount = ERC20 ( FEE_ASSET ) . balanceOf ( self ) if i < MAX_COIN : meta_amounts [ i ] = amount else : base_amounts [ i - MAX_COIN ] = amount # Deposit to the base pool if deposit_base : CurveBase ( self . base_pool ) . add_liquidity ( base_amounts , 0 ) meta_amounts [ MAX_COIN ] = ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ) # Deposit to the meta pool CurveMeta ( self . pool ) . add_liquidity ( meta_amounts , _min_mint_amount ) # Transfer meta token back lp_token : address = self . token lp_amount : uint256 = ERC20 ( lp_token ) . balanceOf ( self ) assert ERC20 ( lp_token ) . transfer ( msg . sender , lp_amount ) return lp_amount Example DepositZap.remove_liquidity \u00b6 DepositZap.remove_liquidity(_amount: uint256, _min_amounts: uint256[N_ALL_COINS]) \u2192 uint256[N_ALL_COINS] Withdraw and unwrap coins from the pool. Returns a list of amounts ( uint256[N_ALL_COINS] ) of underlying coins that were withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal _min_amounts uint256[N_ALL_COINS] Minimum amounts of underlying coins to receive Emits: RemoveLiquidity Transfer Source code @external def remove_liquidity ( _amount : uint256 , _min_amounts : uint256 [ N_ALL_COINS ]) -> uint256 [ N_ALL_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param _min_amounts Minimum amounts of underlying coins to receive @return List of amounts of underlying coins that were withdrawn \"\"\" _token : address = self . token assert ERC20 ( _token ) . transferFrom ( msg . sender , self , _amount ) min_amounts_meta : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) min_amounts_base : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) amounts : uint256 [ N_ALL_COINS ] = empty ( uint256 [ N_ALL_COINS ]) # Withdraw from meta for i in range ( MAX_COIN ): min_amounts_meta [ i ] = _min_amounts [ i ] CurveMeta ( self . pool ) . remove_liquidity ( _amount , min_amounts_meta ) # Withdraw from base _base_amount : uint256 = ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ) for i in range ( BASE_N_COINS ): min_amounts_base [ i ] = _min_amounts [ MAX_COIN + i ] CurveBase ( self . base_pool ) . remove_liquidity ( _base_amount , min_amounts_base ) # Transfer all coins out for i in range ( N_ALL_COINS ): coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] else : coin = self . base_coins [ i - MAX_COIN ] amounts [ i ] = ERC20 ( coin ) . balanceOf ( self ) # \"safeTransfer\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" return amounts Example >>> todo: DepositZap.remove_liquidity_one_coin \u00b6 DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) \u2192 uint256 Withdraw and unwrap a single coin from the metapool. Returns the amount of the underlying coin received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_amount uint256 Minimum amount of underlying coin to receive Emits: RemoveLiquidityOne Transfer Source code @external def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw and unwrap a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of underlying coin to receive @return Amount of underlying coin received \"\"\" assert ERC20 ( self . token ) . transferFrom ( msg . sender , self , _token_amount ) coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] # Withdraw a metapool coin CurveMeta ( self . pool ) . remove_liquidity_one_coin ( _token_amount , i , _min_amount ) else : coin = self . base_coins [ i - MAX_COIN ] # Withdraw a base pool coin CurveMeta ( self . pool ) . remove_liquidity_one_coin ( _token_amount , MAX_COIN , 0 ) CurveBase ( self . base_pool ) . remove_liquidity_one_coin ( ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ), i - MAX_COIN , _min_amount ) # Tranfer the coin out coin_amount : uint256 = ERC20 ( coin ) . balanceOf ( self ) # \"safeTransfer\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( coin_amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" return coin_amount Example >>> todo: DepositZap.remove_liquidity_imbalance \u00b6 DepositZap.remove_liquidity_imbalance(_amounts: uint256[N_ALL_COINS], _max_burn_amount: uint256) \u2192 uint256 Withdraw coins from the pool in an imbalanced amount. Returns the actual amount of the LP token burned in the withdrawal. Input Type Description _amounts uint256[N_ALL_COINS] List of amounts of underlying coins to withdraw _max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: RemoveLiquidityImbalance Transfer Source code @external def remove_liquidity_imbalance ( _amounts : uint256 [ N_ALL_COINS ], _max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param _amounts List of amounts of underlying coins to withdraw @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" base_pool : address = self . base_pool meta_pool : address = self . pool base_coins : address [ BASE_N_COINS ] = self . base_coins meta_coins : address [ N_COINS ] = self . coins lp_token : address = self . token fee : uint256 = CurveBase ( base_pool ) . fee () * BASE_N_COINS / ( 4 * ( BASE_N_COINS - 1 )) fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR # Overcharge to account for imprecision # Transfer the LP token in assert ERC20 ( lp_token ) . transferFrom ( msg . sender , self , _max_burn_amount ) withdraw_base : bool = False amounts_base : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) amounts_meta : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) leftover_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Prepare quantities for i in range ( MAX_COIN ): amounts_meta [ i ] = _amounts [ i ] for i in range ( BASE_N_COINS ): amount : uint256 = _amounts [ MAX_COIN + i ] if amount != 0 : amounts_base [ i ] = amount withdraw_base = True if withdraw_base : amounts_meta [ MAX_COIN ] = CurveBase ( self . base_pool ) . calc_token_amount ( amounts_base , False ) amounts_meta [ MAX_COIN ] += amounts_meta [ MAX_COIN ] * fee / FEE_DENOMINATOR + 1 # Remove liquidity and deposit leftovers back CurveMeta ( meta_pool ) . remove_liquidity_imbalance ( amounts_meta , _max_burn_amount ) if withdraw_base : CurveBase ( base_pool ) . remove_liquidity_imbalance ( amounts_base , amounts_meta [ MAX_COIN ]) leftover_amounts [ MAX_COIN ] = ERC20 ( meta_coins [ MAX_COIN ]) . balanceOf ( self ) if leftover_amounts [ MAX_COIN ] > 0 : CurveMeta ( meta_pool ) . add_liquidity ( leftover_amounts , 0 ) # Transfer all coins out for i in range ( N_ALL_COINS ): coin : address = ZERO_ADDRESS amount : uint256 = 0 if i < MAX_COIN : coin = meta_coins [ i ] amount = amounts_meta [ i ] else : coin = base_coins [ i - MAX_COIN ] amount = amounts_base [ i - MAX_COIN ] # \"safeTransfer\" which works for ERC20s which return bool or not if amount > 0 : _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" # Transfer the leftover LP token out leftover : uint256 = ERC20 ( lp_token ) . balanceOf ( self ) if leftover > 0 : assert ERC20 ( lp_token ) . transfer ( msg . sender , leftover ) return _max_burn_amount - leftover Example >>> todo: DepositZap.calc_withdraw_one_coin \u00b6 DepositZap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing and unwrapping a single coin. Returns the amount of coin i received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw ( i should be in the range from 0 to N_ALL_COINS - 1 , where the LP token of the base pool is removed). Source code @view @external def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : \"\"\" @notice Calculate the amount received when withdrawing and unwrapping a single coin @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the underlying coin to withdraw @return Amount of coin received \"\"\" if i < MAX_COIN : return CurveMeta ( self . pool ) . calc_withdraw_one_coin ( _token_amount , i ) else : base_tokens : uint256 = CurveMeta ( self . pool ) . calc_withdraw_one_coin ( _token_amount , MAX_COIN ) return CurveBase ( self . base_pool ) . calc_withdraw_one_coin ( base_tokens , i - MAX_COIN ) Example >>> todo: DepositZap.calc_token_amount \u00b6 DepositZap.calc_token_amount(_amounts: uint256[N_ALL_COINS], _is_deposit: bool) \u2192 uint256 Calculate addition or reduction in token supply from a deposit or withdrawal. Returns the expected amount of LP tokens received. Input Type Description _amounts uint256[N_ALL_COINS] Amount of each underlying coin being deposited _is_deposit bool Set True for deposits, False for withdrawals Source code @view @external def calc_token_amount ( _amounts : uint256 [ N_ALL_COINS ], _is_deposit : bool ) -> uint256 : \"\"\" @notice Calculate addition or reduction in token supply from a deposit or withdrawal @dev This calculation accounts for slippage, but not fees. Needed to prevent front-running, not for precise calculations! @param _amounts Amount of each underlying coin being deposited @param _is_deposit set True for deposits, False for withdrawals @return Expected amount of LP tokens received \"\"\" meta_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) base_amounts : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) for i in range ( MAX_COIN ): meta_amounts [ i ] = _amounts [ i ] for i in range ( BASE_N_COINS ): base_amounts [ i ] = _amounts [ i + MAX_COIN ] base_tokens : uint256 = CurveBase ( self . base_pool ) . calc_token_amount ( base_amounts , _is_deposit ) meta_amounts [ MAX_COIN ] = base_tokens return CurveMeta ( self . pool ) . calc_token_amount ( meta_amounts , _is_deposit ) Example >>> todo:","title":"Metapool Deposits"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#get-deposit-zap-information","text":"","title":"Get Deposit Zap Information"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzappool","text":"DepositZap.pool() \u2192 address: view Getter for the metapool associated with this deposit contract. Source code pool : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool ... Example >>> todo:","title":"DepositZap.pool"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapbase_pool","text":"DepositZap.base_pool() \u2192 address: view Getter for the base pool of the metapool associated with this deposit contract. Source code base_pool : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token base_pool : address = CurveMeta ( _pool ) . base_pool () self . base_pool = base_pool ... Example >>> todo:","title":"DepositZap.base_pool"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapbase_coins","text":"DepositZap.base_coins(i: uint256) \u2192 address: view Getter for the array of the coins of the metapool\u2019s base pool. Input Type Description i int128 Index of the coin for which to get the address Source code base_coins : public ( address [ BASE_N_COINS ]) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token base_pool : address = CurveMeta ( _pool ) . base_pool () self . base_pool = base_pool for i in range ( N_COINS ): coin : address = CurveMeta ( _pool ) . coins ( i ) self . coins [ i ] = coin # approve coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) for i in range ( BASE_N_COINS ): coin : address = CurveBase ( base_pool ) . coins ( i ) self . base_coins [ i ] = coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) ... Example >>> todo:","title":"DepositZap.base_coins"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzaptoken","text":"DepositZap.token() \u2192 address: view Getter for the LP token of the associated metapool. Source code token : public ( address ) ... @external def __init__ ( _pool : address , _token : address ): \"\"\" @notice Contract constructor @param _pool Metapool address @param _token Pool LP token address \"\"\" self . pool = _pool self . token = _token ... Example >>> todo:","title":"DepositZap.token"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#addremove-liquidity","text":"Note For methods taking the index argument i , a number in the range from 0 to N_ALL_COINS - 1 is valid. This refers to all coins apart from the base pool LP token.","title":"Add/Remove Liquidity"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapadd_liquidity","text":"DepositZap.add_liquidity(_amounts: uint256[N_ALL_COINS], _min_mint_amount: uint256) \u2192 uint256 Wrap underlying coins and deposit them in the pool. Returns the amount of LP token received in exchange for depositing. Input Type Description _amounts uint256[N_ALL_COINS] List of amounts of underlying coins to deposit _min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit Emits: AddLiquidity Transfer Source code @external def add_liquidity ( _amounts : uint256 [ N_ALL_COINS ], _min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Wrap underlying coins and deposit them in the pool @param _amounts List of amounts of underlying coins to deposit @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" meta_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) base_amounts : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) deposit_base : bool = False # Transfer all coins in for i in range ( N_ALL_COINS ): amount : uint256 = _amounts [ i ] if amount == 0 : continue coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] meta_amounts [ i ] = amount else : x : int128 = i - MAX_COIN coin = self . base_coins [ x ] base_amounts [ x ] = amount deposit_base = True # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransferFrom\" # Handle potential Tether fees if coin == FEE_ASSET : amount = ERC20 ( FEE_ASSET ) . balanceOf ( self ) if i < MAX_COIN : meta_amounts [ i ] = amount else : base_amounts [ i - MAX_COIN ] = amount # Deposit to the base pool if deposit_base : CurveBase ( self . base_pool ) . add_liquidity ( base_amounts , 0 ) meta_amounts [ MAX_COIN ] = ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ) # Deposit to the meta pool CurveMeta ( self . pool ) . add_liquidity ( meta_amounts , _min_mint_amount ) # Transfer meta token back lp_token : address = self . token lp_amount : uint256 = ERC20 ( lp_token ) . balanceOf ( self ) assert ERC20 ( lp_token ) . transfer ( msg . sender , lp_amount ) return lp_amount Example","title":"DepositZap.add_liquidity"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapremove_liquidity","text":"DepositZap.remove_liquidity(_amount: uint256, _min_amounts: uint256[N_ALL_COINS]) \u2192 uint256[N_ALL_COINS] Withdraw and unwrap coins from the pool. Returns a list of amounts ( uint256[N_ALL_COINS] ) of underlying coins that were withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal _min_amounts uint256[N_ALL_COINS] Minimum amounts of underlying coins to receive Emits: RemoveLiquidity Transfer Source code @external def remove_liquidity ( _amount : uint256 , _min_amounts : uint256 [ N_ALL_COINS ]) -> uint256 [ N_ALL_COINS ]: \"\"\" @notice Withdraw and unwrap coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param _min_amounts Minimum amounts of underlying coins to receive @return List of amounts of underlying coins that were withdrawn \"\"\" _token : address = self . token assert ERC20 ( _token ) . transferFrom ( msg . sender , self , _amount ) min_amounts_meta : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) min_amounts_base : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) amounts : uint256 [ N_ALL_COINS ] = empty ( uint256 [ N_ALL_COINS ]) # Withdraw from meta for i in range ( MAX_COIN ): min_amounts_meta [ i ] = _min_amounts [ i ] CurveMeta ( self . pool ) . remove_liquidity ( _amount , min_amounts_meta ) # Withdraw from base _base_amount : uint256 = ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ) for i in range ( BASE_N_COINS ): min_amounts_base [ i ] = _min_amounts [ MAX_COIN + i ] CurveBase ( self . base_pool ) . remove_liquidity ( _base_amount , min_amounts_base ) # Transfer all coins out for i in range ( N_ALL_COINS ): coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] else : coin = self . base_coins [ i - MAX_COIN ] amounts [ i ] = ERC20 ( coin ) . balanceOf ( self ) # \"safeTransfer\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" return amounts Example >>> todo:","title":"DepositZap.remove_liquidity"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapremove_liquidity_one_coin","text":"DepositZap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) \u2192 uint256 Withdraw and unwrap a single coin from the metapool. Returns the amount of the underlying coin received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_amount uint256 Minimum amount of underlying coin to receive Emits: RemoveLiquidityOne Transfer Source code @external def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw and unwrap a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of underlying coin to receive @return Amount of underlying coin received \"\"\" assert ERC20 ( self . token ) . transferFrom ( msg . sender , self , _token_amount ) coin : address = ZERO_ADDRESS if i < MAX_COIN : coin = self . coins [ i ] # Withdraw a metapool coin CurveMeta ( self . pool ) . remove_liquidity_one_coin ( _token_amount , i , _min_amount ) else : coin = self . base_coins [ i - MAX_COIN ] # Withdraw a base pool coin CurveMeta ( self . pool ) . remove_liquidity_one_coin ( _token_amount , MAX_COIN , 0 ) CurveBase ( self . base_pool ) . remove_liquidity_one_coin ( ERC20 ( self . coins [ MAX_COIN ]) . balanceOf ( self ), i - MAX_COIN , _min_amount ) # Tranfer the coin out coin_amount : uint256 = ERC20 ( coin ) . balanceOf ( self ) # \"safeTransfer\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( coin_amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" return coin_amount Example >>> todo:","title":"DepositZap.remove_liquidity_one_coin"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapremove_liquidity_imbalance","text":"DepositZap.remove_liquidity_imbalance(_amounts: uint256[N_ALL_COINS], _max_burn_amount: uint256) \u2192 uint256 Withdraw coins from the pool in an imbalanced amount. Returns the actual amount of the LP token burned in the withdrawal. Input Type Description _amounts uint256[N_ALL_COINS] List of amounts of underlying coins to withdraw _max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: RemoveLiquidityImbalance Transfer Source code @external def remove_liquidity_imbalance ( _amounts : uint256 [ N_ALL_COINS ], _max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param _amounts List of amounts of underlying coins to withdraw @param _max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" base_pool : address = self . base_pool meta_pool : address = self . pool base_coins : address [ BASE_N_COINS ] = self . base_coins meta_coins : address [ N_COINS ] = self . coins lp_token : address = self . token fee : uint256 = CurveBase ( base_pool ) . fee () * BASE_N_COINS / ( 4 * ( BASE_N_COINS - 1 )) fee += fee * FEE_IMPRECISION / FEE_DENOMINATOR # Overcharge to account for imprecision # Transfer the LP token in assert ERC20 ( lp_token ) . transferFrom ( msg . sender , self , _max_burn_amount ) withdraw_base : bool = False amounts_base : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) amounts_meta : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) leftover_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Prepare quantities for i in range ( MAX_COIN ): amounts_meta [ i ] = _amounts [ i ] for i in range ( BASE_N_COINS ): amount : uint256 = _amounts [ MAX_COIN + i ] if amount != 0 : amounts_base [ i ] = amount withdraw_base = True if withdraw_base : amounts_meta [ MAX_COIN ] = CurveBase ( self . base_pool ) . calc_token_amount ( amounts_base , False ) amounts_meta [ MAX_COIN ] += amounts_meta [ MAX_COIN ] * fee / FEE_DENOMINATOR + 1 # Remove liquidity and deposit leftovers back CurveMeta ( meta_pool ) . remove_liquidity_imbalance ( amounts_meta , _max_burn_amount ) if withdraw_base : CurveBase ( base_pool ) . remove_liquidity_imbalance ( amounts_base , amounts_meta [ MAX_COIN ]) leftover_amounts [ MAX_COIN ] = ERC20 ( meta_coins [ MAX_COIN ]) . balanceOf ( self ) if leftover_amounts [ MAX_COIN ] > 0 : CurveMeta ( meta_pool ) . add_liquidity ( leftover_amounts , 0 ) # Transfer all coins out for i in range ( N_ALL_COINS ): coin : address = ZERO_ADDRESS amount : uint256 = 0 if i < MAX_COIN : coin = meta_coins [ i ] amount = amounts_meta [ i ] else : coin = base_coins [ i - MAX_COIN ] amount = amounts_base [ i - MAX_COIN ] # \"safeTransfer\" which works for ERC20s which return bool or not if amount > 0 : _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amount , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" # Transfer the leftover LP token out leftover : uint256 = ERC20 ( lp_token ) . balanceOf ( self ) if leftover > 0 : assert ERC20 ( lp_token ) . transfer ( msg . sender , leftover ) return _max_burn_amount - leftover Example >>> todo:","title":"DepositZap.remove_liquidity_imbalance"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapcalc_withdraw_one_coin","text":"DepositZap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing and unwrapping a single coin. Returns the amount of coin i received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw ( i should be in the range from 0 to N_ALL_COINS - 1 , where the LP token of the base pool is removed). Source code @view @external def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : \"\"\" @notice Calculate the amount received when withdrawing and unwrapping a single coin @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the underlying coin to withdraw @return Amount of coin received \"\"\" if i < MAX_COIN : return CurveMeta ( self . pool ) . calc_withdraw_one_coin ( _token_amount , i ) else : base_tokens : uint256 = CurveMeta ( self . pool ) . calc_withdraw_one_coin ( _token_amount , MAX_COIN ) return CurveBase ( self . base_pool ) . calc_withdraw_one_coin ( base_tokens , i - MAX_COIN ) Example >>> todo:","title":"DepositZap.calc_withdraw_one_coin"},{"location":"stableswap_exchange/deposit_contracts/metapool_deposits/#depositzapcalc_token_amount","text":"DepositZap.calc_token_amount(_amounts: uint256[N_ALL_COINS], _is_deposit: bool) \u2192 uint256 Calculate addition or reduction in token supply from a deposit or withdrawal. Returns the expected amount of LP tokens received. Input Type Description _amounts uint256[N_ALL_COINS] Amount of each underlying coin being deposited _is_deposit bool Set True for deposits, False for withdrawals Source code @view @external def calc_token_amount ( _amounts : uint256 [ N_ALL_COINS ], _is_deposit : bool ) -> uint256 : \"\"\" @notice Calculate addition or reduction in token supply from a deposit or withdrawal @dev This calculation accounts for slippage, but not fees. Needed to prevent front-running, not for precise calculations! @param _amounts Amount of each underlying coin being deposited @param _is_deposit set True for deposits, False for withdrawals @return Expected amount of LP tokens received \"\"\" meta_amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) base_amounts : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) for i in range ( MAX_COIN ): meta_amounts [ i ] = _amounts [ i ] for i in range ( BASE_N_COINS ): base_amounts [ i ] = _amounts [ i + MAX_COIN ] base_tokens : uint256 = CurveBase ( self . base_pool ) . calc_token_amount ( base_amounts , _is_deposit ) meta_amounts [ MAX_COIN ] = base_tokens return CurveMeta ( self . pool ) . calc_token_amount ( meta_amounts , _is_deposit ) Example >>> todo:","title":"DepositZap.calc_token_amount"},{"location":"stableswap_exchange/deposit_contracts/overview/","text":"Curve StableSwap Exchange: Deposit Contracts \u00b6 Curve pools may rely on a different contract, called a deposit zap for the addition and removal of underlying coins. This is particularly useful for lending pools, which may only support the addition/removal of wrapped coins. Furthermore, deposit zaps are also useful for metapools, which do not support the addition/removal of base pool coins.","title":"Overview"},{"location":"stableswap_exchange/deposit_contracts/overview/#curve-stableswap-exchange-deposit-contracts","text":"Curve pools may rely on a different contract, called a deposit zap for the addition and removal of underlying coins. This is particularly useful for lending pools, which may only support the addition/removal of wrapped coins. Furthermore, deposit zaps are also useful for metapools, which do not support the addition/removal of base pool coins.","title":"Curve StableSwap Exchange: Deposit Contracts"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/","text":"Token Methods \u00b6 CurveToken.name \u00b6 CurveToken.name() \u2192 string[64]: view Get token name. Source code name : public ( string [ 64 ]) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.symbol () 'Curve.fi yDAI/yUSDC/yUSDT/yBUSD' CurveToken.symbol \u00b6 CurveToken.symbol() \u2192 string[32]: view Get token symbol. Source code symbol : public ( string [ 32 ]) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.symbol () 'yDAI+yUSDC+yUSDT+yBUSD' CurveToken.decimals \u00b6 CurveToken.decimals() \u2192 uint256: view Get token precision (decimals). Source code decimals : public ( uint256 ) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.decimals () 18 CurveToken.balanceOf \u00b6 CurveToken.balanceOf(account: address) \u2192 uint256: view Get token balance for an account. Input Type Description address address Address to get the token balance for Source code # NOTE: By declaring `balanceOf` as public, vyper automatically generates a 'balanceOf()' getter # method to allow access to account balances. # The _KeyType will become a required parameter for the getter and it will return _ValueType. # See: https://vyper.readthedocs.io/en/v0.1.0-beta.8/types.html?highlight=getter#mappings balanceOf : public ( map ( address , uint256 )) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.balanceOf ( \"0x69fb7c45726cfe2badee8317005d3f94be838840\" ) 72372801850459006740117197 CurveToken.totalSupply \u00b6 CurveToken.totalSupply() \u2192 uint256: view Get total token supply. Source code @public @constant def totalSupply () -> uint256 : \"\"\" @dev Total number of tokens in existence. \"\"\" return self . total_supply Example >>> lp_token.totalSupply () 73112516629065063732935484 CurveToken.allowance \u00b6 CurveToken.allowance(_owner: address, _spender: address) \u2192 uint256: view This view method gets the allowance of an address ( _spender ) to spend on behalf of some other account _owner . Input Type Description _spender address Account that can spend up to the allowance _owner address Account that is paying when _spender spends the allowance Source code @public @constant def allowance ( _owner : address , _spender : address ) -> uint256 : \"\"\" @dev Function to check the amount of tokens that an owner allowed to a spender. @param _owner The address which owns the funds. @param _spender The address which will spend the funds. @return An uint256 specifying the amount of tokens still available for the spender. \"\"\" return self . allowances [ _owner ][ _spender ] CurveToken.transfer \u00b6 CurveToken.transfer(_to: address, _value: uint256) \u2192 bool Transfer tokens to a specified address. _from address is implicitly msg.sender . Returns True if the transfer succeeds. Input Type Description _to address Receiver of the tokens _value uint256 Amount of tokens to be transferred Emits: Transfer Source code @public def transfer ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Transfer token for a specified address @param _to The address to transfer to. @param _value The amount to be transferred. \"\"\" # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient balance self . balanceOf [ msg . sender ] -= _value self . balanceOf [ _to ] += _value log . Transfer ( msg . sender , _to , _value ) return True CurveToken.transferFrom \u00b6 CurveToken.transferFrom(_from: address, _to: address, _value: uint256) \u2192 bool Transfer tokens from one address to another. msg.sender does the transfer on behalf of the _from address, and requires sufficient spending allowance. Returns True if transfer succeeds. Input Type Description _from address Address which msg.sender want to send tokens from _to address Address which msg.sender want to transfer to _value uint256 Amount of tokens to be transferred Emits: Transfer Source code @public def transferFrom ( _from : address , _to : address , _value : uint256 ) -> bool : \"\"\" @dev Transfer tokens from one address to another. Note that while this function emits a Transfer event, this is not required as per the specification, and other compliant implementations may not emit the event. @param _from address The address which you want to send tokens from @param _to address The address which you want to transfer to @param _value uint256 the amount of tokens to be transferred \"\"\" # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient balance self . balanceOf [ _from ] -= _value self . balanceOf [ _to ] += _value if msg . sender != self . minter : # minter is allowed to transfer anything # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient allowance self . allowances [ _from ][ msg . sender ] -= _value log . Transfer ( _from , _to , _value ) return True Note While this function emits a Transfer event, this is not required as per the specification, and other compliant implementations may not emit the event. CurveToken.approve \u00b6 CurveToken.approve(_spender: address, _value: uint256) \u2192 bool Approve the passed address to spend the specified amount of tokens on behalf of msg.sender . Returns True on successful approvals. Input Type Description _spender address Address which will spend the funds _value uint256 Amount of tokens to be spent Emits: Approval Source code @public def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will spend the funds. @param _value The amount of tokens to be spent. \"\"\" assert _value == 0 or self . allowances [ msg . sender ][ _spender ] == 0 self . allowances [ msg . sender ][ _spender ] = _value log . Approval ( msg . sender , _spender , _value ) return True Warning Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender\u2019s allowance to 0 and set the desired value afterwards (see this GitHub issue ). Warning For Curve LP Tokens V1 and V2, non-zero to non-zero approvals are prohibited . Instead, after every non-zero approval, the allowance for the spender must be reset to 0. Minter Methods \u00b6 The following methods are only callable by the minter (private attribute). Note For Curve Token V1, the minter attribute is not public . CurveToken.mint \u00b6 CurveToken.mint(_to: address, _value: uint256) This encapsulates the modification of balances such that the proper events are emitted. Input Type Description _to address Address that will receive the minted tokens _value uint256 Amount of tokens that will be minted Emits: Transfer Source code @public def mint ( _to : address , _value : uint256 ): \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log . Transfer ( ZERO_ADDRESS , _to , _value ) CurveToken.burn \u00b6 CurveToken.burn(_value: uint256) Burn an amount of the token of msg.sender . Input Type Description _value uint256 Token amount that will be burned Emits: Transfer Source code @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) @public def burn ( _value : uint256 ): \"\"\" @dev Burn an amount of the token of msg.sender. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( msg . sender , _value ) CurveToken.burnFrom \u00b6 CurveToken.burnFrom(_to: address, _value: uint256) Burn an amount of the token from a given account. Input Type Description _to address Account whose tokens will be burned _value uint256 Token amount that will be burned Emits: Transfer Source code @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value ) CurveToken.set_minter \u00b6 CurveToken.set_minter(_minter: address) Set a new minter for the token. Input Type Description _minter address Address of the new minter Source code @public def set_minter ( _minter : address ): assert msg . sender == self . minter self . minter = _minter","title":"Curve Token V1"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#token-methods","text":"","title":"Token Methods"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenname","text":"CurveToken.name() \u2192 string[64]: view Get token name. Source code name : public ( string [ 64 ]) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.symbol () 'Curve.fi yDAI/yUSDC/yUSDT/yBUSD'","title":"CurveToken.name"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokensymbol","text":"CurveToken.symbol() \u2192 string[32]: view Get token symbol. Source code symbol : public ( string [ 32 ]) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.symbol () 'yDAI+yUSDC+yUSDT+yBUSD'","title":"CurveToken.symbol"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokendecimals","text":"CurveToken.decimals() \u2192 uint256: view Get token precision (decimals). Source code decimals : public ( uint256 ) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.decimals () 18","title":"CurveToken.decimals"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenbalanceof","text":"CurveToken.balanceOf(account: address) \u2192 uint256: view Get token balance for an account. Input Type Description address address Address to get the token balance for Source code # NOTE: By declaring `balanceOf` as public, vyper automatically generates a 'balanceOf()' getter # method to allow access to account balances. # The _KeyType will become a required parameter for the getter and it will return _ValueType. # See: https://vyper.readthedocs.io/en/v0.1.0-beta.8/types.html?highlight=getter#mappings balanceOf : public ( map ( address , uint256 )) ... @public def __init__ ( _name : string [ 64 ], _symbol : string [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log . Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.balanceOf ( \"0x69fb7c45726cfe2badee8317005d3f94be838840\" ) 72372801850459006740117197","title":"CurveToken.balanceOf"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokentotalsupply","text":"CurveToken.totalSupply() \u2192 uint256: view Get total token supply. Source code @public @constant def totalSupply () -> uint256 : \"\"\" @dev Total number of tokens in existence. \"\"\" return self . total_supply Example >>> lp_token.totalSupply () 73112516629065063732935484","title":"CurveToken.totalSupply"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenallowance","text":"CurveToken.allowance(_owner: address, _spender: address) \u2192 uint256: view This view method gets the allowance of an address ( _spender ) to spend on behalf of some other account _owner . Input Type Description _spender address Account that can spend up to the allowance _owner address Account that is paying when _spender spends the allowance Source code @public @constant def allowance ( _owner : address , _spender : address ) -> uint256 : \"\"\" @dev Function to check the amount of tokens that an owner allowed to a spender. @param _owner The address which owns the funds. @param _spender The address which will spend the funds. @return An uint256 specifying the amount of tokens still available for the spender. \"\"\" return self . allowances [ _owner ][ _spender ]","title":"CurveToken.allowance"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokentransfer","text":"CurveToken.transfer(_to: address, _value: uint256) \u2192 bool Transfer tokens to a specified address. _from address is implicitly msg.sender . Returns True if the transfer succeeds. Input Type Description _to address Receiver of the tokens _value uint256 Amount of tokens to be transferred Emits: Transfer Source code @public def transfer ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Transfer token for a specified address @param _to The address to transfer to. @param _value The amount to be transferred. \"\"\" # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient balance self . balanceOf [ msg . sender ] -= _value self . balanceOf [ _to ] += _value log . Transfer ( msg . sender , _to , _value ) return True","title":"CurveToken.transfer"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokentransferfrom","text":"CurveToken.transferFrom(_from: address, _to: address, _value: uint256) \u2192 bool Transfer tokens from one address to another. msg.sender does the transfer on behalf of the _from address, and requires sufficient spending allowance. Returns True if transfer succeeds. Input Type Description _from address Address which msg.sender want to send tokens from _to address Address which msg.sender want to transfer to _value uint256 Amount of tokens to be transferred Emits: Transfer Source code @public def transferFrom ( _from : address , _to : address , _value : uint256 ) -> bool : \"\"\" @dev Transfer tokens from one address to another. Note that while this function emits a Transfer event, this is not required as per the specification, and other compliant implementations may not emit the event. @param _from address The address which you want to send tokens from @param _to address The address which you want to transfer to @param _value uint256 the amount of tokens to be transferred \"\"\" # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient balance self . balanceOf [ _from ] -= _value self . balanceOf [ _to ] += _value if msg . sender != self . minter : # minter is allowed to transfer anything # NOTE: vyper does not allow underflows # so the following subtraction would revert on insufficient allowance self . allowances [ _from ][ msg . sender ] -= _value log . Transfer ( _from , _to , _value ) return True Note While this function emits a Transfer event, this is not required as per the specification, and other compliant implementations may not emit the event.","title":"CurveToken.transferFrom"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenapprove","text":"CurveToken.approve(_spender: address, _value: uint256) \u2192 bool Approve the passed address to spend the specified amount of tokens on behalf of msg.sender . Returns True on successful approvals. Input Type Description _spender address Address which will spend the funds _value uint256 Amount of tokens to be spent Emits: Approval Source code @public def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will spend the funds. @param _value The amount of tokens to be spent. \"\"\" assert _value == 0 or self . allowances [ msg . sender ][ _spender ] == 0 self . allowances [ msg . sender ][ _spender ] = _value log . Approval ( msg . sender , _spender , _value ) return True Warning Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender\u2019s allowance to 0 and set the desired value afterwards (see this GitHub issue ). Warning For Curve LP Tokens V1 and V2, non-zero to non-zero approvals are prohibited . Instead, after every non-zero approval, the allowance for the spender must be reset to 0.","title":"CurveToken.approve"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#minter-methods","text":"The following methods are only callable by the minter (private attribute). Note For Curve Token V1, the minter attribute is not public .","title":"Minter Methods"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenmint","text":"CurveToken.mint(_to: address, _value: uint256) This encapsulates the modification of balances such that the proper events are emitted. Input Type Description _to address Address that will receive the minted tokens _value uint256 Amount of tokens that will be minted Emits: Transfer Source code @public def mint ( _to : address , _value : uint256 ): \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log . Transfer ( ZERO_ADDRESS , _to , _value )","title":"CurveToken.mint"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenburn","text":"CurveToken.burn(_value: uint256) Burn an amount of the token of msg.sender . Input Type Description _value uint256 Token amount that will be burned Emits: Transfer Source code @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) @public def burn ( _value : uint256 ): \"\"\" @dev Burn an amount of the token of msg.sender. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( msg . sender , _value )","title":"CurveToken.burn"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenburnfrom","text":"CurveToken.burnFrom(_to: address, _value: uint256) Burn an amount of the token from a given account. Input Type Description _to address Account whose tokens will be burned _value uint256 Token amount that will be burned Emits: Transfer Source code @private def _burn ( _to : address , _value : uint256 ): \"\"\" @dev Internal function that burns an amount of the token of a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log . Transfer ( _to , ZERO_ADDRESS , _value ) @public def burnFrom ( _to : address , _value : uint256 ): \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter , \"Only minter is allowed to burn\" self . _burn ( _to , _value )","title":"CurveToken.burnFrom"},{"location":"stableswap_exchange/lp_tokens/curve_token_v1/#curvetokenset_minter","text":"CurveToken.set_minter(_minter: address) Set a new minter for the token. Input Type Description _minter address Address of the new minter Source code @public def set_minter ( _minter : address ): assert msg . sender == self . minter self . minter = _minter","title":"CurveToken.set_minter"},{"location":"stableswap_exchange/lp_tokens/curve_token_v2/","text":"The implementation for a Curve Token V2 may be viewed on GitHub . Note Compared to Curve Token v1, the following changes have been made to the API: minter attribute is public and therefore a minter getter has been generated name and symbol attributes can be set via set_name mint method returns bool burnFrom method returns bool burn method has been removed Warning For Curve LP Tokens V1 and V2, non-zero to non-zero approvals are prohibited. Instead, after every non-zero approval, the allowance for the spender must be reset to 0 . CurveToken.minter \u00b6 CurveToken.minter() \u2192 address: view Getter for the address of the minter of the token. Source code minter : public ( address ) @external def __init__ ( _name : String [ 64 ], _symbol : String [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.minter () \"\" CurveToken.set_name \u00b6 CurveToken.set_name(_name: String[64], _symbol: String[32]) Set the name and symbol of the token. This method can only be called by minter. Input Type Description name String[64] New name of token symbol String[32] New symbol of token Source code @external def set_name ( _name : String [ 64 ], _symbol : String [ 32 ]): assert Curve ( self . minter ) . owner () == msg . sender self . name = _name self . symbol = _symbol Example >>> lp_token.minter () todo: \"\" CurveToken.mint \u00b6 CurveToken.mint(_to: address, _value: uint256) \u2192 bool Mint an amount of the token and assign it to an account. This encapsulates the modification of balances such that the proper events are emitted. Returns True if not reverted. Input Type Description _to address Receiver of minted tokens _value uint256 Amount of tokens minted Emits: Transfer Source code @external def mint ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log Transfer ( ZERO_ADDRESS , _to , _value ) return True Example >>> lp_token.mint () todo: \"\" CurveToken.burnFrom \u00b6 CurveToken.burnFrom(_to: address, _value: uint256) \u2192 bool Burn an amount of the token from a given account. Returns True if not reverted. Input Type Description _to address Account whose tokens will be burned _value uint256 Amount that will be burned Emits: Transfer Source code @external def burnFrom ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log Transfer ( _to , ZERO_ADDRESS , _value ) return True Example >>> lp_token.burnFrom () todo: \"\"","title":"Curve Token V2"},{"location":"stableswap_exchange/lp_tokens/curve_token_v2/#curvetokenminter","text":"CurveToken.minter() \u2192 address: view Getter for the address of the minter of the token. Source code minter : public ( address ) @external def __init__ ( _name : String [ 64 ], _symbol : String [ 32 ], _decimals : uint256 , _supply : uint256 ): init_supply : uint256 = _supply * 10 ** _decimals self . name = _name self . symbol = _symbol self . decimals = _decimals self . balanceOf [ msg . sender ] = init_supply self . total_supply = init_supply self . minter = msg . sender log Transfer ( ZERO_ADDRESS , msg . sender , init_supply ) Example >>> lp_token.minter () \"\"","title":"CurveToken.minter"},{"location":"stableswap_exchange/lp_tokens/curve_token_v2/#curvetokenset_name","text":"CurveToken.set_name(_name: String[64], _symbol: String[32]) Set the name and symbol of the token. This method can only be called by minter. Input Type Description name String[64] New name of token symbol String[32] New symbol of token Source code @external def set_name ( _name : String [ 64 ], _symbol : String [ 32 ]): assert Curve ( self . minter ) . owner () == msg . sender self . name = _name self . symbol = _symbol Example >>> lp_token.minter () todo: \"\"","title":"CurveToken.set_name"},{"location":"stableswap_exchange/lp_tokens/curve_token_v2/#curvetokenmint","text":"CurveToken.mint(_to: address, _value: uint256) \u2192 bool Mint an amount of the token and assign it to an account. This encapsulates the modification of balances such that the proper events are emitted. Returns True if not reverted. Input Type Description _to address Receiver of minted tokens _value uint256 Amount of tokens minted Emits: Transfer Source code @external def mint ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Mint an amount of the token and assigns it to an account. This encapsulates the modification of balances such that the proper events are emitted. @param _to The account that will receive the created tokens. @param _value The amount that will be created. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply += _value self . balanceOf [ _to ] += _value log Transfer ( ZERO_ADDRESS , _to , _value ) return True Example >>> lp_token.mint () todo: \"\"","title":"CurveToken.mint"},{"location":"stableswap_exchange/lp_tokens/curve_token_v2/#curvetokenburnfrom","text":"CurveToken.burnFrom(_to: address, _value: uint256) \u2192 bool Burn an amount of the token from a given account. Returns True if not reverted. Input Type Description _to address Account whose tokens will be burned _value uint256 Amount that will be burned Emits: Transfer Source code @external def burnFrom ( _to : address , _value : uint256 ) -> bool : \"\"\" @dev Burn an amount of the token from a given account. @param _to The account whose tokens will be burned. @param _value The amount that will be burned. \"\"\" assert msg . sender == self . minter assert _to != ZERO_ADDRESS self . total_supply -= _value self . balanceOf [ _to ] -= _value log Transfer ( _to , ZERO_ADDRESS , _value ) return True Example >>> lp_token.burnFrom () todo: \"\"","title":"CurveToken.burnFrom"},{"location":"stableswap_exchange/lp_tokens/curve_token_v3/","text":"The Curve Token V3 is more gas efficient than versions 1 and 2. The implementation for a Curve Token V3 may be viewed on GitHub . Note Compared to the Curve Token V2 API, there have been the following changes: increaseAllowance and decreaseAllowance methods added to mitigate race conditions. CurveToken.increaseAllowance \u00b6 CurveToken.increaseAllowance(_spender: address, _added_value: uint256) \u2192 bool Increase the allowance granted to _spender by the msg.sender . This is alternative to approve that can be used as a mitigation for the potential race condition. Returns True if success. Input Type Description _spender address Account whose tokens will be burned _value uint256 Amount that will be burned Emits: Approval Source code @external def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @notice Approve the passed address to transfer the specified amount of tokens on behalf of msg.sender @dev Beware that changing an allowance via this method brings the risk that someone may use both the old and new allowance by unfortunate transaction ordering. This may be mitigated with the use of {increaseAllowance} and {decreaseAllowance}. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will transfer the funds @param _value The amount of tokens that may be transferred @return bool success \"\"\" self . allowance [ msg . sender ][ _spender ] = _value log Approval ( msg . sender , _spender , _value ) return True @external def increaseAllowance ( _spender : address , _added_value : uint256 ) -> bool : \"\"\" @notice Increase the allowance granted to `_spender` by the caller @dev This is alternative to {approve} that can be used as a mitigation for the potential race condition @param _spender The address which will transfer the funds @param _added_value The amount of to increase the allowance @return bool success \"\"\" allowance : uint256 = self . allowance [ msg . sender ][ _spender ] + _added_value self . allowance [ msg . sender ][ _spender ] = allowance log Approval ( msg . sender , _spender , allowance ) return True Example >>> lp_token.increaseAllowance () todo: \"\" CurveToken.decreaseAllowance \u00b6 CurveToken.decreaseAllowance(_spender: address, _subtracted_value: uint256) \u2192 bool Decrease the allowance granted to _spender by the msg.sender . This is alternative to approve that can be used as a mitigation for the potential race condition. Returns True if success. Input Type Description _spender address Account whose tokens will be burned _added_value uint256 Amount that will be burned Emits: Approval Source code @external def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @notice Approve the passed address to transfer the specified amount of tokens on behalf of msg.sender @dev Beware that changing an allowance via this method brings the risk that someone may use both the old and new allowance by unfortunate transaction ordering. This may be mitigated with the use of {increaseAllowance} and {decreaseAllowance}. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will transfer the funds @param _value The amount of tokens that may be transferred @return bool success \"\"\" self . allowance [ msg . sender ][ _spender ] = _value log Approval ( msg . sender , _spender , _value ) return True @external def decreaseAllowance ( _spender : address , _subtracted_value : uint256 ) -> bool : \"\"\" @notice Decrease the allowance granted to `_spender` by the caller @dev This is alternative to {approve} that can be used as a mitigation for the potential race condition @param _spender The address which will transfer the funds @param _subtracted_value The amount of to decrease the allowance @return bool success \"\"\" allowance : uint256 = self . allowance [ msg . sender ][ _spender ] - _subtracted_value self . allowance [ msg . sender ][ _spender ] = allowance log Approval ( msg . sender , _spender , allowance ) return True Example >>> lp_token.decreaseAllowance () todo: \"\"","title":"Curve Token V3"},{"location":"stableswap_exchange/lp_tokens/curve_token_v3/#curvetokenincreaseallowance","text":"CurveToken.increaseAllowance(_spender: address, _added_value: uint256) \u2192 bool Increase the allowance granted to _spender by the msg.sender . This is alternative to approve that can be used as a mitigation for the potential race condition. Returns True if success. Input Type Description _spender address Account whose tokens will be burned _value uint256 Amount that will be burned Emits: Approval Source code @external def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @notice Approve the passed address to transfer the specified amount of tokens on behalf of msg.sender @dev Beware that changing an allowance via this method brings the risk that someone may use both the old and new allowance by unfortunate transaction ordering. This may be mitigated with the use of {increaseAllowance} and {decreaseAllowance}. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will transfer the funds @param _value The amount of tokens that may be transferred @return bool success \"\"\" self . allowance [ msg . sender ][ _spender ] = _value log Approval ( msg . sender , _spender , _value ) return True @external def increaseAllowance ( _spender : address , _added_value : uint256 ) -> bool : \"\"\" @notice Increase the allowance granted to `_spender` by the caller @dev This is alternative to {approve} that can be used as a mitigation for the potential race condition @param _spender The address which will transfer the funds @param _added_value The amount of to increase the allowance @return bool success \"\"\" allowance : uint256 = self . allowance [ msg . sender ][ _spender ] + _added_value self . allowance [ msg . sender ][ _spender ] = allowance log Approval ( msg . sender , _spender , allowance ) return True Example >>> lp_token.increaseAllowance () todo: \"\"","title":"CurveToken.increaseAllowance"},{"location":"stableswap_exchange/lp_tokens/curve_token_v3/#curvetokendecreaseallowance","text":"CurveToken.decreaseAllowance(_spender: address, _subtracted_value: uint256) \u2192 bool Decrease the allowance granted to _spender by the msg.sender . This is alternative to approve that can be used as a mitigation for the potential race condition. Returns True if success. Input Type Description _spender address Account whose tokens will be burned _added_value uint256 Amount that will be burned Emits: Approval Source code @external def approve ( _spender : address , _value : uint256 ) -> bool : \"\"\" @notice Approve the passed address to transfer the specified amount of tokens on behalf of msg.sender @dev Beware that changing an allowance via this method brings the risk that someone may use both the old and new allowance by unfortunate transaction ordering. This may be mitigated with the use of {increaseAllowance} and {decreaseAllowance}. https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address which will transfer the funds @param _value The amount of tokens that may be transferred @return bool success \"\"\" self . allowance [ msg . sender ][ _spender ] = _value log Approval ( msg . sender , _spender , _value ) return True @external def decreaseAllowance ( _spender : address , _subtracted_value : uint256 ) -> bool : \"\"\" @notice Decrease the allowance granted to `_spender` by the caller @dev This is alternative to {approve} that can be used as a mitigation for the potential race condition @param _spender The address which will transfer the funds @param _subtracted_value The amount of to decrease the allowance @return bool success \"\"\" allowance : uint256 = self . allowance [ msg . sender ][ _spender ] - _subtracted_value self . allowance [ msg . sender ][ _spender ] = allowance log Approval ( msg . sender , _spender , allowance ) return True Example >>> lp_token.decreaseAllowance () todo: \"\"","title":"CurveToken.decreaseAllowance"},{"location":"stableswap_exchange/lp_tokens/overview/","text":"In exchange for depositing coins into a Curve pool, liquidity providers receive pool LP (liquidity pool) tokens. A Curve pool LP token is an ERC20 contract specific to the Curve pool. Hence, LP tokens are transferrable. Holders of pool LP tokens may deposit and stake the token into a pool\u2019s liquidity gauge in order to receive CRV token rewards. Alternatively, if the LP token is supported by a metapool, the token may be deposited into the respective metapool in exchange for the metapool\u2019s LP token (see here). Currently, the following versions of Curve StableSwap LP tokens exist: CurveTokenV1 : LP token targetting Vyper ^0.1.0-beta.16 CurveTokenV2 : LP token targetting Vyper ^0.2.0 CurveTokenV2 : LP token targetting Vyper ^0.2.0 todo: add hyperlink to deployment addresses The version of each pool\u2019s LP token can be found in the Deployment Addresses. Note For older Curve pools the token attribute is not always public and a getter has not been explicitly implemented.","title":"Overview"},{"location":"stableswap_exchange/pools/admin_pool_settings/","text":"Overview \u00b6 The following are methods that may only be called by the pool admin ( owner ). Additionally, some admin methods require a two-phase transaction process, whereby changes are committed in a first transaction and after a forced delay applied via a second transaction. The minimum delay after which a committed action can be applied is given by the constant pool attribute admin_actions_delay , which is set to 3 days. Pool Ownership Methods \u00b6 StableSwap.commit_transfer_ownership \u00b6 StableSwap.commit_transfer_ownership(_owner: address) Initiate an ownership transfer of pool to _owner . Input Type Description _owner address Future owner of the pool contract Emits: CommitNewAdmin Source code ADMIN_ACTIONS_DELAY : constant ( uint256 ) = 3 * 86400 ... @external def commit_transfer_ownership ( _owner : address ): assert msg . sender == self . owner # dev: only owner assert self . transfer_ownership_deadline == 0 # dev: active transfer _deadline : uint256 = block . timestamp + ADMIN_ACTIONS_DELAY self . transfer_ownership_deadline = _deadline self . future_owner = _owner log CommitNewAdmin ( _deadline , _owner ) Example >>> pool.commit_transfer_ownership () todo: console output Note The ownership can not be transferred before transfer_ownership_deadline , which is the timestamp of the current block delayed by ADMIN_ACTIONS_DELAY . StableSwap.apply_transfer_ownership \u00b6 StableSwap.apply_transfer_ownership() Transfers ownership of the pool from current owner to the owner previously set via commit_transfer_ownership . Emits: NewAdmin Source code @external def apply_transfer_ownership (): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . transfer_ownership_deadline # dev: insufficient time assert self . transfer_ownership_deadline != 0 # dev: no active transfer self . transfer_ownership_deadline = 0 _owner : address = self . future_owner self . owner = _owner log NewAdmin ( _owner ) Example >>> pool.apply_transfer_ownership () todo: log output Warning Pool ownership can only be transferred once. StableSwap.revert_transfer_ownership() \u00b6 StableSwap.revert_transfer_ownership() Reverts any previously committed transfer of ownership. This method resets the transfer_ownership_deadline to 0 . Source code @external def revert_transfer_ownership (): assert msg . sender == self . owner # dev: only owner self . transfer_ownership_deadline = 0 Example >>> pool.revert_transfer_ownership () todo: log output Amplification Coefficient Admin Controls \u00b6 The amplification coefficient A determines a pool\u2019s tolerance for imbalance between the assets within it. A higher value means that trades will incur slippage sooner as the assets within the pool become imbalanced. Note Within the pools, A is in fact implemented as 1 / A and therefore a higher value implies that the pool will be more tolerant to slippage when imbalanced. The appropriate value for A is dependent upon the type of coin being used within the pool, and is subject to optimisation and pool-parameter update based on the market history of the trading pair. It is possible to modify the amplification coefficient for a pool after it has been deployed. However, it requires a vote within the Curve DAO and must reach a 15% quorum. StableSwap.ramp_A \u00b6 StableSwap.ramp_A(_future_A: uint256, _future_time: uint256) Ramp A up or down by setting a new A to take effect at a future point in time. Input Type Description _future_A uint256 New future value of A _future_time uint256 Timestamp at which new A should take effect Emits: RampA Source code MIN_RAMP_TIME : constant ( uint256 ) = 86400 MAX_A_CHANGE : constant ( uint256 ) = 10 MAX_A : constant ( uint256 ) = 10 ** 6 ... @external def ramp_A ( _future_A : uint256 , _future_time : uint256 ): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . initial_A_time + MIN_RAMP_TIME assert _future_time >= block . timestamp + MIN_RAMP_TIME # dev: insufficient time _initial_A : uint256 = self . _A () _future_A_p : uint256 = _future_A * A_PRECISION assert _future_A > 0 and _future_A < MAX_A if _future_A_p < _initial_A : assert _future_A_p * MAX_A_CHANGE >= _initial_A else : assert _future_A_p <= _initial_A * MAX_A_CHANGE self . initial_A = _initial_A self . future_A = _future_A_p self . initial_A_time = block . timestamp self . future_A_time = _future_time log RampA ( _initial_A , _future_A_p , block . timestamp , _future_time ) Example >>> pool.ramp_A () todo: log output StableSwap.stop_ramp_A \u00b6 StableSwap.stop_ramp_A() Stop ramping A up or down and sets A to current A . Emits: StopRampA Source code @external def stop_ramp_A (): assert msg . sender == self . owner # dev: only owner current_A : uint256 = self . _A () self . initial_A = current_A self . future_A = current_A self . initial_A_time = block . timestamp self . future_A_time = block . timestamp # now (block.timestamp < t1) is always False, so we return saved A log StopRampA ( current_A , block . timestamp ) Example >>> pool.stop_ramp_A () todo: log output Swap Fees Admin Controls \u00b6 todo: hyperlink to fee collection and distribution Curve pools charge fees on token swaps, where the fee may differ between pools. An admin fee is charged on the pool fee. For an overview of how fees are distributed, please refer to Fee Collection and Distribution. StableSwap.commit_new_fee \u00b6 StableSwap.commit_new_fee(_new_fee: uint256, _new_admin_fee: uint256) The method commits new fee params: these fees do not take immediate effect. Input Type Description _new_fee uint256 New pool fee _new_admin_fee uint256 New admin fee (expressed as a percentage of the pool fee) Emits: CommitNewFee Source code MAX_ADMIN_FEE : constant ( uint256 ) = 10 * 10 ** 9 MAX_FEE : constant ( uint256 ) = 5 * 10 ** 9 ADMIN_ACTIONS_DELAY : constant ( uint256 ) = 3 * 86400 ... @external def commit_new_fee ( new_fee : uint256 , new_admin_fee : uint256 ): assert msg . sender == self . owner # dev: only owner assert self . admin_actions_deadline == 0 # dev: active action assert new_fee <= MAX_FEE # dev: fee exceeds maximum assert new_admin_fee <= MAX_ADMIN_FEE # dev: admin fee exceeds maximum _deadline : uint256 = block . timestamp + ADMIN_ACTIONS_DELAY self . admin_actions_deadline = _deadline self . future_fee = new_fee self . future_admin_fee = new_admin_fee log CommitNewFee ( _deadline , new_fee , new_admin_fee ) Example >>> pool.commit_new_fee () todo: log output Note Both the pool fee and the admin_fee are capped by the constants MAX_FEE and MAX_ADMIN_FEE , respectively. By default MAX_FEE is set at 50% and MAX_ADMIN_FEE at 100% (which is charged on the MAX_FEE amount). StableSwap.apply_new_fee \u00b6 StableSwap.apply_new_fee() Apply the previously committed new pool and admin fees for the pool. Emits: NewFee Source code @external def apply_new_fee (): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . admin_actions_deadline # dev: insufficient time assert self . admin_actions_deadline != 0 # dev: no active action self . admin_actions_deadline = 0 _fee : uint256 = self . future_fee _admin_fee : uint256 = self . future_admin_fee self . fee = _fee self . admin_fee = _admin_fee log NewFee ( _fee , _admin_fee ) Example >>> pool.commit_new_fee () todo: log output Note Unlike ownership transfers, pool and admin fees may be set more than once. StableSwap.revert_new_parameters \u00b6 StableSwap.revert_new_parameters() Resets any previously committed new fees. Source code @external def revert_new_parameters (): assert msg . sender == self . owner # dev: only owner self . admin_actions_deadline = 0 Example >>> pool.revert_new_parameters () todo: log output StableSwap.admin_balances \u00b6 StableSwap.admin_balances(i: uint256) \u2192 uint256 Get the admin balance for a single coin in the pool. Input Type Description i uint256 Index of the coin to get admin balance for Source code @view @external def admin_balances ( i : uint256 ) -> uint256 : return ERC20 ( self . coins [ i ]) . balanceOf ( self ) - self . balances [ i ] Example >>> pool.admin_balances () todo: log output StableSwap.withdraw_admin_fees \u00b6 StableSwap.withdraw_admin_fees() Withdraws and transfers admin fees of the pool to the pool owner. @external def withdraw_admin_fees (): assert msg . sender == self . owner # dev: only owner for i in range ( N_COINS ): c : address = self . coins [ i ] value : uint256 = ERC20 ( c ) . balanceOf ( self ) - self . balances [ i ] if value > 0 : assert ERC20 ( c ) . transfer ( msg . sender , value ) Example >>> pool.withdraw_admin_fees () todo: log output StableSwap.donate_admin_fees \u00b6 StableSwap.donate_admin_fees() Donate all admin fees to the pool\u2019s liquidity providers. Source code @external def donate_admin_fees (): assert msg . sender == self . owner # dev: only owner for i in range ( N_COINS ): self . balances [ i ] = ERC20 ( self . coins [ i ]) . balanceOf ( self ) Example >>> pool.donate_admin_fees () todo: log output Note Older Curve pools do not implement this method. Kill a Pool \u00b6 StableSwap.kill_me \u00b6 StableSwap.kill_me() Pause a pool by setting the is_killed boolean flag to True . This disables the following pool functionality: - add_liquidity - exchange - remove_liquidity_imbalance - remove_liquidity_one_coin It is only possible for existing LPs to remove liquidity via remove_liquidity from a paused pool. Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed ... @external def kill_me (): assert msg . sender == self . owner # dev: only owner assert self . kill_deadline > block . timestamp # dev: deadline has passed self . is_killed = True Example todo: add example Note Pools can only be killed within the first 30 days after deployment. StableSwap.unkill_me \u00b6 StableSwap.unkill_me Unpause a pool that was previously paused, re-enabling exchanges. Source code @external def unkill_me(): assert msg.sender == self.owner # dev: only owner self.is_killed = False Example todo: add example","title":"Admin Controls"},{"location":"stableswap_exchange/pools/admin_pool_settings/#overview","text":"The following are methods that may only be called by the pool admin ( owner ). Additionally, some admin methods require a two-phase transaction process, whereby changes are committed in a first transaction and after a forced delay applied via a second transaction. The minimum delay after which a committed action can be applied is given by the constant pool attribute admin_actions_delay , which is set to 3 days.","title":"Overview"},{"location":"stableswap_exchange/pools/admin_pool_settings/#pool-ownership-methods","text":"","title":"Pool Ownership Methods"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapcommit_transfer_ownership","text":"StableSwap.commit_transfer_ownership(_owner: address) Initiate an ownership transfer of pool to _owner . Input Type Description _owner address Future owner of the pool contract Emits: CommitNewAdmin Source code ADMIN_ACTIONS_DELAY : constant ( uint256 ) = 3 * 86400 ... @external def commit_transfer_ownership ( _owner : address ): assert msg . sender == self . owner # dev: only owner assert self . transfer_ownership_deadline == 0 # dev: active transfer _deadline : uint256 = block . timestamp + ADMIN_ACTIONS_DELAY self . transfer_ownership_deadline = _deadline self . future_owner = _owner log CommitNewAdmin ( _deadline , _owner ) Example >>> pool.commit_transfer_ownership () todo: console output Note The ownership can not be transferred before transfer_ownership_deadline , which is the timestamp of the current block delayed by ADMIN_ACTIONS_DELAY .","title":"StableSwap.commit_transfer_ownership"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapapply_transfer_ownership","text":"StableSwap.apply_transfer_ownership() Transfers ownership of the pool from current owner to the owner previously set via commit_transfer_ownership . Emits: NewAdmin Source code @external def apply_transfer_ownership (): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . transfer_ownership_deadline # dev: insufficient time assert self . transfer_ownership_deadline != 0 # dev: no active transfer self . transfer_ownership_deadline = 0 _owner : address = self . future_owner self . owner = _owner log NewAdmin ( _owner ) Example >>> pool.apply_transfer_ownership () todo: log output Warning Pool ownership can only be transferred once.","title":"StableSwap.apply_transfer_ownership"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswaprevert_transfer_ownership","text":"StableSwap.revert_transfer_ownership() Reverts any previously committed transfer of ownership. This method resets the transfer_ownership_deadline to 0 . Source code @external def revert_transfer_ownership (): assert msg . sender == self . owner # dev: only owner self . transfer_ownership_deadline = 0 Example >>> pool.revert_transfer_ownership () todo: log output","title":"StableSwap.revert_transfer_ownership()"},{"location":"stableswap_exchange/pools/admin_pool_settings/#amplification-coefficient-admin-controls","text":"The amplification coefficient A determines a pool\u2019s tolerance for imbalance between the assets within it. A higher value means that trades will incur slippage sooner as the assets within the pool become imbalanced. Note Within the pools, A is in fact implemented as 1 / A and therefore a higher value implies that the pool will be more tolerant to slippage when imbalanced. The appropriate value for A is dependent upon the type of coin being used within the pool, and is subject to optimisation and pool-parameter update based on the market history of the trading pair. It is possible to modify the amplification coefficient for a pool after it has been deployed. However, it requires a vote within the Curve DAO and must reach a 15% quorum.","title":"Amplification Coefficient Admin Controls"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapramp_a","text":"StableSwap.ramp_A(_future_A: uint256, _future_time: uint256) Ramp A up or down by setting a new A to take effect at a future point in time. Input Type Description _future_A uint256 New future value of A _future_time uint256 Timestamp at which new A should take effect Emits: RampA Source code MIN_RAMP_TIME : constant ( uint256 ) = 86400 MAX_A_CHANGE : constant ( uint256 ) = 10 MAX_A : constant ( uint256 ) = 10 ** 6 ... @external def ramp_A ( _future_A : uint256 , _future_time : uint256 ): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . initial_A_time + MIN_RAMP_TIME assert _future_time >= block . timestamp + MIN_RAMP_TIME # dev: insufficient time _initial_A : uint256 = self . _A () _future_A_p : uint256 = _future_A * A_PRECISION assert _future_A > 0 and _future_A < MAX_A if _future_A_p < _initial_A : assert _future_A_p * MAX_A_CHANGE >= _initial_A else : assert _future_A_p <= _initial_A * MAX_A_CHANGE self . initial_A = _initial_A self . future_A = _future_A_p self . initial_A_time = block . timestamp self . future_A_time = _future_time log RampA ( _initial_A , _future_A_p , block . timestamp , _future_time ) Example >>> pool.ramp_A () todo: log output","title":"StableSwap.ramp_A"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapstop_ramp_a","text":"StableSwap.stop_ramp_A() Stop ramping A up or down and sets A to current A . Emits: StopRampA Source code @external def stop_ramp_A (): assert msg . sender == self . owner # dev: only owner current_A : uint256 = self . _A () self . initial_A = current_A self . future_A = current_A self . initial_A_time = block . timestamp self . future_A_time = block . timestamp # now (block.timestamp < t1) is always False, so we return saved A log StopRampA ( current_A , block . timestamp ) Example >>> pool.stop_ramp_A () todo: log output","title":"StableSwap.stop_ramp_A"},{"location":"stableswap_exchange/pools/admin_pool_settings/#swap-fees-admin-controls","text":"todo: hyperlink to fee collection and distribution Curve pools charge fees on token swaps, where the fee may differ between pools. An admin fee is charged on the pool fee. For an overview of how fees are distributed, please refer to Fee Collection and Distribution.","title":"Swap Fees Admin Controls"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapcommit_new_fee","text":"StableSwap.commit_new_fee(_new_fee: uint256, _new_admin_fee: uint256) The method commits new fee params: these fees do not take immediate effect. Input Type Description _new_fee uint256 New pool fee _new_admin_fee uint256 New admin fee (expressed as a percentage of the pool fee) Emits: CommitNewFee Source code MAX_ADMIN_FEE : constant ( uint256 ) = 10 * 10 ** 9 MAX_FEE : constant ( uint256 ) = 5 * 10 ** 9 ADMIN_ACTIONS_DELAY : constant ( uint256 ) = 3 * 86400 ... @external def commit_new_fee ( new_fee : uint256 , new_admin_fee : uint256 ): assert msg . sender == self . owner # dev: only owner assert self . admin_actions_deadline == 0 # dev: active action assert new_fee <= MAX_FEE # dev: fee exceeds maximum assert new_admin_fee <= MAX_ADMIN_FEE # dev: admin fee exceeds maximum _deadline : uint256 = block . timestamp + ADMIN_ACTIONS_DELAY self . admin_actions_deadline = _deadline self . future_fee = new_fee self . future_admin_fee = new_admin_fee log CommitNewFee ( _deadline , new_fee , new_admin_fee ) Example >>> pool.commit_new_fee () todo: log output Note Both the pool fee and the admin_fee are capped by the constants MAX_FEE and MAX_ADMIN_FEE , respectively. By default MAX_FEE is set at 50% and MAX_ADMIN_FEE at 100% (which is charged on the MAX_FEE amount).","title":"StableSwap.commit_new_fee"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapapply_new_fee","text":"StableSwap.apply_new_fee() Apply the previously committed new pool and admin fees for the pool. Emits: NewFee Source code @external def apply_new_fee (): assert msg . sender == self . owner # dev: only owner assert block . timestamp >= self . admin_actions_deadline # dev: insufficient time assert self . admin_actions_deadline != 0 # dev: no active action self . admin_actions_deadline = 0 _fee : uint256 = self . future_fee _admin_fee : uint256 = self . future_admin_fee self . fee = _fee self . admin_fee = _admin_fee log NewFee ( _fee , _admin_fee ) Example >>> pool.commit_new_fee () todo: log output Note Unlike ownership transfers, pool and admin fees may be set more than once.","title":"StableSwap.apply_new_fee"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswaprevert_new_parameters","text":"StableSwap.revert_new_parameters() Resets any previously committed new fees. Source code @external def revert_new_parameters (): assert msg . sender == self . owner # dev: only owner self . admin_actions_deadline = 0 Example >>> pool.revert_new_parameters () todo: log output","title":"StableSwap.revert_new_parameters"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapadmin_balances","text":"StableSwap.admin_balances(i: uint256) \u2192 uint256 Get the admin balance for a single coin in the pool. Input Type Description i uint256 Index of the coin to get admin balance for Source code @view @external def admin_balances ( i : uint256 ) -> uint256 : return ERC20 ( self . coins [ i ]) . balanceOf ( self ) - self . balances [ i ] Example >>> pool.admin_balances () todo: log output","title":"StableSwap.admin_balances"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapwithdraw_admin_fees","text":"StableSwap.withdraw_admin_fees() Withdraws and transfers admin fees of the pool to the pool owner. @external def withdraw_admin_fees (): assert msg . sender == self . owner # dev: only owner for i in range ( N_COINS ): c : address = self . coins [ i ] value : uint256 = ERC20 ( c ) . balanceOf ( self ) - self . balances [ i ] if value > 0 : assert ERC20 ( c ) . transfer ( msg . sender , value ) Example >>> pool.withdraw_admin_fees () todo: log output","title":"StableSwap.withdraw_admin_fees"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapdonate_admin_fees","text":"StableSwap.donate_admin_fees() Donate all admin fees to the pool\u2019s liquidity providers. Source code @external def donate_admin_fees (): assert msg . sender == self . owner # dev: only owner for i in range ( N_COINS ): self . balances [ i ] = ERC20 ( self . coins [ i ]) . balanceOf ( self ) Example >>> pool.donate_admin_fees () todo: log output Note Older Curve pools do not implement this method.","title":"StableSwap.donate_admin_fees"},{"location":"stableswap_exchange/pools/admin_pool_settings/#kill-a-pool","text":"","title":"Kill a Pool"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapkill_me","text":"StableSwap.kill_me() Pause a pool by setting the is_killed boolean flag to True . This disables the following pool functionality: - add_liquidity - exchange - remove_liquidity_imbalance - remove_liquidity_one_coin It is only possible for existing LPs to remove liquidity via remove_liquidity from a paused pool. Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed ... @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed ... @external def kill_me (): assert msg . sender == self . owner # dev: only owner assert self . kill_deadline > block . timestamp # dev: deadline has passed self . is_killed = True Example todo: add example Note Pools can only be killed within the first 30 days after deployment.","title":"StableSwap.kill_me"},{"location":"stableswap_exchange/pools/admin_pool_settings/#stableswapunkill_me","text":"StableSwap.unkill_me Unpause a pool that was previously paused, re-enabling exchanges. Source code @external def unkill_me(): assert msg.sender == self.owner # dev: only owner self.is_killed = False Example todo: add example","title":"StableSwap.unkill_me"},{"location":"stableswap_exchange/pools/lending_pools/","text":"Overview \u00b6 Curve pools may contain lending functionality, whereby the underlying tokens are lent out on other protocols (e.g., Compound or Yearn). Hence, the main difference to a plain pool is that a lending pool does not hold the underlying token itself, but a wrapped representation of it. Currently, Curve supports the following lending pools: aave : Aave pool , with lending on Aave busd : BUSD pool, with lending on yearn.finance compound : Compound pool, with lending on Compound ib : Iron Bank pool , with lending on Cream pax : PAX pool, with lending on yearn.finance usdt : USDT pool , with lending on Compound y : Y pool , with lending on yearn.finance An example of a Curve lending pool is Compound Pool , which contains the wrapped tokens cDAI and cUSDC , while the underlying tokens DAI and USDC are lent out on Compound. Liquidity providers of the Compound Pool therefore receive interest generated on Compound in addition to fees from token swaps in the pool. Implementation of lending pools may differ with respect to how wrapped tokens accrue interest. There are two main types of wrapped tokens that are used by lending pools: cToken-style tokens : These are tokens, such as interest-bearing cTokens on Compound (e.g., cDAI ) or on yTokens on Yearn, where interest accrues as the rate of the token increases. aToken-style tokens : These are tokens, such as aTokens on AAVE (e.g., aDAI ), where interest accrues as the balance of the token increases. The template source code for lending pools may be viewed on GitHub. Note Lending pools also implement the ABI from plain pools. Refer to the plan pools documentation for overlapping methods. Pool Info Methods \u00b6 StableSwap.underlying_coins \u00b6 StableSwap.underlying_coins(i: uint256) \u2192 address: view Getter for the array of underlying coins within the pool. Input Type Description i uint128 Index of coin to swap from Source code underlying_coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of wrapped coins @param _underlying_coins Addresses of ERC20 contracts of underlying coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> lending_pool.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> lending_pool.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563' Exchange Methods \u00b6 Like plain pools, lending pools have the exchange method. However, in the case of lending pools, calling exchange performs a swap between two wrapped tokens in the pool. For example, calling exchange on the Compound Pool, would result in a swap between the wrapped tokens cDAI and cUSDC . StableSwap.exchange_underlying \u00b6 StableSwap.exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256) \u2192 uint256 Perform an exchange between two underlying tokens. Index values can be found via the underlying_coins public getter method. Returns the actual amount of coin j received. Input Type Description i int128 Index value for the underlying coin to send j int128 Index value of the underlying coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchangeUnderlying Source code @external @nonreentrant ( 'lock' ) def exchange_underlying ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two underlying coins @dev Index values can be found via the `underlying_coins` public getter method @param i Index value for the underlying coin to send @param j Index valie of the underlying coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" dy : uint256 = self . _exchange ( i , j , dx ) assert dy >= min_dy , \"Exchange resulted in fewer coins than expected\" u_coin_i : address = self . underlying_coins [ i ] lending_pool : address = self . aave_lending_pool # transfer underlying coin from msg.sender to self _response : Bytes [ 32 ] = raw_call ( u_coin_i , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ) ), max_outsize = 32 ) if len ( _response ) != 0 : assert convert ( _response , bool ) # deposit to aave lending pool raw_call ( lending_pool , concat ( method_id ( \"deposit(address,uint256,address,uint16)\" ), convert ( u_coin_i , bytes32 ), convert ( dx , bytes32 ), convert ( self , bytes32 ), convert ( self . aave_referral , bytes32 ), ) ) # withdraw `j` underlying from lending pool and transfer to caller LendingPool ( lending_pool ) . withdraw ( self . underlying_coins [ j ], dy , msg . sender ) log TokenExchangeUnderlying ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange_underlying () todo: console output Note Older Curve lending pools may not implement the same signature for exchange_underlying . For instance, Compound pool does not return anything for exchange_underlying and therefore costs more in terms of gas. Add/Remove Liquidity Methods \u00b6 The function signatures for adding and removing liquidity to a lending pool are mostly the same as for a plain pool. However, for lending pools, liquidity is added and removed in the wrapped token, not the underlying. In order to be able to add and remove liquidity in the underlying token (e.g., remove DAI from Compound Pool instead of cDAI ) there exists a Deposit<POOL>.vy contract (e.g., ( DepositCompound.vy ). Warning Older Curve lending pools (e.g., Compound Pool) do not implement all plain pool methods for adding and removing liquidity. For instance, remove_liquidity_one_coin is not implemented by Compound Pool). Some newer pools (e.g., IB ) have a modified signature for add_liquidity and allow the caller to specify whether the deposited liquidity is in the wrapped or underlying token. StableSwap.add_liquidity \u00b6 StableSwap.add_liquidity(_amounts: uint256[N_COINS], _min_mint_amount: uint256, _use_underlying: bool = False) \u2192 uint256 Perform an exchange between two underlying tokens. Index values can be found via the underlying_coins public getter method. Returns amount of LP tokens received in exchange for the deposited tokens. Input Type Description _amounts uint256[N_COINS] List of amounts of coins to deposit _min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit _use_underlying bool If True , deposit underlying assets instead of wrapped assets Emits: AddLiquidity Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( _amounts : uint256 [ N_COINS ], _min_mint_amount : uint256 , _use_underlying : bool = False ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param _amounts List of amounts of coins to deposit @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit @param _use_underlying If True, deposit underlying assets instead of aTokens @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed # Initial invariant amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . _balances () lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( lp_token ) . totalSupply () D0 : uint256 = 0 if token_supply != 0 : D0 = self . get_D_precisions ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert _amounts [ i ] != 0 # dev: initial deposit requires all coins new_balances [ i ] += _amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_precisions ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) mint_amount : uint256 = 0 if token_supply != 0 : # Only account for fees if we are not the first to deposit ys : uint256 = ( D0 + D1 ) / N_COINS _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _feemul : uint256 = self . offpeg_fee_multiplier _admin_fee : uint256 = self . admin_fee difference : uint256 = 0 for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 new_balance : uint256 = new_balances [ i ] if ideal_balance > new_balance : difference = ideal_balance - new_balance else : difference = new_balance - ideal_balance xs : uint256 = old_balances [ i ] + new_balance fees [ i ] = self . _dynamic_fee ( xs , ys , _fee , _feemul ) * difference / FEE_DENOMINATOR if _admin_fee != 0 : self . admin_balances [ i ] += fees [ i ] * _admin_fee / FEE_DENOMINATOR new_balances [ i ] = new_balance - fees [ i ] D2 : uint256 = self . get_D_precisions ( new_balances , amp ) mint_amount = token_supply * ( D2 - D0 ) / D0 else : mint_amount = D1 # Take the dust if there was any assert mint_amount >= _min_mint_amount , \"Slippage screwed you\" # Take coins from the sender if _use_underlying : lending_pool : address = self . aave_lending_pool aave_referral : bytes32 = convert ( self . aave_referral , bytes32 ) # Take coins from the sender for i in range ( N_COINS ): amount : uint256 = _amounts [ i ] if amount != 0 : coin : address = self . underlying_coins [ i ] # transfer underlying coin from msg.sender to self _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) != 0 : assert convert ( _response , bool ) # deposit to aave lending pool raw_call ( lending_pool , concat ( method_id ( \"deposit(address,uint256,address,uint16)\" ), convert ( coin , bytes32 ), convert ( amount , bytes32 ), convert ( self , bytes32 ), aave_referral , ) ) else : for i in range ( N_COINS ): amount : uint256 = _amounts [ i ] if amount != 0 : assert ERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , amount ) # dev: failed transfer # Mint pool tokens CurveToken ( lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , _amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> lending_pool.add_liquidity () todo: console output","title":"Lending Pools"},{"location":"stableswap_exchange/pools/lending_pools/#overview","text":"Curve pools may contain lending functionality, whereby the underlying tokens are lent out on other protocols (e.g., Compound or Yearn). Hence, the main difference to a plain pool is that a lending pool does not hold the underlying token itself, but a wrapped representation of it. Currently, Curve supports the following lending pools: aave : Aave pool , with lending on Aave busd : BUSD pool, with lending on yearn.finance compound : Compound pool, with lending on Compound ib : Iron Bank pool , with lending on Cream pax : PAX pool, with lending on yearn.finance usdt : USDT pool , with lending on Compound y : Y pool , with lending on yearn.finance An example of a Curve lending pool is Compound Pool , which contains the wrapped tokens cDAI and cUSDC , while the underlying tokens DAI and USDC are lent out on Compound. Liquidity providers of the Compound Pool therefore receive interest generated on Compound in addition to fees from token swaps in the pool. Implementation of lending pools may differ with respect to how wrapped tokens accrue interest. There are two main types of wrapped tokens that are used by lending pools: cToken-style tokens : These are tokens, such as interest-bearing cTokens on Compound (e.g., cDAI ) or on yTokens on Yearn, where interest accrues as the rate of the token increases. aToken-style tokens : These are tokens, such as aTokens on AAVE (e.g., aDAI ), where interest accrues as the balance of the token increases. The template source code for lending pools may be viewed on GitHub. Note Lending pools also implement the ABI from plain pools. Refer to the plan pools documentation for overlapping methods.","title":"Overview"},{"location":"stableswap_exchange/pools/lending_pools/#pool-info-methods","text":"","title":"Pool Info Methods"},{"location":"stableswap_exchange/pools/lending_pools/#stableswapunderlying_coins","text":"StableSwap.underlying_coins(i: uint256) \u2192 address: view Getter for the array of underlying coins within the pool. Input Type Description i uint128 Index of coin to swap from Source code underlying_coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _underlying_coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of wrapped coins @param _underlying_coins Addresses of ERC20 contracts of underlying coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS assert _underlying_coins [ i ] != ZERO_ADDRESS # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _underlying_coins [ i ], concat ( method_id ( \"approve(address,uint256)\" ), convert ( _coins [ i ], bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) self . coins = _coins self . underlying_coins = _underlying_coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> lending_pool.coins ( 0 ) '0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643' >>> lending_pool.coins ( 1 ) '0x39AA39c021dfbaE8faC545936693aC917d5E7563'","title":"StableSwap.underlying_coins"},{"location":"stableswap_exchange/pools/lending_pools/#exchange-methods","text":"Like plain pools, lending pools have the exchange method. However, in the case of lending pools, calling exchange performs a swap between two wrapped tokens in the pool. For example, calling exchange on the Compound Pool, would result in a swap between the wrapped tokens cDAI and cUSDC .","title":"Exchange Methods"},{"location":"stableswap_exchange/pools/lending_pools/#stableswapexchange_underlying","text":"StableSwap.exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256) \u2192 uint256 Perform an exchange between two underlying tokens. Index values can be found via the underlying_coins public getter method. Returns the actual amount of coin j received. Input Type Description i int128 Index value for the underlying coin to send j int128 Index value of the underlying coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchangeUnderlying Source code @external @nonreentrant ( 'lock' ) def exchange_underlying ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two underlying coins @dev Index values can be found via the `underlying_coins` public getter method @param i Index value for the underlying coin to send @param j Index valie of the underlying coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" dy : uint256 = self . _exchange ( i , j , dx ) assert dy >= min_dy , \"Exchange resulted in fewer coins than expected\" u_coin_i : address = self . underlying_coins [ i ] lending_pool : address = self . aave_lending_pool # transfer underlying coin from msg.sender to self _response : Bytes [ 32 ] = raw_call ( u_coin_i , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ) ), max_outsize = 32 ) if len ( _response ) != 0 : assert convert ( _response , bool ) # deposit to aave lending pool raw_call ( lending_pool , concat ( method_id ( \"deposit(address,uint256,address,uint16)\" ), convert ( u_coin_i , bytes32 ), convert ( dx , bytes32 ), convert ( self , bytes32 ), convert ( self . aave_referral , bytes32 ), ) ) # withdraw `j` underlying from lending pool and transfer to caller LendingPool ( lending_pool ) . withdraw ( self . underlying_coins [ j ], dy , msg . sender ) log TokenExchangeUnderlying ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange_underlying () todo: console output Note Older Curve lending pools may not implement the same signature for exchange_underlying . For instance, Compound pool does not return anything for exchange_underlying and therefore costs more in terms of gas.","title":"StableSwap.exchange_underlying"},{"location":"stableswap_exchange/pools/lending_pools/#addremove-liquidity-methods","text":"The function signatures for adding and removing liquidity to a lending pool are mostly the same as for a plain pool. However, for lending pools, liquidity is added and removed in the wrapped token, not the underlying. In order to be able to add and remove liquidity in the underlying token (e.g., remove DAI from Compound Pool instead of cDAI ) there exists a Deposit<POOL>.vy contract (e.g., ( DepositCompound.vy ). Warning Older Curve lending pools (e.g., Compound Pool) do not implement all plain pool methods for adding and removing liquidity. For instance, remove_liquidity_one_coin is not implemented by Compound Pool). Some newer pools (e.g., IB ) have a modified signature for add_liquidity and allow the caller to specify whether the deposited liquidity is in the wrapped or underlying token.","title":"Add/Remove Liquidity Methods"},{"location":"stableswap_exchange/pools/lending_pools/#stableswapadd_liquidity","text":"StableSwap.add_liquidity(_amounts: uint256[N_COINS], _min_mint_amount: uint256, _use_underlying: bool = False) \u2192 uint256 Perform an exchange between two underlying tokens. Index values can be found via the underlying_coins public getter method. Returns amount of LP tokens received in exchange for the deposited tokens. Input Type Description _amounts uint256[N_COINS] List of amounts of coins to deposit _min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit _use_underlying bool If True , deposit underlying assets instead of wrapped assets Emits: AddLiquidity Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( _amounts : uint256 [ N_COINS ], _min_mint_amount : uint256 , _use_underlying : bool = False ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param _amounts List of amounts of coins to deposit @param _min_mint_amount Minimum amount of LP tokens to mint from the deposit @param _use_underlying If True, deposit underlying assets instead of aTokens @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed # Initial invariant amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . _balances () lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( lp_token ) . totalSupply () D0 : uint256 = 0 if token_supply != 0 : D0 = self . get_D_precisions ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert _amounts [ i ] != 0 # dev: initial deposit requires all coins new_balances [ i ] += _amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_precisions ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) mint_amount : uint256 = 0 if token_supply != 0 : # Only account for fees if we are not the first to deposit ys : uint256 = ( D0 + D1 ) / N_COINS _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _feemul : uint256 = self . offpeg_fee_multiplier _admin_fee : uint256 = self . admin_fee difference : uint256 = 0 for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 new_balance : uint256 = new_balances [ i ] if ideal_balance > new_balance : difference = ideal_balance - new_balance else : difference = new_balance - ideal_balance xs : uint256 = old_balances [ i ] + new_balance fees [ i ] = self . _dynamic_fee ( xs , ys , _fee , _feemul ) * difference / FEE_DENOMINATOR if _admin_fee != 0 : self . admin_balances [ i ] += fees [ i ] * _admin_fee / FEE_DENOMINATOR new_balances [ i ] = new_balance - fees [ i ] D2 : uint256 = self . get_D_precisions ( new_balances , amp ) mint_amount = token_supply * ( D2 - D0 ) / D0 else : mint_amount = D1 # Take the dust if there was any assert mint_amount >= _min_mint_amount , \"Slippage screwed you\" # Take coins from the sender if _use_underlying : lending_pool : address = self . aave_lending_pool aave_referral : bytes32 = convert ( self . aave_referral , bytes32 ) # Take coins from the sender for i in range ( N_COINS ): amount : uint256 = _amounts [ i ] if amount != 0 : coin : address = self . underlying_coins [ i ] # transfer underlying coin from msg.sender to self _response : Bytes [ 32 ] = raw_call ( coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amount , bytes32 ) ), max_outsize = 32 ) if len ( _response ) != 0 : assert convert ( _response , bool ) # deposit to aave lending pool raw_call ( lending_pool , concat ( method_id ( \"deposit(address,uint256,address,uint16)\" ), convert ( coin , bytes32 ), convert ( amount , bytes32 ), convert ( self , bytes32 ), aave_referral , ) ) else : for i in range ( N_COINS ): amount : uint256 = _amounts [ i ] if amount != 0 : assert ERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , amount ) # dev: failed transfer # Mint pool tokens CurveToken ( lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , _amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> lending_pool.add_liquidity () todo: console output","title":"StableSwap.add_liquidity"},{"location":"stableswap_exchange/pools/metapools/","text":"Overview \u00b6 A metapool is a pool where a stablecoin is paired against the LP token from another pool, a so-called base pool. For example, a liquidity provider may deposit DAI into 3Pool and in exchange receive the pool\u2019s LP token 3CRV . The 3CRV LP token may then be deposited into the GUSD metapool , which contains the coins GUSD and 3CRV , in exchange for the metapool\u2019s LP token gusd3CRV. The obtained LP token may then be staked in the metapool\u2019s liquidity gauge for CRV rewards. Metapools provide an opportunity for the base pool liquidity providers to earn additional trading fees by depositing their LP tokens into the metapool. Note that the CRV rewards received for staking LP tokens into the pool\u2019s liquidity gauge may differ for the base pool\u2019s liquidity gauge and the metapool\u2019s liquidity gauge. For details on liquidity gauges and protocol rewards, please refer to Liquidity Gauges and Minting CRV. Note Metapools also implement the ABI from plain pools. The template source code for metapools may be viewed on GitHub . Pool Info Methods \u00b6 StableSwap.base_coins \u00b6 StableSwap.base_coins(i: uint256) \u2192 address: view Get the coins of the base pool. Returns address of the coin at index i . Input Type Description i uint256 Coin index Source code # Token corresponding to the pool is always the last one BASE_POOL_COINS : constant ( int128 ) = 3 ... base_coins : public ( address [ BASE_POOL_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> metapool.base_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' >>> metapool.base_coins ( 2 ) '0xdAC17F958D2ee523a2206206994597C13D831ec7' StableSwap.coins \u00b6 StableSwap.coins(i: uint256) \u2192 address: view Get the coins of the metapool. Returns address of coin at index i . Input Type Description i uint256 Coin index Source code N_COINS : constant ( int128 ) = 2 ... coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.coins ( 0 ) '0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd' >>> metapool.coins ( 1 ) '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490' In this console example, coins(0) is the metapool\u2019s coin ( GUSD ) and coins(1) is the LP token of the base pool ( 3CRV ). StableSwap.base_pool \u00b6 StableSwap.base_pool() \u2192 address: view Get the address of the base pool. Returns address of the base pool implementation. Source code base_pool : public ( address ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_pool () '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7' StableSwap.base_virtual_price \u00b6 StableSwap.base_virtual_price() \u2192 uint256: view Get the current price of the base pool LP token relative to the underlying base pool assets. Source code base_virtual_price : public ( uint256 ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_virtual_price () 1014750545929625438 Note The base pool\u2019s virtual price is only fetched from the base pool if the cached price has expired. A fetched based pool virtual price is cached for 10 minutes ( BASE_CACHE_EXPIRES: constant(int128) = 10 * 60 ). StableSwap.base_cache_update() \u00b6 StableSwap.base_cache_update() \u2192 uint256: view Get the timestamp at which the base pool virtual price was last cached. Source code base_cache_updated : public ( uint256 ) ... BASE_CACHE_EXPIRES : constant ( int128 ) = 10 * 60 # 10 min ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) ... @internal def _vp_rate () -> uint256 : if block . timestamp > self . base_cache_updated + BASE_CACHE_EXPIRES : vprice : uint256 = Curve ( self . base_pool ) . get_virtual_price () self . base_virtual_price = vprice self . base_cache_updated = block . timestamp return vprice else : return self . base_virtual_price @internal @view def _vp_rate_ro () -> uint256 : if block . timestamp > self . base_cache_updated + BASE_CACHE_EXPIRES : return Curve ( self . base_pool ) . get_virtual_price () else : return self . base_virtual_price Example >>> metapool.base_cache_updated () 1616583340 Exchange Methods \u00b6 Similar to lending pools, on metapools exchanges can be made either between the coins the metapool actually holds (another pool\u2019s LP token and some other coin) or between the metapool\u2019s underlying coins. In the context of a metapool, underlying coins refers to the metapool\u2019s coin and any of the base pool\u2019s coins. The base pool\u2019s LP token is not included as an underlying coin. For example, the GUSD metapool would have the following: Coins: GUSD , 3CRV (3Pool LP) Underlying coins: GUSD , DAI , USDC , USDT Note While metapools contain public getters for coins and base_coins , there exists no getter for obtaining a list of all underlying coins. StableSwap.exchange \u00b6 StableSwap.exchange(i: int128, j: int128, _dx: uint256, _min_dy: uint256) \u2192 uint256 Perform an exchange between two (non-underlying) coins in the metapool. Index values can be found via the coins public getter method. Returns: the actual amount of coin j received. Input Type Description i int128 Index value for the coin to send j int128 Index value of the coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchange todo: explain how fee is calculated Source code @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed rates : uint256 [ N_COINS ] = RATES rates [ MAX_COIN ] = self . _vp_rate () old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( rates [ MAX_COIN ], old_balances ) x : uint256 = xp [ i ] + dx * rates [ i ] / PRECISION y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = xp [ j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units dy = ( dy - dy_fee ) * PRECISION / rates [ j ] assert dy >= min_dy , \"Too few coins in result\" dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ i ] = old_balances [ i ] + dx # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ j ] = old_balances [ j ] - dy - dy_admin_fee assert ERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , dx ) assert ERC20 ( self . coins [ j ]) . transfer ( msg . sender , dy ) log TokenExchange ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange () todo: console output StableSwap.exchange_underlying \u00b6 StableSwap.exchange_underlying(i: int128, j: int128, _dx: uint256, _min_dy: uint256) \u2192 uint256 Perform an exchange between two underlying tokens. Index values are the coins followed by the base_coins , where the base pool LP token is not included as a value. Returns: the actual amount of coin j received. Input Type Description i int128 Index value for the coin to send j int128 Index value of the coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchangeUnderlying Source code @external @nonreentrant ( 'lock' ) def exchange_underlying ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two underlying coins @dev Index values can be found via the `underlying_coins` public getter method @param i Index value for the underlying coin to send @param j Index valie of the underlying coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed rates : uint256 [ N_COINS ] = RATES rates [ MAX_COIN ] = self . _vp_rate () _base_pool : address = self . base_pool # Use base_i or base_j if they are >= 0 base_i : int128 = i - MAX_COIN base_j : int128 = j - MAX_COIN meta_i : int128 = MAX_COIN meta_j : int128 = MAX_COIN if base_i < 0 : meta_i = i if base_j < 0 : meta_j = j dy : uint256 = 0 # Addresses for input and output coins input_coin : address = ZERO_ADDRESS if base_i < 0 : input_coin = self . coins [ i ] else : input_coin = self . base_coins [ base_i ] output_coin : address = ZERO_ADDRESS if base_j < 0 : output_coin = self . coins [ j ] else : output_coin = self . base_coins [ base_j ] # Handle potential Tether fees dx_w_fee : uint256 = dx if input_coin == FEE_ASSET : dx_w_fee = ERC20 ( FEE_ASSET ) . balanceOf ( self ) # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( input_coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransferFrom\" # Handle potential Tether fees if input_coin == FEE_ASSET : dx_w_fee = ERC20 ( FEE_ASSET ) . balanceOf ( self ) - dx_w_fee if base_i < 0 or base_j < 0 : old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( rates [ MAX_COIN ], old_balances ) x : uint256 = 0 if base_i < 0 : x = xp [ i ] + dx_w_fee * rates [ i ] / PRECISION else : # i is from BasePool # At first, get the amount of pool tokens base_inputs : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) base_inputs [ base_i ] = dx_w_fee coin_i : address = self . coins [ MAX_COIN ] # Deposit and measure delta x = ERC20 ( coin_i ) . balanceOf ( self ) Curve ( _base_pool ) . add_liquidity ( base_inputs , 0 ) # Need to convert pool token to \"virtual\" units using rates # dx is also different now dx_w_fee = ERC20 ( coin_i ) . balanceOf ( self ) - x x = dx_w_fee * rates [ MAX_COIN ] / PRECISION # Adding number of pool tokens x += xp [ MAX_COIN ] y : uint256 = self . get_y ( meta_i , meta_j , x , xp ) # Either a real coin or token dy = xp [ meta_j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units # Works for both pool coins and real coins dy = ( dy - dy_fee ) * PRECISION / rates [ meta_j ] dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ meta_j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ meta_i ] = old_balances [ meta_i ] + dx_w_fee # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ meta_j ] = old_balances [ meta_j ] - dy - dy_admin_fee # Withdraw from the base pool if needed if base_j >= 0 : out_amount : uint256 = ERC20 ( output_coin ) . balanceOf ( self ) Curve ( _base_pool ) . remove_liquidity_one_coin ( dy , base_j , 0 ) dy = ERC20 ( output_coin ) . balanceOf ( self ) - out_amount assert dy >= min_dy , \"Too few coins in result\" else : # If both are from the base pool dy = ERC20 ( output_coin ) . balanceOf ( self ) Curve ( _base_pool ) . exchange ( base_i , base_j , dx_w_fee , min_dy ) dy = ERC20 ( output_coin ) . balanceOf ( self ) - dy # \"safeTransfer\" which works for ERC20s which return bool or not _response = raw_call ( output_coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" log TokenExchangeUnderlying ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange_underlying () todo: console output","title":"Metapools"},{"location":"stableswap_exchange/pools/metapools/#overview","text":"A metapool is a pool where a stablecoin is paired against the LP token from another pool, a so-called base pool. For example, a liquidity provider may deposit DAI into 3Pool and in exchange receive the pool\u2019s LP token 3CRV . The 3CRV LP token may then be deposited into the GUSD metapool , which contains the coins GUSD and 3CRV , in exchange for the metapool\u2019s LP token gusd3CRV. The obtained LP token may then be staked in the metapool\u2019s liquidity gauge for CRV rewards. Metapools provide an opportunity for the base pool liquidity providers to earn additional trading fees by depositing their LP tokens into the metapool. Note that the CRV rewards received for staking LP tokens into the pool\u2019s liquidity gauge may differ for the base pool\u2019s liquidity gauge and the metapool\u2019s liquidity gauge. For details on liquidity gauges and protocol rewards, please refer to Liquidity Gauges and Minting CRV. Note Metapools also implement the ABI from plain pools. The template source code for metapools may be viewed on GitHub .","title":"Overview"},{"location":"stableswap_exchange/pools/metapools/#pool-info-methods","text":"","title":"Pool Info Methods"},{"location":"stableswap_exchange/pools/metapools/#stableswapbase_coins","text":"StableSwap.base_coins(i: uint256) \u2192 address: view Get the coins of the base pool. Returns address of the coin at index i . Input Type Description i uint256 Coin index Source code # Token corresponding to the pool is always the last one BASE_POOL_COINS : constant ( int128 ) = 3 ... base_coins : public ( address [ BASE_POOL_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_coins ( 0 ) '0x6B175474E89094C44Da98b954EedeAC495271d0F' >>> metapool.base_coins ( 1 ) '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48' >>> metapool.base_coins ( 2 ) '0xdAC17F958D2ee523a2206206994597C13D831ec7'","title":"StableSwap.base_coins"},{"location":"stableswap_exchange/pools/metapools/#stableswapcoins","text":"StableSwap.coins(i: uint256) \u2192 address: view Get the coins of the metapool. Returns address of coin at index i . Input Type Description i uint256 Coin index Source code N_COINS : constant ( int128 ) = 2 ... coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.coins ( 0 ) '0x056Fd409E1d7A124BD7017459dFEa2F387b6d5Cd' >>> metapool.coins ( 1 ) '0x6c3F90f043a72FA612cbac8115EE7e52BDe6E490' In this console example, coins(0) is the metapool\u2019s coin ( GUSD ) and coins(1) is the LP token of the base pool ( 3CRV ).","title":"StableSwap.coins"},{"location":"stableswap_exchange/pools/metapools/#stableswapbase_pool","text":"StableSwap.base_pool() \u2192 address: view Get the address of the base pool. Returns address of the base pool implementation. Source code base_pool : public ( address ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_pool () '0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7'","title":"StableSwap.base_pool"},{"location":"stableswap_exchange/pools/metapools/#stableswapbase_virtual_price","text":"StableSwap.base_virtual_price() \u2192 uint256: view Get the current price of the base pool LP token relative to the underlying base pool assets. Source code base_virtual_price : public ( uint256 ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) Example >>> metapool.base_virtual_price () 1014750545929625438 Note The base pool\u2019s virtual price is only fetched from the base pool if the cached price has expired. A fetched based pool virtual price is cached for 10 minutes ( BASE_CACHE_EXPIRES: constant(int128) = 10 * 60 ).","title":"StableSwap.base_virtual_price"},{"location":"stableswap_exchange/pools/metapools/#stableswapbase_cache_update","text":"StableSwap.base_cache_update() \u2192 uint256: view Get the timestamp at which the base pool virtual price was last cached. Source code base_cache_updated : public ( uint256 ) ... BASE_CACHE_EXPIRES : constant ( int128 ) = 10 * 60 # 10 min ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _base_pool : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _base_pool Address of the base pool (which will have a virtual price) @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . token = CurveToken ( _pool_token ) self . base_pool = _base_pool self . base_virtual_price = Curve ( _base_pool ) . get_virtual_price () self . base_cache_updated = block . timestamp for i in range ( BASE_POOL_COINS ): _base_coin : address = Curve ( _base_pool ) . coins ( convert ( i , uint256 )) self . base_coins [ i ] = _base_coin # approve underlying coins for infinite transfers _response : Bytes [ 32 ] = raw_call ( _base_coin , concat ( method_id ( \"approve(address,uint256)\" ), convert ( _base_pool , bytes32 ), convert ( MAX_UINT256 , bytes32 ), ), max_outsize = 32 , ) if len ( _response ) > 0 : assert convert ( _response , bool ) ... @internal def _vp_rate () -> uint256 : if block . timestamp > self . base_cache_updated + BASE_CACHE_EXPIRES : vprice : uint256 = Curve ( self . base_pool ) . get_virtual_price () self . base_virtual_price = vprice self . base_cache_updated = block . timestamp return vprice else : return self . base_virtual_price @internal @view def _vp_rate_ro () -> uint256 : if block . timestamp > self . base_cache_updated + BASE_CACHE_EXPIRES : return Curve ( self . base_pool ) . get_virtual_price () else : return self . base_virtual_price Example >>> metapool.base_cache_updated () 1616583340","title":"StableSwap.base_cache_update()"},{"location":"stableswap_exchange/pools/metapools/#exchange-methods","text":"Similar to lending pools, on metapools exchanges can be made either between the coins the metapool actually holds (another pool\u2019s LP token and some other coin) or between the metapool\u2019s underlying coins. In the context of a metapool, underlying coins refers to the metapool\u2019s coin and any of the base pool\u2019s coins. The base pool\u2019s LP token is not included as an underlying coin. For example, the GUSD metapool would have the following: Coins: GUSD , 3CRV (3Pool LP) Underlying coins: GUSD , DAI , USDC , USDT Note While metapools contain public getters for coins and base_coins , there exists no getter for obtaining a list of all underlying coins.","title":"Exchange Methods"},{"location":"stableswap_exchange/pools/metapools/#stableswapexchange","text":"StableSwap.exchange(i: int128, j: int128, _dx: uint256, _min_dy: uint256) \u2192 uint256 Perform an exchange between two (non-underlying) coins in the metapool. Index values can be found via the coins public getter method. Returns: the actual amount of coin j received. Input Type Description i int128 Index value for the coin to send j int128 Index value of the coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchange todo: explain how fee is calculated Source code @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed rates : uint256 [ N_COINS ] = RATES rates [ MAX_COIN ] = self . _vp_rate () old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( rates [ MAX_COIN ], old_balances ) x : uint256 = xp [ i ] + dx * rates [ i ] / PRECISION y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = xp [ j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units dy = ( dy - dy_fee ) * PRECISION / rates [ j ] assert dy >= min_dy , \"Too few coins in result\" dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ i ] = old_balances [ i ] + dx # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ j ] = old_balances [ j ] - dy - dy_admin_fee assert ERC20 ( self . coins [ i ]) . transferFrom ( msg . sender , self , dx ) assert ERC20 ( self . coins [ j ]) . transfer ( msg . sender , dy ) log TokenExchange ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange () todo: console output","title":"StableSwap.exchange"},{"location":"stableswap_exchange/pools/metapools/#stableswapexchange_underlying","text":"StableSwap.exchange_underlying(i: int128, j: int128, _dx: uint256, _min_dy: uint256) \u2192 uint256 Perform an exchange between two underlying tokens. Index values are the coins followed by the base_coins , where the base pool LP token is not included as a value. Returns: the actual amount of coin j received. Input Type Description i int128 Index value for the coin to send j int128 Index value of the coin to receive _dx uint256 Amount of i being exchanged _min_dy uint256 Minimum amount of j to receive Emits: TokenExchangeUnderlying Source code @external @nonreentrant ( 'lock' ) def exchange_underlying ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two underlying coins @dev Index values can be found via the `underlying_coins` public getter method @param i Index value for the underlying coin to send @param j Index valie of the underlying coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed rates : uint256 [ N_COINS ] = RATES rates [ MAX_COIN ] = self . _vp_rate () _base_pool : address = self . base_pool # Use base_i or base_j if they are >= 0 base_i : int128 = i - MAX_COIN base_j : int128 = j - MAX_COIN meta_i : int128 = MAX_COIN meta_j : int128 = MAX_COIN if base_i < 0 : meta_i = i if base_j < 0 : meta_j = j dy : uint256 = 0 # Addresses for input and output coins input_coin : address = ZERO_ADDRESS if base_i < 0 : input_coin = self . coins [ i ] else : input_coin = self . base_coins [ base_i ] output_coin : address = ZERO_ADDRESS if base_j < 0 : output_coin = self . coins [ j ] else : output_coin = self . base_coins [ base_j ] # Handle potential Tether fees dx_w_fee : uint256 = dx if input_coin == FEE_ASSET : dx_w_fee = ERC20 ( FEE_ASSET ) . balanceOf ( self ) # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( input_coin , concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransferFrom\" # Handle potential Tether fees if input_coin == FEE_ASSET : dx_w_fee = ERC20 ( FEE_ASSET ) . balanceOf ( self ) - dx_w_fee if base_i < 0 or base_j < 0 : old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( rates [ MAX_COIN ], old_balances ) x : uint256 = 0 if base_i < 0 : x = xp [ i ] + dx_w_fee * rates [ i ] / PRECISION else : # i is from BasePool # At first, get the amount of pool tokens base_inputs : uint256 [ BASE_N_COINS ] = empty ( uint256 [ BASE_N_COINS ]) base_inputs [ base_i ] = dx_w_fee coin_i : address = self . coins [ MAX_COIN ] # Deposit and measure delta x = ERC20 ( coin_i ) . balanceOf ( self ) Curve ( _base_pool ) . add_liquidity ( base_inputs , 0 ) # Need to convert pool token to \"virtual\" units using rates # dx is also different now dx_w_fee = ERC20 ( coin_i ) . balanceOf ( self ) - x x = dx_w_fee * rates [ MAX_COIN ] / PRECISION # Adding number of pool tokens x += xp [ MAX_COIN ] y : uint256 = self . get_y ( meta_i , meta_j , x , xp ) # Either a real coin or token dy = xp [ meta_j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units # Works for both pool coins and real coins dy = ( dy - dy_fee ) * PRECISION / rates [ meta_j ] dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ meta_j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ meta_i ] = old_balances [ meta_i ] + dx_w_fee # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ meta_j ] = old_balances [ meta_j ] - dy - dy_admin_fee # Withdraw from the base pool if needed if base_j >= 0 : out_amount : uint256 = ERC20 ( output_coin ) . balanceOf ( self ) Curve ( _base_pool ) . remove_liquidity_one_coin ( dy , base_j , 0 ) dy = ERC20 ( output_coin ) . balanceOf ( self ) - out_amount assert dy >= min_dy , \"Too few coins in result\" else : # If both are from the base pool dy = ERC20 ( output_coin ) . balanceOf ( self ) Curve ( _base_pool ) . exchange ( base_i , base_j , dx_w_fee , min_dy ) dy = ERC20 ( output_coin ) . balanceOf ( self ) - dy # \"safeTransfer\" which works for ERC20s which return bool or not _response = raw_call ( output_coin , concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # dev: failed transfer # end \"safeTransfer\" log TokenExchangeUnderlying ( msg . sender , i , dx , j , dy ) return dy Example >>> lending_pool.exchange_underlying () todo: console output","title":"StableSwap.exchange_underlying"},{"location":"stableswap_exchange/pools/overview/","text":"A Curve pool is a smart contract that implements the StableSwap invariant and thereby allows for the exchange of two or more tokens. More broadly, Curve pools can be split into three categories: Plain Pools : A pool where two or more stablecoins are paired against each other. Lending Pools : A pool where two or more wrapped tokens (e.g. cDAI ) are paired against one another, while the underlying is lent out on some other protocol. Metapools : A pool where a stablecoin is paired against the LP token from another pool. Source code for Curve pools may be viewed on GitHub . Warning The API for plain, lending and metapools applies to all pools that are implemented based on pool templates . When interacting with older Curve pools, there may be differences in terms of visibility, gas efficiency and/or variable naming. Furthermore, note that older contracts use vyper 0.1.x... and that the getters generated for public arrays changed between 0.1.x and 0.2.x to accept uint256 instead of int128 in order to handle the lookups. Please do not assume for a Curve pool to implement the API outlined in this section but verify this before interacting with a pool contract. For information on code style please refer to the official style guide .","title":"Overview"},{"location":"stableswap_exchange/pools/plain_pools/","text":"Overview \u00b6 The simplest Curve pool is a plain pool, which is an implementation of the StableSwap invariant for two or more tokens. The key characteristic of a plain pool is that the pool contract holds all deposited assets at all times. An example of a Curve plain pool is 3Pool , which contains the tokens DAI , USDC and USDT . Note The API of plain pools is also implemented by lending and metapools. The following Brownie console interaction examples are using EURS Pool. The template source code for plain pools may be viewed on GitHub . Pool Info Methods \u00b6 StableSwap.coins \u00b6 StableSwap.coins(i: uint256) \u2192 address: view Getter for the array of swappable coins within the pool. Returns: coin address ( address ) for coin index i . Input Type Description i uint256 Coin index Source code coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.coin ( 0 ) '0xdB25f211AB05b1c97D595516F45794528a807ad8' StableSwap.balances \u00b6 StableSwap.balances(i: uint256) \u2192 uint256: view Getter for the pool balances array. Returns: Balance of coin ( uint256 ) at index i . Input Type Description i uint256 Coin index Example >>> pool.balances ( 0 ) 2918187395 StableSwap.owner \u00b6 StableSwap.owner() \u2192 address: view Getter for the admin/owner of the pool contract. Returns: address of the admin of the pool contract. Source code owner : public ( address ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.owner () '0xeCb456EA5365865EbAb8a2661B0c503410e9B347' StableSwap.lp_token \u00b6 StableSwap.lp_token() \u2192 address: view Getter for the LP token of the pool. Returns: address of the lp_token . Example >>> pool.lp_token () '0x194eBd173F6cDacE046C53eACcE9B953F28411d1' Note In older Curve pools lp_token may not be public and thus not visible. StableSwap.A (Amplification factor) \u00b6 StableSwap.A() \u2192 uint256: view Getter for the amplification coefficient of the pool. Source code A_PRECISION : constant ( uint256 ) = 100 ... @view @external def A () -> uint256 : return self . _A () / A_PRECISION Example >>> pool.A () 100 Note The amplification coefficient is scaled by A_PRECISION ( =100 ) StableSwap.A_precise \u00b6 StableSwap.A_precise() \u2192 uint256: view Getter for the unscaled amplification coefficient of the pool. Source code @view @external def A_precise () -> uint256 : return self . _A () Example >>> pool.A () 10000 StableSwap.get_virtual_price \u00b6 StableSwap.get_virtual_price() \u2192 uint256: view Current virtual price of the pool LP token relative to the underlying pool assets. Source code @view @external def get_virtual_price () -> uint256 : \"\"\" @notice The current virtual price of the pool LP token @dev Useful for calculating profits @return LP token virtual price normalized to 1e18 \"\"\" D : uint256 = self . get_D ( self . _xp (), self . _A ()) # D is in the units similar to DAI (e.g. converted to precision 1e18) # When balanced, D = n * x_u - total virtual value of the portfolio token_supply : uint256 = ERC20 ( self . lp_token ) . totalSupply () return D * PRECISION / token_supply Example >>> pool.get_virtual_price () 1001692838188850782 Note The method returns virtual_price as an integer with 1e18 precision. virtual_price returns a price relative to the underlying. You can get the absolute price by multiplying it with the price of the underlying assets. StableSwap.fee \u00b6 StableSwap.fee() \u2192 uint256: view The pool swap fee. Source code fee : public ( uint256 ) # fee * 1e10 ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.fee () 4000000 Note The method returns fee as an integer with 1e10 precision. StableSwap.admin_fee \u00b6 StableSwap.admin_fee() \u2192 uint256: view The percentage of the swap fee that is taken as an admin fee. Source code admin_fee : public ( uint256 ) # admin_fee * 1e10 ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.admin_fee () 5000000000 Note The method returns an integer with with 1e10 precision. Admin fee is set at 50% ( 5000000000 ) and is paid out to veCRV holders. Exchange Methods \u00b6 StableSwap.get_dy \u00b6 StableSwap.get_dy(i: int128, j: int128, _dx: uint256) \u2192 uint256: view Get the amount of coin j one would receive for swapping dx of coin i . Input Type Description i uint128 Index of coin to swap from j uint128 Index of coin to swap to dx uint256 Amount of coin i to swap Source code @view @external def get_dy ( i : int128 , j : int128 , dx : uint256 ) -> uint256 : xp : uint256 [ N_COINS ] = self . _xp () rates : uint256 [ N_COINS ] = RATES x : uint256 = xp [ i ] + ( dx * rates [ i ] / PRECISION ) y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = ( xp [ j ] - y - 1 ) _fee : uint256 = self . fee * dy / FEE_DENOMINATOR return ( dy - _fee ) * PRECISION / rates [ j ] Example >>> pool.get_dy ( 0 , 1 , 100 ) 996307731416690125 Note Note: In this example, the EURS Pool coins decimals for coins(0) and coins(1) are 2 and 18 , respectively. StableSwap.exchange \u00b6 StableSwap.exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) \u2192 uint256 Perform an exchange between two coins. Input Type Description i uint128 Index of coin to swap from j uint128 Index of coin to swap to dx uint256 Amount of coin i to swap min_dy uint256 Minimum amount of j to receive Returns the actual amount of coin j received. Index values can be found via the coins public getter method. Emits: TokenExchange Source code @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( old_balances ) rates : uint256 [ N_COINS ] = RATES x : uint256 = xp [ i ] + dx * rates [ i ] / PRECISION y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = xp [ j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units dy = ( dy - dy_fee ) * PRECISION / rates [ j ] assert dy >= min_dy , \"Exchange resulted in fewer coins than expected\" dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ i ] = old_balances [ i ] + dx # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ j ] = old_balances [ j ] - dy - dy_admin_fee # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( self . coins [ j ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log TokenExchange ( msg . sender , i , dx , j , dy ) return dy Example >>> expected = pool.get_dy ( 0 , 1 , 10 **2 ) * 0 .99 >>> pool.exchange ( 0 , 1 , 10 **2, expected, { \"from\" : alice }) Add/Remove Liquidity Methods \u00b6 StableSwap.calc_token_amount \u00b6 StableSwap.calc_token_amount(_amounts: uint256[N_COINS], _: bool) \u2192 uint256: view Calculate addition or reduction in token supply from a deposit or withdrawal. Returns the expected amount of LP tokens received. This calculation accounts for slippage, but not fees. N_COINS : Number of coins in the pool. Input Type Description amounts uint256[N_COINS] Amount of each coin being deposited is_deposit bool Set True for deposits, False for withdrawals Source code @view @external def calc_token_amount ( amounts : uint256 [ N_COINS ], is_deposit : bool ) -> uint256 : \"\"\" @notice Calculate addition or reduction in token supply from a deposit or withdrawal @dev This calculation accounts for slippage, but not fees. Needed to prevent front-running, not for precise calculations! @param amounts Amount of each coin being deposited @param is_deposit set True for deposits, False for withdrawals @return Expected amount of LP tokens received \"\"\" amp : uint256 = self . _A () _balances : uint256 [ N_COINS ] = self . balances D0 : uint256 = self . get_D_mem ( _balances , amp ) for i in range ( N_COINS ): if is_deposit : _balances [ i ] += amounts [ i ] else : _balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( _balances , amp ) token_amount : uint256 = ERC20 ( self . lp_token ) . totalSupply () diff : uint256 = 0 if is_deposit : diff = D1 - D0 else : diff = D0 - D1 return diff * token_amount / D0 Example >>> pool.calc_token_amount ([ 10 **2, 10 **18 ] , True ) 1996887509167925969 StableSwap.add_liquidity \u00b6 StableSwap.add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) \u2192 uint256 Deposit coins into the pool. Returns the amount of LP tokens received in exchange for the deposited tokens. Input Type Description amounts uint256[N_COINS] Amount of each coin being deposited min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit Emits: AddLiquidity Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # dev: initial deposit requires all coins # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) if token_supply > 0 : # Only account for fees if we are not the first to deposit _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( new_balances , amp ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if amounts [ i ] > 0 : # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # Mint pool tokens CurveToken ( _lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> todo: add_liquidity console output example StableSwap.remove_liquidity \u00b6 StableSwap.remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) \u2192 uint256[N_COINS] Withdraw coins from the pool. Returns a list of the amounts for each coin that was withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal min_amounts `uint256[N_COINS]`` Minimum amounts of underlying coins to receive Emits: RemoveLiquidity Source code @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param min_amounts Minimum amounts of underlying coins to receive @return List of amounts of coins that were withdrawn \"\"\" _lp_token : address = self . lp_token total_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Fees are unused but we've got them historically in event for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( value , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) CurveToken ( _lp_token ) . burnFrom ( msg . sender , _amount ) # dev: insufficient funds log RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) return amounts Example >>> todo: remove_liquidity console output example StableSwap.remove_liquidity_imbalance \u00b6 StableSwap.remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) \u2192 uint256 Withdraw coins from the pool in an imbalanced amount. Returns a list of the amounts for each coin that was withdrawn. Input Type Description amounts uint256[N_COINS] List of amounts of underlying coins to withdraw max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: RemoveLiquidityImbalance Source code @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( old_balances , amp ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( new_balances , amp ) _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () assert token_supply != 0 # dev: zero total supply _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( new_balances , amp ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount != 0 # dev: zero tokens burned token_amount += 1 # In case of rounding errors - make it unfavorable for the \"attacker\" assert token_amount <= max_burn_amount , \"Slippage screwed you\" CurveToken ( _lp_token ) . burnFrom ( msg . sender , token_amount ) # dev: insufficient funds for i in range ( N_COINS ): if amounts [ i ] != 0 : _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) return token_amount Example >>> todo: remove_liquidity_imbalance console output example StableSwap.calc_withdraw_one_coin \u00b6 StableSwap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing a single coin. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw Source code @view @internal def _calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> ( uint256 , uint256 , uint256 ): # First, need to calculate # * Get current D # * Solve Eqn against y_i for D - _token_amount amp : uint256 = self . _A () xp : uint256 [ N_COINS ] = self . _xp () D0 : uint256 = self . get_D ( xp , amp ) total_supply : uint256 = ERC20 ( self . lp_token ) . totalSupply () D1 : uint256 = D0 - _token_amount * D0 / total_supply new_y : uint256 = self . get_y_D ( amp , i , xp , D1 ) xp_reduced : uint256 [ N_COINS ] = xp _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) for j in range ( N_COINS ): dx_expected : uint256 = 0 if j == i : dx_expected = xp [ j ] * D1 / D0 - new_y else : dx_expected = xp [ j ] - xp [ j ] * D1 / D0 xp_reduced [ j ] -= _fee * dx_expected / FEE_DENOMINATOR dy : uint256 = xp_reduced [ i ] - self . get_y_D ( amp , i , xp_reduced , D1 ) precisions : uint256 [ N_COINS ] = PRECISION_MUL dy = ( dy - 1 ) / precisions [ i ] # Withdraw less to account for rounding errors dy_0 : uint256 = ( xp [ i ] - new_y ) / precisions [ i ] # w/o fees return dy , dy_0 - dy , total_supply @view @external def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : \"\"\" @notice Calculate the amount received when withdrawing a single coin @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @return Amount of coin received \"\"\" return self . _calc_withdraw_one_coin ( _token_amount , i )[ 0 ] Example >>> todo: calculate_withdraw_one_coin console output example StableSwap.remove_liquidity_one_coin \u00b6 StableSwap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) \u2192 uint256 Withdraw a single coin from the pool. Returns the amount of coin i received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_amount uint256 Minimum amount of coin to receive Emits: RemoveLiquidityOne Source code @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed dy : uint256 = 0 dy_fee : uint256 = 0 total_supply : uint256 = 0 dy , dy_fee , total_supply = self . _calc_withdraw_one_coin ( _token_amount , i ) assert dy >= _min_amount , \"Not enough coins removed\" self . balances [ i ] -= ( dy + dy_fee * self . admin_fee / FEE_DENOMINATOR ) CurveToken ( self . lp_token ) . burnFrom ( msg . sender , _token_amount ) # dev: insufficient funds _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityOne ( msg . sender , _token_amount , dy , total_supply - _token_amount ) return dy Example >>> todo: remove_liquidity_one_coin console output example","title":"Plain Pools"},{"location":"stableswap_exchange/pools/plain_pools/#overview","text":"The simplest Curve pool is a plain pool, which is an implementation of the StableSwap invariant for two or more tokens. The key characteristic of a plain pool is that the pool contract holds all deposited assets at all times. An example of a Curve plain pool is 3Pool , which contains the tokens DAI , USDC and USDT . Note The API of plain pools is also implemented by lending and metapools. The following Brownie console interaction examples are using EURS Pool. The template source code for plain pools may be viewed on GitHub .","title":"Overview"},{"location":"stableswap_exchange/pools/plain_pools/#pool-info-methods","text":"","title":"Pool Info Methods"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapcoins","text":"StableSwap.coins(i: uint256) \u2192 address: view Getter for the array of swappable coins within the pool. Returns: coin address ( address ) for coin index i . Input Type Description i uint256 Coin index Source code coins : public ( address [ N_COINS ]) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.coin ( 0 ) '0xdB25f211AB05b1c97D595516F45794528a807ad8'","title":"StableSwap.coins"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapbalances","text":"StableSwap.balances(i: uint256) \u2192 uint256: view Getter for the pool balances array. Returns: Balance of coin ( uint256 ) at index i . Input Type Description i uint256 Coin index Example >>> pool.balances ( 0 ) 2918187395","title":"StableSwap.balances"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapowner","text":"StableSwap.owner() \u2192 address: view Getter for the admin/owner of the pool contract. Returns: address of the admin of the pool contract. Source code owner : public ( address ) ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 contracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.owner () '0xeCb456EA5365865EbAb8a2661B0c503410e9B347'","title":"StableSwap.owner"},{"location":"stableswap_exchange/pools/plain_pools/#stableswaplp_token","text":"StableSwap.lp_token() \u2192 address: view Getter for the LP token of the pool. Returns: address of the lp_token . Example >>> pool.lp_token () '0x194eBd173F6cDacE046C53eACcE9B953F28411d1' Note In older Curve pools lp_token may not be public and thus not visible.","title":"StableSwap.lp_token"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapa-amplification-factor","text":"StableSwap.A() \u2192 uint256: view Getter for the amplification coefficient of the pool. Source code A_PRECISION : constant ( uint256 ) = 100 ... @view @external def A () -> uint256 : return self . _A () / A_PRECISION Example >>> pool.A () 100 Note The amplification coefficient is scaled by A_PRECISION ( =100 )","title":"StableSwap.A (Amplification factor)"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapa_precise","text":"StableSwap.A_precise() \u2192 uint256: view Getter for the unscaled amplification coefficient of the pool. Source code @view @external def A_precise () -> uint256 : return self . _A () Example >>> pool.A () 10000","title":"StableSwap.A_precise"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapget_virtual_price","text":"StableSwap.get_virtual_price() \u2192 uint256: view Current virtual price of the pool LP token relative to the underlying pool assets. Source code @view @external def get_virtual_price () -> uint256 : \"\"\" @notice The current virtual price of the pool LP token @dev Useful for calculating profits @return LP token virtual price normalized to 1e18 \"\"\" D : uint256 = self . get_D ( self . _xp (), self . _A ()) # D is in the units similar to DAI (e.g. converted to precision 1e18) # When balanced, D = n * x_u - total virtual value of the portfolio token_supply : uint256 = ERC20 ( self . lp_token ) . totalSupply () return D * PRECISION / token_supply Example >>> pool.get_virtual_price () 1001692838188850782 Note The method returns virtual_price as an integer with 1e18 precision. virtual_price returns a price relative to the underlying. You can get the absolute price by multiplying it with the price of the underlying assets.","title":"StableSwap.get_virtual_price"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapfee","text":"StableSwap.fee() \u2192 uint256: view The pool swap fee. Source code fee : public ( uint256 ) # fee * 1e10 ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.fee () 4000000 Note The method returns fee as an integer with 1e10 precision.","title":"StableSwap.fee"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapadmin_fee","text":"StableSwap.admin_fee() \u2192 uint256: view The percentage of the swap fee that is taken as an admin fee. Source code admin_fee : public ( uint256 ) # admin_fee * 1e10 ... @external def __init__ ( _owner : address , _coins : address [ N_COINS ], _pool_token : address , _A : uint256 , _fee : uint256 , _admin_fee : uint256 ): \"\"\" @notice Contract constructor @param _owner Contract owner address @param _coins Addresses of ERC20 conracts of coins @param _pool_token Address of the token representing LP share @param _A Amplification coefficient multiplied by n * (n - 1) @param _fee Fee to charge for exchanges @param _admin_fee Admin fee \"\"\" for i in range ( N_COINS ): assert _coins [ i ] != ZERO_ADDRESS self . coins = _coins self . initial_A = _A * A_PRECISION self . future_A = _A * A_PRECISION self . fee = _fee self . admin_fee = _admin_fee self . owner = _owner self . kill_deadline = block . timestamp + KILL_DEADLINE_DT self . lp_token = _pool_token Example >>> pool.admin_fee () 5000000000 Note The method returns an integer with with 1e10 precision. Admin fee is set at 50% ( 5000000000 ) and is paid out to veCRV holders.","title":"StableSwap.admin_fee"},{"location":"stableswap_exchange/pools/plain_pools/#exchange-methods","text":"","title":"Exchange Methods"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapget_dy","text":"StableSwap.get_dy(i: int128, j: int128, _dx: uint256) \u2192 uint256: view Get the amount of coin j one would receive for swapping dx of coin i . Input Type Description i uint128 Index of coin to swap from j uint128 Index of coin to swap to dx uint256 Amount of coin i to swap Source code @view @external def get_dy ( i : int128 , j : int128 , dx : uint256 ) -> uint256 : xp : uint256 [ N_COINS ] = self . _xp () rates : uint256 [ N_COINS ] = RATES x : uint256 = xp [ i ] + ( dx * rates [ i ] / PRECISION ) y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = ( xp [ j ] - y - 1 ) _fee : uint256 = self . fee * dy / FEE_DENOMINATOR return ( dy - _fee ) * PRECISION / rates [ j ] Example >>> pool.get_dy ( 0 , 1 , 100 ) 996307731416690125 Note Note: In this example, the EURS Pool coins decimals for coins(0) and coins(1) are 2 and 18 , respectively.","title":"StableSwap.get_dy"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapexchange","text":"StableSwap.exchange(i: int128, j: int128, dx: uint256, min_dy: uint256) \u2192 uint256 Perform an exchange between two coins. Input Type Description i uint128 Index of coin to swap from j uint128 Index of coin to swap to dx uint256 Amount of coin i to swap min_dy uint256 Minimum amount of j to receive Returns the actual amount of coin j received. Index values can be found via the coins public getter method. Emits: TokenExchange Source code @external @nonreentrant ( 'lock' ) def exchange ( i : int128 , j : int128 , dx : uint256 , min_dy : uint256 ) -> uint256 : \"\"\" @notice Perform an exchange between two coins @dev Index values can be found via the `coins` public getter method @param i Index value for the coin to send @param j Index valie of the coin to recieve @param dx Amount of `i` being exchanged @param min_dy Minimum amount of `j` to receive @return Actual amount of `j` received \"\"\" assert not self . is_killed # dev: is killed old_balances : uint256 [ N_COINS ] = self . balances xp : uint256 [ N_COINS ] = self . _xp_mem ( old_balances ) rates : uint256 [ N_COINS ] = RATES x : uint256 = xp [ i ] + dx * rates [ i ] / PRECISION y : uint256 = self . get_y ( i , j , x , xp ) dy : uint256 = xp [ j ] - y - 1 # -1 just in case there were some rounding errors dy_fee : uint256 = dy * self . fee / FEE_DENOMINATOR # Convert all to real units dy = ( dy - dy_fee ) * PRECISION / rates [ j ] assert dy >= min_dy , \"Exchange resulted in fewer coins than expected\" dy_admin_fee : uint256 = dy_fee * self . admin_fee / FEE_DENOMINATOR dy_admin_fee = dy_admin_fee * PRECISION / rates [ j ] # Change balances exactly in same way as we change actual ERC20 coin amounts self . balances [ i ] = old_balances [ i ] + dx # When rounding errors happen, we undercharge admin fee in favor of LP self . balances [ j ] = old_balances [ j ] - dy - dy_admin_fee # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( dx , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) _response = raw_call ( self . coins [ j ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log TokenExchange ( msg . sender , i , dx , j , dy ) return dy Example >>> expected = pool.get_dy ( 0 , 1 , 10 **2 ) * 0 .99 >>> pool.exchange ( 0 , 1 , 10 **2, expected, { \"from\" : alice })","title":"StableSwap.exchange"},{"location":"stableswap_exchange/pools/plain_pools/#addremove-liquidity-methods","text":"","title":"Add/Remove Liquidity Methods"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapcalc_token_amount","text":"StableSwap.calc_token_amount(_amounts: uint256[N_COINS], _: bool) \u2192 uint256: view Calculate addition or reduction in token supply from a deposit or withdrawal. Returns the expected amount of LP tokens received. This calculation accounts for slippage, but not fees. N_COINS : Number of coins in the pool. Input Type Description amounts uint256[N_COINS] Amount of each coin being deposited is_deposit bool Set True for deposits, False for withdrawals Source code @view @external def calc_token_amount ( amounts : uint256 [ N_COINS ], is_deposit : bool ) -> uint256 : \"\"\" @notice Calculate addition or reduction in token supply from a deposit or withdrawal @dev This calculation accounts for slippage, but not fees. Needed to prevent front-running, not for precise calculations! @param amounts Amount of each coin being deposited @param is_deposit set True for deposits, False for withdrawals @return Expected amount of LP tokens received \"\"\" amp : uint256 = self . _A () _balances : uint256 [ N_COINS ] = self . balances D0 : uint256 = self . get_D_mem ( _balances , amp ) for i in range ( N_COINS ): if is_deposit : _balances [ i ] += amounts [ i ] else : _balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( _balances , amp ) token_amount : uint256 = ERC20 ( self . lp_token ) . totalSupply () diff : uint256 = 0 if is_deposit : diff = D1 - D0 else : diff = D0 - D1 return diff * token_amount / D0 Example >>> pool.calc_token_amount ([ 10 **2, 10 **18 ] , True ) 1996887509167925969","title":"StableSwap.calc_token_amount"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapadd_liquidity","text":"StableSwap.add_liquidity(amounts: uint256[N_COINS], min_mint_amount: uint256) \u2192 uint256 Deposit coins into the pool. Returns the amount of LP tokens received in exchange for the deposited tokens. Input Type Description amounts uint256[N_COINS] Amount of each coin being deposited min_mint_amount uint256 Minimum amount of LP tokens to mint from the deposit Emits: AddLiquidity Source code @external @nonreentrant ( 'lock' ) def add_liquidity ( amounts : uint256 [ N_COINS ], min_mint_amount : uint256 ) -> uint256 : \"\"\" @notice Deposit coins into the pool @param amounts List of amounts of coins to deposit @param min_mint_amount Minimum amount of LP tokens to mint from the deposit @return Amount of LP tokens received by depositing \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () # Initial invariant D0 : uint256 = 0 old_balances : uint256 [ N_COINS ] = self . balances if token_supply > 0 : D0 = self . get_D_mem ( old_balances , amp ) new_balances : uint256 [ N_COINS ] = old_balances for i in range ( N_COINS ): if token_supply == 0 : assert amounts [ i ] > 0 # dev: initial deposit requires all coins # balances store amounts of c-tokens new_balances [ i ] = old_balances [ i ] + amounts [ i ] # Invariant after change D1 : uint256 = self . get_D_mem ( new_balances , amp ) assert D1 > D0 # We need to recalculate the invariant accounting for fees # to calculate fair user's share D2 : uint256 = D1 fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) if token_supply > 0 : # Only account for fees if we are not the first to deposit _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 = self . get_D_mem ( new_balances , amp ) else : self . balances = new_balances # Calculate, how much pool tokens to mint mint_amount : uint256 = 0 if token_supply == 0 : mint_amount = D1 # Take the dust if there was any else : mint_amount = token_supply * ( D2 - D0 ) / D0 assert mint_amount >= min_mint_amount , \"Slippage screwed you\" # Take coins from the sender for i in range ( N_COINS ): if amounts [ i ] > 0 : # \"safeTransferFrom\" which works for ERC20s which return bool or not _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transferFrom(address,address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( self , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) # Mint pool tokens CurveToken ( _lp_token ) . mint ( msg . sender , mint_amount ) log AddLiquidity ( msg . sender , amounts , fees , D1 , token_supply + mint_amount ) return mint_amount Example >>> todo: add_liquidity console output example","title":"StableSwap.add_liquidity"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapremove_liquidity","text":"StableSwap.remove_liquidity(_amount: uint256, min_amounts: uint256[N_COINS]) \u2192 uint256[N_COINS] Withdraw coins from the pool. Returns a list of the amounts for each coin that was withdrawn. Input Type Description _amount uint256 Quantity of LP tokens to burn in the withdrawal min_amounts `uint256[N_COINS]`` Minimum amounts of underlying coins to receive Emits: RemoveLiquidity Source code @external @nonreentrant ( 'lock' ) def remove_liquidity ( _amount : uint256 , min_amounts : uint256 [ N_COINS ]) -> uint256 [ N_COINS ]: \"\"\" @notice Withdraw coins from the pool @dev Withdrawal amounts are based on current deposit ratios @param _amount Quantity of LP tokens to burn in the withdrawal @param min_amounts Minimum amounts of underlying coins to receive @return List of amounts of coins that were withdrawn \"\"\" _lp_token : address = self . lp_token total_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () amounts : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) # Fees are unused but we've got them historically in event for i in range ( N_COINS ): value : uint256 = self . balances [ i ] * _amount / total_supply assert value >= min_amounts [ i ], \"Withdrawal resulted in fewer coins than expected\" self . balances [ i ] -= value amounts [ i ] = value _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( value , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) CurveToken ( _lp_token ) . burnFrom ( msg . sender , _amount ) # dev: insufficient funds log RemoveLiquidity ( msg . sender , amounts , fees , total_supply - _amount ) return amounts Example >>> todo: remove_liquidity console output example","title":"StableSwap.remove_liquidity"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapremove_liquidity_imbalance","text":"StableSwap.remove_liquidity_imbalance(amounts: uint256[N_COINS], max_burn_amount: uint256) \u2192 uint256 Withdraw coins from the pool in an imbalanced amount. Returns a list of the amounts for each coin that was withdrawn. Input Type Description amounts uint256[N_COINS] List of amounts of underlying coins to withdraw max_burn_amount uint256 Maximum amount of LP token to burn in the withdrawal Emits: RemoveLiquidityImbalance Source code @external @nonreentrant ( 'lock' ) def remove_liquidity_imbalance ( amounts : uint256 [ N_COINS ], max_burn_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw coins from the pool in an imbalanced amount @param amounts List of amounts of underlying coins to withdraw @param max_burn_amount Maximum amount of LP token to burn in the withdrawal @return Actual amount of the LP token burned in the withdrawal \"\"\" assert not self . is_killed # dev: is killed amp : uint256 = self . _A () old_balances : uint256 [ N_COINS ] = self . balances new_balances : uint256 [ N_COINS ] = old_balances D0 : uint256 = self . get_D_mem ( old_balances , amp ) for i in range ( N_COINS ): new_balances [ i ] -= amounts [ i ] D1 : uint256 = self . get_D_mem ( new_balances , amp ) _lp_token : address = self . lp_token token_supply : uint256 = ERC20 ( _lp_token ) . totalSupply () assert token_supply != 0 # dev: zero total supply _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) _admin_fee : uint256 = self . admin_fee fees : uint256 [ N_COINS ] = empty ( uint256 [ N_COINS ]) for i in range ( N_COINS ): ideal_balance : uint256 = D1 * old_balances [ i ] / D0 difference : uint256 = 0 if ideal_balance > new_balances [ i ]: difference = ideal_balance - new_balances [ i ] else : difference = new_balances [ i ] - ideal_balance fees [ i ] = _fee * difference / FEE_DENOMINATOR self . balances [ i ] = new_balances [ i ] - ( fees [ i ] * _admin_fee / FEE_DENOMINATOR ) new_balances [ i ] -= fees [ i ] D2 : uint256 = self . get_D_mem ( new_balances , amp ) token_amount : uint256 = ( D0 - D2 ) * token_supply / D0 assert token_amount != 0 # dev: zero tokens burned token_amount += 1 # In case of rounding errors - make it unfavorable for the \"attacker\" assert token_amount <= max_burn_amount , \"Slippage screwed you\" CurveToken ( _lp_token ) . burnFrom ( msg . sender , token_amount ) # dev: insufficient funds for i in range ( N_COINS ): if amounts [ i ] != 0 : _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( amounts [ i ], bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityImbalance ( msg . sender , amounts , fees , D1 , token_supply - token_amount ) return token_amount Example >>> todo: remove_liquidity_imbalance console output example","title":"StableSwap.remove_liquidity_imbalance"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapcalc_withdraw_one_coin","text":"StableSwap.calc_withdraw_one_coin(_token_amount: uint256, i: int128) \u2192 uint256 Calculate the amount received when withdrawing a single coin. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw Source code @view @internal def _calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> ( uint256 , uint256 , uint256 ): # First, need to calculate # * Get current D # * Solve Eqn against y_i for D - _token_amount amp : uint256 = self . _A () xp : uint256 [ N_COINS ] = self . _xp () D0 : uint256 = self . get_D ( xp , amp ) total_supply : uint256 = ERC20 ( self . lp_token ) . totalSupply () D1 : uint256 = D0 - _token_amount * D0 / total_supply new_y : uint256 = self . get_y_D ( amp , i , xp , D1 ) xp_reduced : uint256 [ N_COINS ] = xp _fee : uint256 = self . fee * N_COINS / ( 4 * ( N_COINS - 1 )) for j in range ( N_COINS ): dx_expected : uint256 = 0 if j == i : dx_expected = xp [ j ] * D1 / D0 - new_y else : dx_expected = xp [ j ] - xp [ j ] * D1 / D0 xp_reduced [ j ] -= _fee * dx_expected / FEE_DENOMINATOR dy : uint256 = xp_reduced [ i ] - self . get_y_D ( amp , i , xp_reduced , D1 ) precisions : uint256 [ N_COINS ] = PRECISION_MUL dy = ( dy - 1 ) / precisions [ i ] # Withdraw less to account for rounding errors dy_0 : uint256 = ( xp [ i ] - new_y ) / precisions [ i ] # w/o fees return dy , dy_0 - dy , total_supply @view @external def calc_withdraw_one_coin ( _token_amount : uint256 , i : int128 ) -> uint256 : \"\"\" @notice Calculate the amount received when withdrawing a single coin @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @return Amount of coin received \"\"\" return self . _calc_withdraw_one_coin ( _token_amount , i )[ 0 ] Example >>> todo: calculate_withdraw_one_coin console output example","title":"StableSwap.calc_withdraw_one_coin"},{"location":"stableswap_exchange/pools/plain_pools/#stableswapremove_liquidity_one_coin","text":"StableSwap.remove_liquidity_one_coin(_token_amount: uint256, i: int128, _min_amount: uint256) \u2192 uint256 Withdraw a single coin from the pool. Returns the amount of coin i received. Input Type Description _token_amount uint256 Amount of LP tokens to burn in the withdrawal i int128 Index value of the coin to withdraw _min_amount uint256 Minimum amount of coin to receive Emits: RemoveLiquidityOne Source code @external @nonreentrant ( 'lock' ) def remove_liquidity_one_coin ( _token_amount : uint256 , i : int128 , _min_amount : uint256 ) -> uint256 : \"\"\" @notice Withdraw a single coin from the pool @param _token_amount Amount of LP tokens to burn in the withdrawal @param i Index value of the coin to withdraw @param _min_amount Minimum amount of coin to receive @return Amount of coin received \"\"\" assert not self . is_killed # dev: is killed dy : uint256 = 0 dy_fee : uint256 = 0 total_supply : uint256 = 0 dy , dy_fee , total_supply = self . _calc_withdraw_one_coin ( _token_amount , i ) assert dy >= _min_amount , \"Not enough coins removed\" self . balances [ i ] -= ( dy + dy_fee * self . admin_fee / FEE_DENOMINATOR ) CurveToken ( self . lp_token ) . burnFrom ( msg . sender , _token_amount ) # dev: insufficient funds _response : Bytes [ 32 ] = raw_call ( self . coins [ i ], concat ( method_id ( \"transfer(address,uint256)\" ), convert ( msg . sender , bytes32 ), convert ( dy , bytes32 ), ), max_outsize = 32 , ) # dev: failed transfer if len ( _response ) > 0 : assert convert ( _response , bool ) log RemoveLiquidityOne ( msg . sender , _token_amount , dy , total_supply - _token_amount ) return dy Example >>> todo: remove_liquidity_one_coin console output example","title":"StableSwap.remove_liquidity_one_coin"}]}